{"version":3,"sources":["../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isFunction.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/createErrorClass.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/arrRemove.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/Subscription.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/config.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/reportUnhandledError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/noop.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/NotificationFactories.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/errorContext.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/Subscriber.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/symbol/observable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/identity.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/pipe.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/Observable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/lift.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/OperatorSubscriber.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/refCount.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/ConnectableObservable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/performanceTimestampProvider.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/animationFrameProvider.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/dom/animationFrames.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/Subject.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/BehaviorSubject.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/dateTimestampProvider.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/ReplaySubject.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/AsyncSubject.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/Action.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/intervalProvider.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/Immediate.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/immediateProvider.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/AsapAction.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/Scheduler.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/asap.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/async.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/QueueAction.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/queue.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/animationFrame.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/empty.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isScheduler.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/args.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isArrayLike.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isPromise.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isInteropObservable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isAsyncIterable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/throwUnobservableError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/symbol/iterator.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isIterable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isReadableStreamLike.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/innerFrom.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/executeSchedule.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/observeOn.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/subscribeOn.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduled/scheduleObservable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduled/schedulePromise.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduled/scheduleArray.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduled/scheduleIterable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduled/scheduleAsyncIterable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/scheduled/scheduled.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/from.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/of.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/throwError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/Notification.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isObservable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/EmptyError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/lastValueFrom.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/firstValueFrom.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/NotFoundError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/SequenceError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/isDate.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/timeout.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/map.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/mapOneOrManyArgs.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/bindCallbackInternals.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/bindCallback.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/bindNodeCallback.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/argsArgArrayOrObject.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/createObject.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/combineLatest.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeInternals.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeMap.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeAll.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/concatAll.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/concat.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/defer.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/connectable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/forkJoin.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/fromEvent.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/fromEventPattern.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/generate.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/iif.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/timer.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/interval.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/merge.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/never.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/argsOrArgArray.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/onErrorResumeNext.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/pairs.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/util/not.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/filter.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/partition.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/race.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/range.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/using.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/zip.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/types.js","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/audit.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/auditTime.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/buffer.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/bufferCount.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/bufferTime.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/bufferToggle.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/bufferWhen.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/catchError.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/scanInternals.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/reduce.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/toArray.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/joinAllInternals.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/combineLatestAll.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/combineAll.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/combineLatest.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/combineLatestWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/concatMap.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/concatMapTo.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/concat.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/concatWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/observable/fromSubscribable.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/connect.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/count.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/debounce.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/debounceTime.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/defaultIfEmpty.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/take.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/ignoreElements.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mapTo.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/delayWhen.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/delay.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/dematerialize.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/distinct.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/distinctUntilChanged.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/distinctUntilKeyChanged.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/throwIfEmpty.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/elementAt.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/endWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/every.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/exhaustMap.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/exhaustAll.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/exhaust.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/expand.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/finalize.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/find.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/findIndex.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/first.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/groupBy.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/isEmpty.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/takeLast.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/last.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/materialize.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/max.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/flatMap.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeMapTo.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeScan.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/merge.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/mergeWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/min.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/multicast.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/onErrorResumeNextWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/pairwise.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/pluck.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/publish.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/publishBehavior.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/publishLast.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/publishReplay.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/raceWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/repeat.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/repeatWhen.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/retry.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/retryWhen.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/sample.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/sampleTime.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/scan.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/sequenceEqual.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/share.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/shareReplay.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/single.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/skip.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/skipLast.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/skipUntil.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/skipWhile.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/startWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/switchMap.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/switchAll.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/switchMapTo.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/switchScan.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/takeUntil.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/takeWhile.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/tap.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/throttle.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/throttleTime.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/timeInterval.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/timeoutWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/timestamp.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/window.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/windowCount.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/windowTime.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/windowToggle.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/windowWhen.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/withLatestFrom.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/zipAll.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/zip.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/internal/operators/zipWith.ts","../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/src/index.ts","../src/wallet/bitte-wallet.ts","../src/wallet/constants.ts","../src/BitteWalletContext.tsx","../src/hooks/useNearPrice.ts"],"names":["isFunction","value","exports","createErrorClass","createImpl","_super","instance","ctorFunc","createErrorClass_1","errors","err","arrRemove","arr","item","index","isFunction_1","UnsubscriptionError_1","arrRemove_1","Subscription","initialTeardown","_parentage","_parentage_1","__values","_parentage_1_1","parent_1","initialFinalizer","e","_finalizers","_finalizers_1","_finalizers_1_1","finalizer","execFinalizer","__spreadArray","__read","teardown","_a","parent","empty","isSubscription","handler","timeout","args","_i","delegate","handle","config_1","timeoutProvider_1","reportUnhandledError","onUnhandledError","noop","createNotification","errorNotification","error","nextNotification","kind","context","errorContext","cb","isRoot","errorThrown","captureError","Subscription_1","reportUnhandledError_1","noop_1","NotificationFactories_1","errorContext_1","Subscriber","__extends","destination","_this","next","complete","SafeSubscriber","handleStoppedNotification","_bind","bind","fn","thisArg","ConsumerObserver","partialObserver","handleUnhandledError","observerOrNext","context_1","defaultErrorHandler","notification","subscriber","onStoppedNotification","identity","x","identity_1","pipe","fns","pipeFromArray","input","prev","Subscriber_1","observable_1","pipe_1","Observable","subscribe","operator","observable","isSubscriber","source","sink","promiseCtor","getPromiseCtor","resolve","reject","operations","isObserver","hasLift","operate","init","liftedSource","createOperatorSubscriber","onNext","onComplete","onError","onFinalize","OperatorSubscriber","shouldUnsubscribe","closed_1","lift_1","OperatorSubscriber_1","refCount","connection","refCounter","sharedConnection","conn","Observable_1","refCount_1","ConnectableObservable","subjectFactory","subject","_connection","subject_1","callback","request","cancel","timestamp","performanceTimestampProvider_1","animationFrameProvider_1","animationFrames","timestampProvider","animationFramesFactory","DEFAULT_ANIMATION_FRAMES","provider","start","id","run","now","ObjectUnsubscribedError_1","Subject","AnonymousSubject","_b","_c","observer","observers","hasError","isStopped","thrownError","Subject_1","BehaviorSubject","_value","subscription","dateTimestampProvider_1","ReplaySubject","_bufferSize","_windowTime","_timestampProvider","_buffer","_infiniteTimeWindow","copy","i","adjustedBufferSize","last","AsyncSubject","_hasValue","_isComplete","Action","scheduler","work","state","delay","Action_1","intervalProvider_1","AsyncAction","_id","_scheduler","_delay","errored","errorValue","actions","nextHandle","resolved","activeHandles","findAndClearHandle","Immediate_1","setImmediate","clearImmediate","AsyncAction_1","immediateProvider_1","AsapAction","Scheduler","schedulerActionCtor","Scheduler_1","AsyncScheduler","SchedulerAction","action","AsyncScheduler_1","AsapScheduler","flushId","AsapAction_1","AsapScheduler_1","QueueAction","QueueScheduler","QueueAction_1","QueueScheduler_1","AnimationFrameAction","AnimationFrameScheduler","AnimationFrameAction_1","AnimationFrameScheduler_1","VirtualTimeScheduler","maxFrames","VirtualAction","a","b","emptyScheduled","isScheduler","isScheduler_1","popResultSelector","popScheduler","popNumber","defaultValue","isPromise","isInteropObservable","isAsyncIterable","obj","createInvalidObservableTypeError","getSymbolIterator","iterator_1","isIterable","readableStreamLikeToAsyncGenerator","readableStream","reader","__await","done","isReadableStreamLike","isArrayLike_1","isPromise_1","isInteropObservable_1","isAsyncIterable_1","throwUnobservableError_1","isIterable_1","isReadableStreamLike_1","innerFrom","fromInteropObservable","fromArrayLike","fromPromise","fromAsyncIterable","fromIterable","fromReadableStreamLike","obs","array","promise","iterable","iterable_1","iterable_1_1","asyncIterable","process","asyncIterable_1","__asyncValues","asyncIterable_1_1","executeSchedule","parentSubscription","repeat","scheduleSubscription","executeSchedule_1","observeOn","subscribeOn","innerFrom_1","observeOn_1","subscribeOn_1","scheduleObservable","schedulePromise","scheduleArray","scheduleIterable","iterator","scheduleAsyncIterable","result","scheduleAsyncIterable_1","scheduleReadableStreamLike","scheduleObservable_1","schedulePromise_1","scheduleArray_1","scheduleIterable_1","scheduleReadableStreamLike_1","scheduled","scheduled_1","from","args_1","from_1","of","throwError","errorOrErrorFactory","errorFactory","empty_1","of_1","throwError_1","NotificationKind","Notification","observeNotification","nextHandler","errorHandler","completeHandler","nextOrObserver","_d","isObservable","EmptyError_1","lastValueFrom","config","hasConfig","firstValueFrom","message","isValidDate","async_1","isDate_1","info","schedulerArg","first","each","_with","timeoutErrorFactory","meta","originalSourceSubscription","timerSubscription","lastValue","seen","startTimer","map","project","map_1","isArray","callOrApply","mapOneOrManyArgs","mapOneOrManyArgs_1","AsyncSubject_1","bindCallbackInternals","isNodeStyle","callbackFunc","resultSelector","uninitialized","subs","isAsync_1","isComplete_1","results","bindCallbackInternals_1","bindCallback","bindNodeCallback","getPrototypeOf","objectProto","getKeys","argsArgArrayOrObject","first_1","isPOJO","keys","key","createObject","values","argsArgArrayOrObject_1","createObject_1","combineLatest","observables","combineLatestInit","valueTransform","maybeSchedule","length","active","remainingFirstValues","hasFirstValue","execute","mergeInternals","concurrent","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","bufferedValue","mergeInternals_1","mergeMap","ii","mergeMap_1","mergeAll","mergeAll_1","concatAll","concatAll_1","concat","defer","observableFactory","defer_1","DEFAULT_CONFIG","connectable","connector","resetOnDisconnect","forkJoin","sources","remainingCompletions","remainingEmissions","sourceIndex","hasValue","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","options","isEventTarget","methodName","isNodeStyleEventEmitter","toCommonHandlerRegistry","isJQueryStyleEventEmitter","add","remove","subTarget","fromEventPattern","addHandler","removeHandler","retValue","generate","initialStateOrOptions","condition","iterate","resultSelectorOrScheduler","initialState","gen","iif","trueResult","falseResult","timer","dueTime","intervalOrScheduler","intervalDuration","due","n","timer_1","interval","period","merge","never","argsOrArgArray","argsOrArgArray_1","onErrorResumeNext","nextSources","subscribeNext","nextSource","innerSubscriber","pairs","not","pred","filter","predicate","not_1","filter_1","partition","race","raceInit","subscriptions","s","range","count","end","using","resourceFactory","resource","zip","buffers","completed","require_types","__commonJSMin","audit","durationSelector","durationSubscriber","endDuration","cleanupDuration","audit_1","auditTime","duration","closingNotifier","currentBuffer","bufferCount","bufferSize","startBufferEvery","toEmit","buffers_1","buffers_1_1","toEmit_1","toEmit_1_1","buffers_2","buffers_2_1","bufferTime","bufferTimeSpan","otherArgs","bufferCreationInterval","maxBufferSize","bufferRecords","restartOnEmit","emit","record","startBuffer","record_1","bufferTimeSubscriber","recordsCopy","recordsCopy_1","recordsCopy_1_1","bufferToggle","openings","closingSelector","openValue","closingSubscription","emitBuffer","bufferWhen","closingSubscriber","openBuffer","catchError","selector","innerSub","syncUnsub","handledResult","scanInternals","accumulator","seed","hasSeed","emitOnNext","emitBeforeComplete","hasState","scanInternals_1","reduce","reduce_1","arrReducer","toArray","toArray_1","joinAllInternals","joinFn","combineLatest_1","joinAllInternals_1","combineLatestAll","combineLatestAll_1","combineLatestWith","otherSources","concatMap","concatMap_1","concatMapTo","innerObservable","concat_1","concatWith","fromSubscribable","subscribable","fromSubscribable_1","connect","total","debounce","debounceTime","activeTask","lastTime","emitWhenIdle","targetTime","defaultIfEmpty","take","ignoreElements","mapTo","take_1","ignoreElements_1","mapTo_1","delayWhen","delayDurationSelector","subscriptionDelay","delayWhen_1","Notification_1","dematerialize","distinct","keySelector","flushes","distinctKeys","distinctUntilChanged","comparator","defaultCompare","previousKey","currentKey","distinctUntilChanged_1","distinctUntilKeyChanged","compare","y","throwIfEmpty","defaultErrorFactory","ArgumentOutOfRangeError_1","throwIfEmpty_1","defaultIfEmpty_1","elementAt","hasDefaultValue","v","endWith","every","exhaustMap","outerValue","exhaustMap_1","exhaustAll","exhaustAll_1","finalize","find","createFind","findIndex","find_1","groupBy","elementOrOptions","element","groups","notify","handleError","consumer","activeGroups","teardownAttempted","groupBySourceSubscriber","key_1","group_1","grouped","createGroupedObservable","durationSubscriber_1","groupSubject","groupSubscriber","isEmpty","takeLast","buffer_1","buffer_1_1","takeLast_1","materialize","max","comparer","mergeMapTo","mergeScan","merge_1","mergeWith","min","ConnectableObservable_1","connect_1","multicast","subjectOrSubjectFactory","onErrorResumeNext_1","onErrorResumeNextWith","pairwise","hasPrev","p","pluck","properties","currentProp","multicast_1","publish","BehaviorSubject_1","publishBehavior","initialValue","publishLast","ReplaySubject_1","publishReplay","windowTime","selectorOrScheduler","race_1","raceWith","countOrConfig","soFar","sourceSub","resubscribe","notifier","notifierSubscriber_1","subscribeToSource","repeatWhen","syncResub","completions$","isNotifierComplete","isMainComplete","getCompletionSubject","subscribeForRepeatWhen","retry","configOrCount","resetOnSuccess","subscribeForRetry","resub_1","retryWhen","errors$","subscribeForRetryWhen","sample","sample_1","interval_1","sampleTime","scan","sequenceEqual","compareTo","aState","createState","bState","isEqual","createSubscriber","selfState","otherState","sequenceEqualSubscriber","share","resetOnError","resetOnComplete","resetOnRefCountZero","wrapperSource","resetConnection","hasCompleted","hasErrored","cancelReset","reset","resetAndUnsubscribe","dest","handleReset","on","onSubscriber","share_1","shareReplay","configOrBufferSize","SequenceError_1","NotFoundError_1","single","singleValue","seenValue","skip","_","skipLast","skipCount","ring","valueIndex","oldValue","skipUntil","taking","skipSubscriber","skipWhile","startWith","switchMap","innerIndex","outerIndex","switchMap_1","switchAll","switchMapTo","switchScan","takeUntil","takeWhile","inclusive","tap","tapObserver","isUnsub","throttle","leading","trailing","sendValue","throttled","endThrottling","send","cleanupThrottling","startThrottle","throttle_1","throttleTime","duration$","timeInterval","TimeInterval","timeout_1","timeoutWith","withObservable","window","windowBoundaries","windowSubject","windowCount","windowSize","startWindowEvery","startEvery","windows","windows_1","windows_1_1","window_1","c","window_2","windowTimeSpan","windowCreationInterval","maxWindowSize","windowRecords","restartOnClose","closeWindow","startWindow","loop","terminate","windowToggle","windowsCopy","windowsCopy_1","windowsCopy_1_1","windowWhen","openWindow","withLatestFrom","inputs","len","otherValues","ready","zip_1","zipAll","zipWith","otherInputs","animationFrames_1","asap_1","queue_1","animationFrame_1","VirtualTimeScheduler_1","isObservable_1","lastValueFrom_1","firstValueFrom_1","bindCallback_1","bindNodeCallback_1","connectable_1","forkJoin_1","fromEvent_1","fromEventPattern_1","generate_1","iif_1","never_1","pairs_1","partition_1","range_1","using_1","empty_2","never_2","__exportStar","auditTime_1","bufferCount_1","bufferTime_1","bufferToggle_1","bufferWhen_1","catchError_1","combineAll_1","combineLatestWith_1","concatMapTo_1","concatWith_1","count_1","debounce_1","debounceTime_1","delay_1","dematerialize_1","distinct_1","distinctUntilKeyChanged_1","elementAt_1","endWith_1","every_1","exhaust_1","expand_1","finalize_1","findIndex_1","groupBy_1","isEmpty_1","last_1","materialize_1","max_1","flatMap_1","mergeMapTo_1","mergeScan_1","mergeWith_1","min_1","onErrorResumeNextWith_1","pairwise_1","pluck_1","publish_1","publishBehavior_1","publishLast_1","publishReplay_1","raceWith_1","repeat_1","repeatWhen_1","retry_1","retryWhen_1","sampleTime_1","scan_1","sequenceEqual_1","shareReplay_1","single_1","skip_1","skipLast_1","skipUntil_1","skipWhile_1","startWith_1","switchAll_1","switchMapTo_1","switchScan_1","takeUntil_1","takeWhile_1","tap_1","throttleTime_1","timeInterval_1","timeout_2","timeoutWith_1","timestamp_1","windowCount_1","windowTime_1","windowToggle_1","windowWhen_1","withLatestFrom_1","zipAll_1","zipWith_1","import_rxjs","WALLET_CONNECTION_POLL_INTERVAL","WALLET_CONNECTION_TIMEOUT","SUPPORT","ERROR_MESSAGES","SUPPORTED_NEAR_WALLETS","setupMeteorWallet","setupMyNearWallet","setupHereWallet","walletUrls","BitteWalletAuth","onlyBitteWallet","network","contractAddress","successUrl","walletUrl","setupWalletSelector","setupBitteWallet","setupModal","mbjs","modal","tryToResolveAccountsFromState","elapsed","accounts","params","callbackUrl","BitteWalletContext","createContext","BitteWalletContextProvider","children","additionalWallets","errorMessage","setErrorMessage","useState","components","setComponents","setAccounts","isWaitingForConnection","setIsWaitingForConnection","isWalletSelectorSetup","setIsWalletSelectorSetup","selectedNetwork","selectedContract","setupBitteWalletSelector","registerWalletAccountsSubscriber","connectWalletSelector","pollForWalletConnection","disconnectFromWalletSelector","signMessage","isOnlyBitteWallet","setup","useCallback","onCloseModal","setupWallet","useEffect","closeButton","disconnect","contextVal","useMemo","account","jsx","useBitteWallet","useContext","useNearPrice","price","setPrice","setError","data","nearPrice"],"mappings":"mcAIA,IAAA,EAAA,CAAA,MAAA,CAAA,MAAA,CAAA,IAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,IAAA,EAAA,CAAA,MAAA,CAAA,wBAAA,CAAA,IAAA,EAAA,CAAA,MAAA,CAAA,mBAAA,CAAA,IAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,EAAA,CAAA,EAAA,OAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,GAAA,CAAA,EAAA,OAAA,CAAA,EAAA,QAAA,EAAA,OAAA,CAAA,EAAA,UAAA,CAAA,IAAA,IAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,GAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,UAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,UAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,IAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,UAAA,CAAA,EAAA,CAAA,CAAA,CAAA,SAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,UAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,UAAA,CAAA,SAAA,CAAA,SAAgBA,EAAWC,CAAAA,CAAAA,CAAU,CACnC,OAAO,OAAOA,CAAU,EAAA,UAC1B,CAFAC,EAAAA,CAAA,WAAAF,GCKA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,gBAAA,CAAA,SAAA,CAAA,SAAgBG,EAAoBC,CAAAA,CAAAA,CAAgC,CAClE,IAAMC,CAAAA,CAAS,SAACC,CAAAA,CAAa,CAC3B,KAAA,CAAM,IAAKA,CAAAA,CAAQ,EACnBA,CAAS,CAAA,KAAA,CAAQ,IAAI,KAAA,GAAQ,MAC/B,CAAA,CAEMC,CAAWH,CAAAA,CAAAA,CAAWC,CAAM,CAClC,CAAA,OAAAE,CAAS,CAAA,SAAA,CAAY,MAAO,CAAA,MAAA,CAAO,KAAM,CAAA,SAAS,EAClDA,CAAS,CAAA,SAAA,CAAU,WAAcA,CAAAA,CAAAA,CAC1BA,CACT,CAVAL,EAAAA,CAAA,gBAAAC,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,mBAAAA,CAAAA,SAAAA,CCTA,IAAAK,EAAA,CAAA,EAAA,EAAA,CAkBaN,EAAA,CAAA,mBAAA,CAA+CM,GAAA,gBAC1D,CAAA,SAACH,CAAM,CAAA,CACL,OAAA,SAA4CI,CAAAA,CAA0B,CACpEJ,CAAAA,CAAO,IAAI,CACX,CAAA,IAAA,CAAK,OAAUI,CAAAA,CAAAA,CACRA,EAAO,MAAM,CAAA,CAAA;AACxBA,CAAAA,CAAAA,CAAAA,CAAO,GAAI,CAAA,SAACC,CAAK,CAAA,CAAA,CAAC,CAAK,OAAG,CAAA,CAAI,CAAC,CAAA,IAAA,CAAKA,CAAI,CAAA,QAAA,EAAjB,CAA6B,EAAE,IAAK,CAAA;AAAM,EAAA,CAAA,CAAA,CACzD,GACJ,IAAK,CAAA,IAAA,CAAO,qBACZ,CAAA,IAAA,CAAK,OAASD,EAChB,CARA,CAQC,EAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAA,CAAA,SAAA,CCvBL,SAAgBE,EAAaC,CAAAA,CAAAA,CAA6BC,EAAO,CAC/D,GAAID,EAAK,CACP,IAAME,CAAQF,CAAAA,CAAAA,CAAI,QAAQC,CAAI,CAAA,CAC9B,GAAKC,CAASF,EAAAA,CAAAA,CAAI,OAAOE,CAAO,CAAA,CAAC,EAErC,CAAA,CALAZ,GAAA,SAAAS,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,QAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,OAAAA,MAAAA,EAAAA,UAAAA,EAAAA,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,OAAAA,CAAAA,CAAAA,MAAAA,EAAAA,QAAAA,CAAAA,OAAAA,CAAAA,IAAAA,CAAAA,UAAAA,CAAAA,OAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CAAAA,MAAAA,GAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,IAAAA,SAAAA,CAAAA,CAAAA,CAAAA,yBAAAA,CAAAA,iCAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,MAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,OAAAA,MAAAA,EAAAA,UAAAA,EAAAA,CAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,KAAAA,CAAAA,CAAAA,GAAAA,KAAAA,CAAAA,EAAAA,CAAAA,EAAAA,EAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,EAAAA,IAAAA,EAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,EAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,aAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,YAAAA,CAAAA,SAAAA,CCLA,IAAAI,EAAA,CAAA,CAAA,EAAA,CACAC,GAAA,EAEAC,EAAAA,CAAAA,EAAAA,CAAA,CAcAC,EAAAA,CAAAA,EAAAA,CAAA,UAAA,CAyBE,SAAAA,EAAoBC,CAA4B,CAAA,CAA5B,KAAA,eAAAA,CAAAA,CAAAA,CAdb,IAAA,CAAA,MAAA,CAAS,MAER,IAAA,CAAA,UAAA,CAAmD,KAMnD,IAAA,CAAA,WAAA,CAAqD,KAMV,CAQnD,OAAAD,CAAA,CAAA,SAAA,CAAA,YAAA,UAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CACMT,EAEJ,GAAI,CAAC,KAAK,MAAQ,CAAA,CAChB,IAAK,CAAA,MAAA,CAAS,KAGN,IAAAW,CAAAA,CAAe,KAAI,UAC3B,CAAA,GAAIA,EAEF,GADA,IAAA,CAAK,UAAa,CAAA,IAAA,CACd,MAAM,OAAQA,CAAAA,CAAU,CAC1B,CAAA,GAAA,CAAA,IAAA,IAAqBC,EAAAC,EAAAF,CAAAA,CAAU,CAAAG,CAAAA,CAAAA,CAAAF,EAAA,IAAA,EAAA,CAAA,CAAAE,CAAA,CAAA,IAAA,CAAAA,EAAAF,CAAA,CAAA,IAAA,EAAE,CAAA,CAA5B,IAAMG,CAAMD,CAAAA,CAAAA,CAAA,MACfC,CAAO,CAAA,MAAA,CAAO,IAAI,EAGpBJ,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,EAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAW,MAAO,CAAA,IAAI,EAIlB,IAAiBK,CAAAA,CAAqB,KAAI,eAClD,CAAA,GAAIV,GAAA,UAAWU,CAAAA,CAAgB,CAC7B,CAAA,GAAI,CACFA,CAAgB,GAAA,CAAA,MACTC,EAAG,CACVjB,CAAAA,CAASiB,aAAaV,EAAA,CAAA,mBAAA,CAAsBU,CAAE,CAAA,MAAA,CAAS,CAACA,CAAC,EAAA,CAIrD,IAAAC,CAAgB,CAAA,IAAA,CAAI,YAC5B,GAAIA,CAAAA,CAAa,CACf,IAAA,CAAK,YAAc,IACnB,CAAA,GAAA,CAAA,IAAA,IAAwBC,EAAAN,EAAAK,CAAAA,CAAW,EAAAE,CAAAD,CAAAA,CAAAA,CAAA,IAAA,EAAA,CAAA,CAAAC,CAAA,CAAA,IAAA,CAAAA,EAAAD,CAAA,CAAA,IAAA,GAAE,CAAhC,IAAME,CAASD,CAAAA,CAAAA,CAAA,MAClB,GAAI,CACFE,EAAcD,CAAAA,CAAS,SAChBpB,CAAK,CAAA,CACZD,CAASA,CAAAA,CAAAA,EAAU,EACfC,CAAAA,CAAAA,YAAeM,GAAA,mBACjBP,CAAAA,CAAAA,CAAMuB,GAAAA,EAAA,CAAA,EAAAC,CAAAA,EAAAA,CAAOxB,CAAM,CAAA,CAAA,CAAAwB,GAAKvB,CAAI,CAAA,MAAM,CAAA,CAElCD,CAAAA,CAAAA,CAAO,IAAKC,CAAAA,CAAG,yGAMvB,GAAID,CAAAA,CACF,MAAM,IAAIO,EAAAA,CAAA,oBAAoBP,CAAM,CAAA,CAG1C,CAoBAS,CAAAA,CAAAA,CAAA,UAAA,GAAA,CAAA,SAAIgB,EAAuB,CAGzB,IAAA,CAAA,CAAA,GAAIA,GAAYA,CAAa,GAAA,IAAA,CAC3B,GAAI,IAAA,CAAK,OAGPH,EAAcG,CAAAA,CAAQ,OACjB,CACL,GAAIA,aAAoBhB,CAAc,CAAA,CAGpC,GAAIgB,CAAAA,CAAS,QAAUA,CAAS,CAAA,UAAA,CAAW,IAAI,CAC7C,CAAA,OAEFA,EAAS,UAAW,CAAA,IAAI,EAEzB,CAAA,CAAA,IAAA,CAAK,aAAcC,CAAA,CAAA,IAAA,CAAK,eAAW,IAAAA,EAAAA,CAAAA,GAAA,UAAAA,CAAI,CAAA,EAAI,EAAA,IAAA,CAAKD,CAAQ,EAG/D,CAAA,CAAA,CAOQhB,EAAA,SAAA,CAAA,UAAA,CAAR,SAAmBkB,CAAoB,CAAA,CAC7B,IAAAhB,CAAAA,CAAe,KAAI,UAC3B,CAAA,OAAOA,IAAegB,CAAW,EAAA,KAAA,CAAM,QAAQhB,CAAU,CAAA,EAAKA,CAAW,CAAA,QAAA,CAASgB,CAAM,CAC1F,CAAA,CASQlB,EAAA,SAAA,CAAA,UAAA,CAAR,SAAmBkB,CAAoB,CAAA,CAC7B,IAAAhB,CAAAA,CAAe,KAAI,UAC3B,CAAA,IAAA,CAAK,WAAa,KAAM,CAAA,OAAA,CAAQA,CAAU,CAAKA,EAAAA,CAAAA,CAAW,IAAKgB,CAAAA,CAAM,EAAGhB,CAAcA,EAAAA,CAAAA,CAAa,CAACA,CAAYgB,CAAAA,CAAM,EAAIA,EAC5H,CAAA,CAMQlB,CAAA,CAAA,SAAA,CAAA,cAAR,SAAsBkB,CAAAA,CAAoB,CAChC,IAAAhB,CAAAA,CAAe,KAAI,UACvBA,CAAAA,CAAAA,GAAegB,CACjB,CAAA,IAAA,CAAK,WAAa,IACT,CAAA,KAAA,CAAM,QAAQhB,CAAU,CAAA,EACjCH,GAAA,SAAUG,CAAAA,CAAAA,CAAYgB,CAAM,EAEhC,EAgBAlB,CAAA,CAAA,SAAA,CAAA,OAAA,SAAOgB,CAAAA,CAAsC,CACnC,IAAAP,CAAAA,CAAgB,IAAI,CAAA,WAAA,CAC5BA,GAAeV,EAAA,CAAA,SAAA,CAAUU,CAAaO,CAAAA,CAAQ,EAE1CA,CAAoBhB,YAAAA,CAAAA,EACtBgB,CAAS,CAAA,aAAA,CAAc,IAAI,EAE/B,CAAA,CAlLchB,EAAA,KAAS,CAAA,UAAA,CACrB,IAAMmB,CAAAA,CAAQ,IAAInB,CAAAA,CAClB,OAAAmB,CAAM,CAAA,MAAA,CAAS,KACRA,CACT,CAAA,GA+KFnB,CArLA,CAAA,EAAA,CAAahB,CAAA,CAAA,YAAA,CAAAgB,GAuLAhB,CAAA,CAAA,kBAAA,CAAqBgB,GAAa,KAE/C,CAAA,SAAgBoB,GAAerC,CAAU,CAAA,CACvC,OACEA,CAAAA,YAAiBiB,IAChBjB,CAAS,EAAA,QAAA,GAAYA,GAASc,EAAA,CAAA,UAAA,CAAWd,EAAM,MAAM,CAAA,EAAKc,EAAA,CAAA,UAAA,CAAWd,EAAM,GAAG,CAAA,EAAKc,GAAA,UAAWd,CAAAA,CAAAA,CAAM,WAAW,CAEpH,CALAC,CAAA,CAAA,cAAA,CAAAoC,GAOA,SAASP,EAAAA,CAAcD,EAAwC,CACzDf,EAAAA,CAAA,WAAWe,CAAS,CAAA,CACtBA,CAAS,EAAA,CAETA,EAAU,WAAW,GAEzB,0FChNa5B,EAAA,CAAA,MAAA,CAAuB,CAClC,gBAAkB,CAAA,IAAA,CAClB,qBAAuB,CAAA,IAAA,CACvB,QAAS,SACT,CAAA,qCAAA,CAAuC,KACvC,CAAA,wBAAA,CAA0B,4fCGfA,CAAA,CAAA,eAAA,CAAmC,CAG9C,UAAA,CAAA,SAAWqC,CAAqBC,CAAAA,CAAAA,CAAgB,SAAEC,CAAA,CAAA,GAAAC,CAAA,CAAA,CAAA,CAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,EAAA,CAAA,CAAA,CAAA,UAAAA,CAAA,CAAA,CACxC,IAAAC,CAAAA,CAAazC,EAAA,eAAe,CAAA,QAAA,CACpC,OAAIyC,CAAU,EAAA,UAAA,CACLA,EAAS,UAAU,CAAA,KAAA,CAAnBA,CAAQX,CAAAA,EAAAA,CAAA,CAAYO,CAASC,CAAAA,CAAO,EAAAP,EAAKQ,CAAAA,CAAI,CAAA,CAAA,CAAA,CAE/C,UAAU,CAAA,KAAA,CAAA,UAAAT,EAAA,CAAA,CAACO,EAASC,CAAO,CAAA,CAAAP,GAAKQ,CAAI,CAAA,CAAA,CAC7C,EACA,YAAA,CAAA,SAAaG,EAAM,CACT,IAAAD,EAAazC,CAAA,CAAA,eAAA,CAAe,QACpC,CAAA,OAAA,CAAQyC,GAAU,YAAgB,EAAA,YAAA,EAAcC,CAAa,CAC/D,CAAA,CACA,SAAU,SC7BZ,EAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,IAAAC,EAAA,CAAA,EAAA,EAAA,CACAC,GAAA,EAWA,EAAA,CAAA,SAAgBC,EAAqBrC,CAAAA,CAAAA,CAAQ,CAC3CoC,EAAA,CAAA,eAAA,CAAgB,UAAW,CAAA,UAAA,CACjB,IAAAE,CAAAA,CAAqBH,GAAA,MAAM,CAAA,gBAAA,CACnC,GAAIG,CAEFA,CAAAA,CAAAA,CAAiBtC,CAAG,CAAA,CAAA,WAGdA,CAEV,CAAC,EACH,CAXAR,EAAAA,CAAA,qBAAA6C,GCXA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,IAAA,CAAA,SAAA,CAAA,SAAgBE,EAAI,EAAA,EAApB/C,EAAA,CAAA,IAAA,CAAA+C,oKCMa/C,CAAA,CAAA,qBAAA,CAAyB,UAAA,CAAM,OAAAgD,EAAmB,CAAA,GAAA,CAAK,UAAW,SAAS,CAA5C,GAO5C,CAAA,SAAgBC,GAAkBC,CAAU,CAAA,CAC1C,OAAOF,EAAAA,CAAmB,IAAK,SAAWE,CAAAA,CAAK,CACjD,CAFAlD,CAAAA,CAAA,kBAAAiD,EASA,CAAA,SAAgBE,EAAoBpD,CAAAA,CAAAA,CAAQ,CAC1C,OAAOiD,EAAAA,CAAmB,IAAKjD,CAAO,CAAA,SAAS,CACjD,CAFAC,CAAAA,CAAA,gBAAAmD,CAAAA,EAAAA,CAUA,SAAgBH,EAAmBI,CAAAA,CAAAA,CAAuBrD,EAAYmD,CAAU,CAAA,CAC9E,OAAO,CACL,IAAA,CAAIE,CACJ,CAAA,KAAA,CAAKrD,EACL,KAAKmD,CAAAA,CAAAA,CAET,CANAlD,CAAA,CAAA,kBAAA,CAAAgD,kHCjCA,IAAAL,EAAAA,CAAA,EAEIU,EAAAA,CAAAA,EAAAA,CAAuD,KAS3D,SAAgBC,EAAAA,CAAaC,EAAc,CACzC,GAAIZ,GAAA,MAAO,CAAA,qCAAA,CAAuC,CAChD,IAAMa,EAAS,CAACH,EAAAA,CAKhB,GAJIG,CACFH,GAAAA,EAAAA,CAAU,CAAE,WAAa,CAAA,KAAA,CAAO,KAAO,CAAA,IAAI,GAE7CE,CAAE,EAAA,CACEC,EAAQ,CACJ,IAAAvB,EAAyBoB,EAAvBI,CAAAA,CAAAA,CAAWxB,CAAA,CAAA,WAAA,CAAEiB,EAAKjB,CAAA,CAAA,KAAA,CAE1B,GADAoB,EAAU,CAAA,IAAA,CACNI,EACF,MAAMP,CAAAA,CAAAA,CAAAA,KAMVK,CAAE,GAEN,CAnBAvD,EAAA,CAAA,YAAA,CAAAsD,GAyBA,SAAgBI,EAAAA,CAAalD,EAAQ,CAC/BmC,EAAAA,CAAA,MAAO,CAAA,qCAAA,EAAyCU,KAClDA,EAAQ,CAAA,WAAA,CAAc,KACtBA,EAAQ,CAAA,KAAA,CAAQ7C,GAEpB,CALAR,EAAAA,CAAA,YAAA0D,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,SAAAA,EAAAA,UAAAA,CAAAA,IAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,MAAAA,CAAAA,cAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,WAAAA,KAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,IAAAA,CAAAA,IAAAA,CAAAA,CAAAA,MAAAA,CAAAA,SAAAA,CAAAA,cAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,OAAAA,CAAAA,EAAAA,UAAAA,EAAAA,CAAAA,GAAAA,IAAAA,CAAAA,MAAAA,IAAAA,SAAAA,CAAAA,sBAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,+BAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,IAAAA,CAAAA,WAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,GAAAA,IAAAA,CAAAA,MAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CCpCA,IAAA7C,EAAA,CAAA,CAAA,EAAA,CAEA8C,GAAA,CACAhB,EAAAA,CAAAA,EAAAA,CAAA,KACAiB,EAAA,CAAA,EAAA,EAAA,CACAC,EAAA,CAAA,CAAA,EAAA,CACAC,GAAA,EACAlB,EAAAA,CAAAA,EAAAA,CAAA,EACAmB,EAAAA,CAAAA,EAAAA,CAAA,KAYAC,EAAA,CAAA,SAAA7D,CAAA,CAAA,CAAmC8D,GAAAD,CAAA7D,CAAAA,CAAA,EA6BjC,SAAA6D,CAAAA,CAAYE,EAA6C,CAAzD,IAAAC,CACEhE,CAAAA,CAAAA,CAAA,KAAA,IAAA,CAAA,EAAO,KATC,OAAAgE,CAAAA,CAAA,UAAqB,KAUzBD,CAAAA,CAAAA,EACFC,CAAK,CAAA,WAAA,CAAcD,EAGfP,EAAA,CAAA,cAAA,CAAeO,CAAW,CAC5BA,EAAAA,CAAAA,CAAY,IAAIC,CAAI,CAAA,EAGtBA,CAAK,CAAA,WAAA,CAAcnE,EAAA,cAEvB,CAAA,CAAA,CAzBO,OAAAgE,CAAA,CAAA,MAAA,CAAP,SAAiBI,CAAwBlB,CAAAA,CAAAA,CAA2BmB,CAAqB,CAAA,CACvF,OAAO,IAAIC,EAAAA,CAAeF,EAAMlB,CAAOmB,CAAAA,CAAQ,CACjD,CAgCAL,CAAAA,CAAAA,CAAA,SAAA,CAAA,IAAA,CAAA,SAAKjE,CAAS,CAAA,CACR,KAAK,SACPwE,CAAAA,EAAAA,CAA0BT,GAAA,gBAAiB/D,CAAAA,CAAK,CAAG,CAAA,IAAI,EAEvD,IAAK,CAAA,KAAA,CAAMA,CAAM,EAErB,CAAA,CASAiE,EAAA,SAAA,CAAA,KAAA,CAAA,SAAMxD,CAAAA,CAAS,CACT,IAAK,CAAA,SAAA,CACP+D,EAA0BT,CAAAA,EAAAA,CAAA,kBAAkBtD,CAAG,CAAA,CAAG,IAAI,CAAA,EAEtD,KAAK,SAAY,CAAA,IAAA,CACjB,KAAK,MAAOA,CAAAA,CAAG,GAEnB,CAQAwD,CAAAA,CAAAA,CAAA,SAAA,CAAA,QAAA,CAAA,UAAA,CACM,IAAA,CAAK,UACPO,EAA0BT,CAAAA,EAAAA,CAAA,sBAAuB,IAAI,CAAA,EAErD,IAAK,CAAA,SAAA,CAAY,KACjB,IAAK,CAAA,SAAA,IAET,CAEAE,CAAAA,CAAAA,CAAA,UAAA,WAAA,CAAA,UAAA,CACO,IAAA,CAAK,SACR,IAAK,CAAA,SAAA,CAAY,KACjB7D,CAAA,CAAA,SAAA,CAAM,YAAW,IAAA,CAAA,IAAA,CACjB,CAAA,IAAA,CAAK,YAAc,IAEvB,EAAA,CAAA,CAEU6D,EAAA,SAAA,CAAA,KAAA,CAAV,SAAgBjE,CAAQ,CAAA,CACtB,IAAK,CAAA,WAAA,CAAY,KAAKA,CAAK,EAC7B,EAEUiE,CAAA,CAAA,SAAA,CAAA,OAAV,SAAiBxD,CAAAA,CAAQ,CACvB,GAAI,CACF,IAAK,CAAA,WAAA,CAAY,MAAMA,CAAG,EAAA,CAAA,OAAA,CAE1B,KAAK,WAAW,GAAA,CAEpB,CAEUwD,CAAAA,CAAAA,CAAA,UAAA,SAAV,CAAA,UAAA,CACE,GAAI,CACF,IAAK,CAAA,WAAA,CAAY,QAAQ,GAAA,CAAA,OAAA,CAEzB,KAAK,WAAW,GAAA,CAEpB,EACFA,CAAA,CAAA,CApHmCL,GAAA,YAAY,CAAA,CAAlC3D,CAAA,CAAA,UAAA,CAAAgE,GA2Hb,IAAMQ,EAAAA,CAAQ,SAAS,SAAU,CAAA,IAAA,CAEjC,SAASC,EAAyCC,CAAAA,CAAAA,CAAQC,CAAY,CAAA,CACpE,OAAOH,EAAM,CAAA,IAAA,CAAKE,EAAIC,CAAO,CAC/B,CAMA,IAAAC,EAAAA,CAAA,UAAA,CACE,SAAAA,CAAoBC,CAAAA,CAAAA,CAAqC,CAArC,IAAA,CAAA,eAAA,CAAAA,EAAwC,CAE5D,OAAAD,CAAA,CAAA,SAAA,CAAA,KAAA,SAAK7E,CAAAA,CAAQ,CACH,IAAA8E,CAAAA,CAAoB,KAAI,eAChC,CAAA,GAAIA,CAAgB,CAAA,IAAA,CAClB,GAAI,CACFA,CAAAA,CAAgB,KAAK9E,CAAK,EAAA,CAAA,MACnBmD,EAAO,CACd4B,EAAAA,CAAqB5B,CAAK,EAAA,CAGhC,EAEA0B,CAAA,CAAA,SAAA,CAAA,MAAA,SAAMpE,CAAAA,CAAQ,CACJ,IAAAqE,CAAAA,CAAoB,IAAI,CAAA,eAAA,CAChC,GAAIA,CAAgB,CAAA,KAAA,CAClB,GAAI,CACFA,CAAAA,CAAgB,MAAMrE,CAAG,EAAA,CAAA,MAClB0C,CAAO,CAAA,CACd4B,GAAqB5B,CAAK,EAAA,CAAA,KAG5B4B,GAAqBtE,CAAG,EAE5B,EAEAoE,CAAA,CAAA,SAAA,CAAA,QAAA,CAAA,UAAA,CACU,IAAAC,CAAAA,CAAoB,KAAI,eAChC,CAAA,GAAIA,EAAgB,QAClB,CAAA,GAAI,CACFA,CAAAA,CAAgB,WACT3B,CAAAA,MAAAA,CAAAA,CAAO,CACd4B,EAAqB5B,CAAAA,CAAK,GAGhC,CACF0B,CAAAA,CAAA,CArCA,EAAA,CAuCAN,GAAA,SAAAnE,CAAAA,CAAA,CAAuC8D,EAAAK,CAAAA,CAAAA,CAAAnE,CAAA,CACrC,CAAA,SAAAmE,CACES,CAAAA,CAAAA,CACA7B,EACAmB,CAA8B,CAAA,CAHhC,IAAAF,CAKEhE,CAAAA,CAAAA,CAAA,KAAA,IAAA,CAAA,EAAO,IAEH0E,CAAAA,CAAAA,CACJ,GAAIhE,EAAA,CAAA,UAAA,CAAWkE,CAAc,CAAK,EAAA,CAACA,EAGjCF,CAAkB,CAAA,CAChB,IAAOE,CAAAA,CAAAA,EAAkB,UACzB,KAAO7B,CAAAA,CAAAA,EAAS,UAChB,QAAUmB,CAAAA,CAAAA,EAAY,gBAEnB,CAEL,IAAIW,CACAb,CAAAA,CAAAA,EAAQxB,GAAA,MAAO,CAAA,wBAAA,EAIjBqC,CAAU,CAAA,MAAA,CAAO,OAAOD,CAAc,CAAA,CACtCC,CAAQ,CAAA,WAAA,CAAc,UAAA,CAAM,OAAAb,EAAK,WAAW,EAAhB,EAC5BU,CAAkB,CAAA,CAChB,IAAME,CAAAA,CAAAA,CAAe,MAAQN,EAAKM,CAAAA,CAAAA,CAAe,KAAMC,CAAO,CAAA,CAC9D,MAAOD,CAAe,CAAA,KAAA,EAASN,EAAKM,CAAAA,CAAAA,CAAe,MAAOC,CAAO,CAAA,CACjE,SAAUD,CAAe,CAAA,QAAA,EAAYN,GAAKM,CAAe,CAAA,QAAA,CAAUC,CAAO,CAAA,CAAA,EAI5EH,EAAkBE,EAMtB,CAAA,OAAAZ,EAAK,WAAc,CAAA,IAAIS,GAAiBC,CAAe,CAAA,CAAA,CACzD,CACF,OAAAP,CAAA,CAzCuCN,CAAAA,EAAU,EAApChE,CAAA,CAAA,cAAA,CAAAsE,GA2Cb,SAASQ,EAAAA,CAAqB5B,CAAU,CAAA,CAClCP,GAAA,MAAO,CAAA,qCAAA,CACToB,GAAA,YAAab,CAAAA,CAAK,EAIlBU,EAAA,CAAA,oBAAA,CAAqBV,CAAK,EAE9B,CAQA,SAAS+B,EAAAA,CAAoBzE,EAAQ,CACnC,MAAMA,CACR,CAOA,SAAS+D,EAA0BW,CAAAA,CAAAA,CAA2CC,EAA2B,CAC/F,IAAAC,CAA0BzC,CAAAA,EAAAA,CAAA,OAAM,qBACxCyC,CAAAA,CAAAA,EAAyBxC,EAAA,CAAA,eAAA,CAAgB,WAAW,UAAA,CAAM,OAAAwC,CAAsBF,CAAAA,CAAAA,CAAcC,CAAU,CAA9C,CAA+C,EAC3G,CAOanF,EAAA,cAA6D,CAAA,CACxE,OAAQ,IACR,CAAA,IAAA,CAAM6D,GAAA,IACN,CAAA,KAAA,CAAOoB,EACP,CAAA,QAAA,CAAUpB,GAAA,IC5QC7D,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAA,WAA+B,UAAA,CAAM,OAAC,OAAO,MAAA,EAAW,UAAc,EAAA,MAAA,CAAO,YAAe,cAAvD,CAAA,6FCoClD,SAAgBqF,EAAAA,CAAYC,EAAI,CAC9B,OAAOA,CACT,CAFAtF,GAAA,QAAAqF,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,aAAAA,CAAAA,EAAAA,CAAAA,IAAAA,CAAAA,SAAAA,CC1CA,IAAAE,EAAA,CAAA,CAAA,EAAA,CA6EA,SAAgBC,EAAI,EAAA,CAAA,IAAA,IAACC,CAAA,CAAA,GAAAjD,CAAA,CAAA,CAAA,CAAAA,EAAA,SAAA,CAAA,MAAA,CAAAA,IAAAiD,CAAAjD,CAAAA,CAAA,CAAA,CAAA,SAAA,CAAAA,CAAA,CACnB,CAAA,OAAOkD,GAAcD,CAAG,CAC1B,CAFAzF,EAAA,CAAA,IAAA,CAAAwF,EAKA,CAAA,SAAgBE,GAAoBD,CAA+B,CAAA,CACjE,OAAIA,CAAAA,CAAI,SAAW,CACVF,CAAAA,EAAAA,CAAA,QAGLE,CAAAA,CAAAA,CAAI,SAAW,CACVA,CAAAA,CAAAA,CAAI,CAAC,CAGP,CAAA,SAAeE,EAAQ,CAC5B,OAAOF,CAAI,CAAA,MAAA,CAAO,SAACG,CAAWlB,CAAAA,CAAAA,CAAuB,CAAK,OAAAA,CAAAA,CAAGkB,CAAI,CAAP,CAAA,CAAUD,CAAY,CAClF,CACF,CAZA3F,EAAAA,CAAA,cAAA0F,GCjFA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,UAAA,CAAA,SAAA,CAAA,IAAAG,GAAA,EACAlC,EAAAA,CAAAA,EAAAA,CAAA,CAEAmC,EAAAA,CAAAA,EAAAA,CAAA,KACAC,EAAA,CAAA,EAAA,EAAA,CACApD,GAAA,EACA9B,EAAAA,CAAAA,EAAAA,CAAA,IACAkD,EAAA,CAAA,EAAA,EAAA,CAQAiC,EAAA,CAAA,UAAA,CAkBE,SAAAA,CAAAA,CAAYC,EAA6E,CACnFA,CAAAA,GACF,KAAK,UAAaA,CAAAA,CAAAA,EAEtB,CA4BA,OAAAD,EAAA,SAAA,CAAA,IAAA,CAAA,SAAQE,CAAyB,CAAA,CAC/B,IAAMC,CAAa,CAAA,IAAIH,CACvB,CAAA,OAAAG,EAAW,MAAS,CAAA,IAAA,CACpBA,EAAW,QAAWD,CAAAA,CAAAA,CACfC,CACT,CA6IAH,CAAAA,CAAAA,CAAA,SAAA,CAAA,SAAA,CAAA,SACEjB,CACA7B,CAAAA,CAAAA,CACAmB,EAA8B,CAHhC,IAAAF,EAAA,IAKQgB,CAAAA,CAAAA,CAAaiB,EAAarB,CAAAA,CAAc,EAAIA,CAAiB,CAAA,IAAIc,GAAA,cAAed,CAAAA,CAAAA,CAAgB7B,EAAOmB,CAAQ,CAAA,CAErH,OAAAN,EAAAA,CAAA,aAAa,UAAA,CACL,IAAA9B,CAAuBkC,CAAAA,CAAAA,CAArB+B,EAAQjE,CAAA,CAAA,QAAA,CAAEoE,CAAMpE,CAAAA,CAAAA,CAAA,OACxBkD,CAAW,CAAA,GAAA,CACTe,EAGIA,CAAS,CAAA,IAAA,CAAKf,EAAYkB,CAAM,CAAA,CAChCA,CAIAlC,CAAAA,CAAAA,CAAK,WAAWgB,CAAU,CAAA,CAG1BhB,EAAK,aAAcgB,CAAAA,CAAU,CAAC,EAEtC,CAAC,CAEMA,CAAAA,CACT,EAGUa,CAAA,CAAA,SAAA,CAAA,cAAV,SAAwBM,CAAAA,CAAmB,CACzC,GAAI,CACF,OAAO,IAAA,CAAK,WAAWA,CAAI,CAAA,CAAA,MACpB9F,EAAK,CAIZ8F,CAAAA,CAAK,MAAM9F,CAAG,EAAA,CAElB,CA6DAwF,CAAAA,CAAAA,CAAA,UAAA,OAAA,CAAA,SAAQ5B,EAA0BmC,CAAoC,CAAA,CAAtE,IAAApC,CAAA,CAAA,IAAA,CACE,OAAAoC,CAAAA,CAAcC,GAAeD,CAAW,CAAA,CAEjC,IAAIA,CAAAA,CAAkB,SAACE,CAASC,CAAAA,CAAAA,CAAM,CAC3C,IAAMvB,EAAa,IAAIU,EAAAA,CAAA,eAAkB,CACvC,IAAA,CAAM,SAAC9F,CAAK,CAAA,CACV,GAAI,CACFqE,EAAKrE,CAAK,EAAA,CAAA,MACHS,EAAK,CACZkG,CAAAA,CAAOlG,CAAG,CACV2E,CAAAA,CAAAA,CAAW,WAAW,GAAA,CAE1B,EACA,KAAOuB,CAAAA,CAAAA,CACP,SAAUD,CACX,CAAA,CAAA,CACDtC,EAAK,SAAUgB,CAAAA,CAAU,EAC3B,CAAC,CACH,CAGUa,CAAAA,CAAAA,CAAA,UAAA,UAAV,CAAA,SAAqBb,EAA2B,CAC9C,IAAA,CAAA,CAAA,OAAA,CAAOlD,CAAA,CAAA,IAAA,CAAK,UAAM,IAAAA,EAAAA,CAAAA,GAAA,UAAA,SAAAA,CAAAA,CAAAA,CAAE,UAAUkD,CAAU,CAC1C,CAOAa,CAAAA,CAAAA,CAAA,UAACF,EAAA,CAAA,UAAiB,EAAlB,UAAA,CACE,OAAO,IACT,CAAA,CA4FAE,CAAA,CAAA,SAAA,CAAA,KAAA,UAAA,CAAA,IAAA,IAAKW,EAAA,EAAA,CAAAnE,EAAA,CAAAA,CAAAA,CAAAA,CAAA,SAAA,CAAA,MAAA,CAAAA,IAAAmE,CAAAnE,CAAAA,CAAA,CAAA,CAAA,SAAA,CAAAA,CAAA,CACH,CAAA,OAAOuD,EAAA,CAAA,aAAA,CAAcY,CAAU,CAAE,CAAA,IAAI,CACvC,CA6BAX,CAAAA,CAAAA,CAAA,UAAA,SAAA,CAAA,SAAUO,CAAoC,CAAA,CAA9C,IAAApC,CAAA,CAAA,IAAA,CACE,OAAAoC,CAAcC,CAAAA,EAAAA,CAAeD,CAAW,CAEjC,CAAA,IAAIA,CAAY,CAAA,SAACE,EAASC,CAAM,CAAA,CACrC,IAAI3G,CACJoE,CAAAA,CAAAA,CAAK,UACH,SAACmB,CAAAA,CAAI,CAAK,OAACvF,EAAQuF,CAAT,CAAA,CACV,SAAC9E,CAAQ,CAAA,CAAK,OAAAkG,CAAOlG,CAAAA,CAAG,CAAV,CAAA,CACd,UAAA,CAAM,OAAAiG,EAAQ1G,CAAK,CAAb,CAAc,EAExB,CAAC,CACH,CAAA,CA1aOiG,EAAA,MAAkC,CAAA,SAAIC,EAAwD,CACnG,OAAO,IAAID,CAAcC,CAAAA,CAAS,CACpC,CAAA,CAyaFD,IA9cahG,CAAAA,EAAAA,CAAA,WAAAgG,EAudb,CAAA,SAASQ,GAAeD,CAA+C,CAAA,CAAA,IAAA,CAAA,CACrE,OAAOtE,CAAAA,CAAAA,CAAAsE,GAAe5D,EAAA,CAAA,MAAA,CAAO,OAAO,IAAA,IAAA,EAAAV,IAAA,SAAAA,CAAAA,CAAAA,CAAI,OAC1C,CAEA,SAAS2E,EAAc7G,CAAAA,CAAAA,CAAU,CAC/B,OAAOA,CAAAA,EAASc,GAAA,UAAWd,CAAAA,CAAAA,CAAM,IAAI,CAAA,EAAKc,GAAA,UAAWd,CAAAA,CAAAA,CAAM,KAAK,CAAKc,EAAAA,EAAAA,CAAA,WAAWd,CAAM,CAAA,QAAQ,CAChG,CAEA,SAASqG,EAAgBrG,CAAAA,CAAAA,CAAU,CACjC,OAAQA,CAAAA,EAASA,aAAiB8F,EAAA,CAAA,UAAA,EAAgBe,EAAW7G,CAAAA,CAAK,GAAK4D,EAAA,CAAA,cAAA,CAAe5D,CAAK,CAC7F,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,EAAA,CAAA,OAAA,CAAA,SAAA,CC9eA,IAAAc,EAAA,CAAA,CAAA,EAAA,CAKA,SAAgBgG,EAAAA,CAAQR,EAAW,CACjC,OAAOxF,GAAA,UAAWwF,CAAAA,CAAAA,EAAQ,IAAI,CAChC,CAFArG,EAAA,CAAA,OAAA,CAAA6G,GAQA,SAAgBC,EAAAA,CACdC,EAAqF,CAErF,OAAO,SAACV,CAAqB,CAAA,CAC3B,GAAIQ,EAAAA,CAAQR,CAAM,CAChB,CAAA,OAAOA,EAAO,IAAK,CAAA,SAA+BW,EAA2B,CAC3E,GAAI,CACF,OAAOD,EAAKC,CAAc,CAAA,IAAI,QACvBxG,CAAK,CAAA,CACZ,KAAK,KAAMA,CAAAA,CAAG,EAElB,CAAA,CAAC,EAEH,MAAM,IAAI,UAAU,wCAAwC,CAC9D,CACF,CAfAR,EAAAA,CAAA,OAAA8G,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,CAAAA,SAAAA,EAAAA,UAAAA,CAAAA,IAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,MAAAA,CAAAA,cAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,WAAAA,KAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,IAAAA,CAAAA,IAAAA,CAAAA,CAAAA,MAAAA,CAAAA,SAAAA,CAAAA,cAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,OAAAA,CAAAA,EAAAA,UAAAA,EAAAA,CAAAA,GAAAA,IAAAA,CAAAA,MAAAA,IAAAA,SAAAA,CAAAA,sBAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,+BAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,IAAAA,CAAAA,WAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,GAAAA,IAAAA,CAAAA,MAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,kBAAAA,CAAAA,EAAAA,CAAAA,wBAAAA,CAAAA,SAAAA,CChBA,IAAAjB,EAAA,CAAA,EAAA,EAAA,CAcA,SAAgBoB,EACd/C,CAAAA,CAAAA,CACAgD,EACAC,CACAC,CAAAA,CAAAA,CACAC,CAAuB,CAAA,CAEvB,OAAO,IAAIC,EAAAA,CAAmBpD,EAAagD,CAAQC,CAAAA,CAAAA,CAAYC,EAASC,CAAU,CACpF,CARArH,EAAAA,CAAA,yBAAAiH,EAcA,CAAA,IAAAK,GAAA,SAAAnH,CAAAA,CAAA,CAA2C8D,EAAAqD,CAAAA,CAAAA,CAAAnH,CAAA,CAAA,CAiBzC,SAAAmH,CACEpD,CAAAA,CAAAA,CACAgD,EACAC,CACAC,CAAAA,CAAAA,CACQC,EACAE,CAAiC,CAAA,CAN3C,IAAApD,CAAAA,CAoBEhE,EAAA,IAAA,CAAA,IAAA,CAAM+D,CAAW,CAAC,EAAA,IAAA,CAfV,OAAAC,CAAA,CAAA,UAAA,CAAAkD,CACAlD,CAAAA,CAAAA,CAAA,kBAAAoD,CAeRpD,CAAAA,CAAAA,CAAK,MAAQ+C,CACT,CAAA,SAAuCnH,EAAQ,CAC7C,GAAI,CACFmH,CAAAA,CAAOnH,CAAK,EACLS,CAAAA,MAAAA,CAAAA,CAAK,CACZ0D,CAAAA,CAAY,MAAM1D,CAAG,EAAA,CAEzB,CACAL,CAAAA,CAAAA,CAAA,UAAM,KACVgE,CAAAA,CAAAA,CAAK,OAASiD,CACV,CAAA,SAAuC5G,EAAQ,CAC7C,GAAI,CACF4G,CAAAA,CAAQ5G,CAAG,EACJA,CAAAA,MAAAA,CAAAA,CAAK,CAEZ0D,CAAY,CAAA,KAAA,CAAM1D,CAAG,EAGrB,CAAA,OAAA,CAAA,IAAA,CAAK,WAAW,GAAA,CAEpB,EACAL,CAAA,CAAA,SAAA,CAAM,OACVgE,CAAK,CAAA,SAAA,CAAYgD,EACb,UAAA,CACE,GAAI,CACFA,IACO3G,CAAAA,MAAAA,CAAAA,CAAK,CAEZ0D,CAAY,CAAA,KAAA,CAAM1D,CAAG,EAGrB,CAAA,OAAA,CAAA,IAAA,CAAK,WAAW,GAAA,CAEpB,EACAL,CAAA,CAAA,SAAA,CAAM,WACZ,CAEA,OAAAmH,EAAA,SAAA,CAAA,WAAA,CAAA,UAAA,CAAA,IAAA,CAAA,CACE,GAAI,CAAC,IAAA,CAAK,mBAAqB,IAAK,CAAA,iBAAA,GAAqB,CAC/C,IAAAE,CAAW,CAAA,IAAA,CAAI,OACvBrH,CAAA,CAAA,SAAA,CAAM,YAAW,IAAA,CAAA,IAAA,EAEjB,CAACqH,CAAAA,GAAAA,CAAUvF,CAAA,CAAA,IAAA,CAAK,cAAU,IAAAA,EAAAA,CAAAA,GAAA,SAAAA,EAAAA,CAAAA,CAAA,KAAf,IAAI,CAAA,EAAA,CAEnB,CACFqF,CAAAA,CAAA,EAnF2CzB,EAAA,CAAA,UAAU,EAAxC7F,EAAA,CAAA,kBAAA,CAAAsH,8FCzBb,IAAAG,EAAAA,CAAA,CACAC,EAAAA,CAAAA,EAAAA,CAAA,IA4DA,SAAgBC,EAAAA,EAAQ,CACtB,OAAOF,EAAAA,CAAA,QAAQ,SAACpB,CAAAA,CAAQlB,CAAU,CAAA,CAChC,IAAIyC,CAAkC,CAAA,IAAA,CAErCvB,EAAe,SAEhB,EAAA,CAAA,IAAMwB,EAAaH,EAAA,CAAA,wBAAA,CAAyBvC,CAAY,CAAA,SAAA,CAAW,UAAW,SAAW,CAAA,UAAA,CACvF,GAAI,CAACkB,GAAWA,CAAe,CAAA,SAAA,EAAa,CAAK,EAAA,CAAA,CAAI,EAAGA,CAAe,CAAA,SAAA,CAAW,CAChFuB,CAAa,CAAA,IAAA,CACb,OA4BF,IAAME,CAAAA,CAAoBzB,CAAe,CAAA,WAAA,CACnC0B,EAAOH,CACbA,CAAAA,CAAAA,CAAa,KAETE,CAAqB,GAAA,CAACC,GAAQD,CAAqBC,GAAAA,CAAAA,CAAAA,EACrDD,CAAiB,CAAA,WAAA,GAGnB3C,CAAW,CAAA,WAAA,GACb,CAAC,CAAA,CAEDkB,EAAO,SAAUwB,CAAAA,CAAU,CAEtBA,CAAAA,CAAAA,CAAW,SACdD,CAAcvB,CAAAA,CAAAA,CAAoC,OAAO,EAAA,EAE7D,CAAC,CACH,CAtDArG,EAAA,CAAA,QAAA,CAAA2H,gmBC/DA,IAAAK,EAAAA,CAAA,IAEArE,EAAA,CAAA,CAAA,EAAA,CACAsE,GAAA,EACAP,EAAAA,CAAAA,EAAAA,CAAA,CACAD,EAAAA,CAAAA,EAAAA,CAAA,IASAS,EAAA,CAAA,SAAA/H,EAAA,CAA8C8D,EAAAA,CAAAiE,EAAA/H,CAAA,CAAA,CAgB5C,SAAA+H,CAAAA,CAAmB7B,EAAiC8B,CAAgC,CAAA,CAApF,IAAAhE,CACEhE,CAAAA,CAAAA,CAAA,KAAA,IAAA,CAAA,EAAO,IADU,CAAA,OAAAgE,EAAA,MAAAkC,CAAAA,CAAAA,CAAiClC,EAAA,cAAAgE,CAAAA,CAAAA,CAf1ChE,EAAA,QAA8B,CAAA,IAAA,CAC9BA,CAAA,CAAA,SAAA,CAAoB,EACpBA,CAAA,CAAA,WAAA,CAAmC,KAkBvCsD,EAAA,CAAA,OAAA,CAAQpB,CAAM,CAChBlC,GAAAA,CAAAA,CAAK,IAAOkC,CAAAA,CAAAA,CAAO,OAEvB,CAGU,OAAA6B,EAAA,SAAA,CAAA,UAAA,CAAV,SAAqB/C,CAAyB,CAAA,CAC5C,OAAO,IAAA,CAAK,YAAa,CAAA,SAAA,CAAUA,CAAU,CAC/C,CAAA,CAEU+C,EAAA,SAAA,CAAA,UAAA,CAAV,UAAA,CACE,IAAME,CAAU,CAAA,IAAA,CAAK,SACrB,OAAI,CAAA,CAACA,GAAWA,CAAQ,CAAA,SAAA,IACtB,IAAK,CAAA,QAAA,CAAW,KAAK,cAAc,EAAA,CAAA,CAE9B,KAAK,QACd,CAAA,CAEUF,EAAA,SAAA,CAAA,SAAA,CAAV,UAAA,CACE,KAAK,SAAY,CAAA,CAAA,CACT,IAAAG,CAAgB,CAAA,IAAA,CAAI,YAC5B,IAAK,CAAA,QAAA,CAAW,IAAK,CAAA,WAAA,CAAc,KACnCA,CAAa,EAAA,WAAA,GACf,CAMAH,CAAAA,CAAAA,CAAA,UAAA,OAAA,CAAA,UAAA,CAAA,IAAA/D,EAAA,IACMyD,CAAAA,CAAAA,CAAa,KAAK,WACtB,CAAA,GAAI,CAACA,CAAY,CAAA,CACfA,CAAa,CAAA,IAAA,CAAK,YAAc,IAAIjE,EAAAA,CAAA,aACpC,IAAM2E,CAAAA,CAAU,KAAK,UAAU,EAAA,CAC/BV,CAAW,CAAA,GAAA,CACT,KAAK,MAAO,CAAA,SAAA,CACVF,GAAA,wBACEY,CAAAA,CAAAA,CACA,UACA,UAAA,CACEnE,CAAK,CAAA,SAAA,GACLmE,CAAQ,CAAA,QAAA,GACV,CACA,CAAA,SAAC9H,EAAG,CACF2D,CAAAA,CAAK,SAAS,EAAA,CACdmE,EAAQ,KAAM9H,CAAAA,CAAG,EACnB,CAAA,CACA,UAAA,CAAM,OAAA2D,CAAK,CAAA,SAAA,EAAL,CAAgB,CACvB,CACF,CAGCyD,CAAAA,CAAAA,CAAW,SACb,IAAK,CAAA,WAAA,CAAc,IACnBA,CAAAA,CAAAA,CAAajE,GAAA,YAAa,CAAA,KAAA,EAAA,CAG9B,OAAOiE,CACT,CAAA,CAMAM,EAAA,SAAA,CAAA,QAAA,CAAA,UAAA,CACE,OAAOD,EAAA,CAAA,QAAA,GAAsB,IAAI,CACnC,EACFC,CAAA,CAAA,CAxF8CF,EAAA,CAAA,UAAU,EAA3ChI,EAAA,CAAA,qBAAA,CAAAkI,kHCTAlI,EAAA,CAAA,4BAAA,CAA6D,CACxE,GAAG,CAAA,UAAA,CAGD,OAAA,CAAQA,GAAA,4BAA6B,CAAA,QAAA,EAAY,aAAa,GAAG,EACnE,EACA,QAAU,CAAA,SAAA,EAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,IAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,MAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,OAAA,MAAA,EAAA,UAAA,EAAA,CAAA,CAAA,MAAA,CAAA,QAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,GAAA,CAAA,KAAA,CAAA,CAAA,GAAA,KAAA,CAAA,EAAA,CAAA,EAAA,EAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,EAAA,IAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,KAAA,EAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,IAAA,GAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,MAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,aAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,MAAA,CAAA,cAAA,CAAA,CAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,sBAAA,CAAA,SAAA,CCZZ,IAAA2D,EAAAA,CAAA,IAca3D,CAAA,CAAA,sBAAA,CAAiD,CAG5D,QAAA,CAAA,SAASuI,EAAQ,CACf,IAAIC,CAAU,CAAA,qBAAA,CACVC,EAAkD,oBAC9ChG,CAAAA,CAAAA,CAAazC,EAAA,sBAAsB,CAAA,QAAA,CACvCyC,IACF+F,CAAU/F,CAAAA,CAAAA,CAAS,qBACnBgG,CAAAA,CAAAA,CAAShG,EAAS,oBAEpB,CAAA,CAAA,IAAMC,CAAS8F,CAAAA,CAAAA,CAAQ,SAACE,CAAS,CAAA,CAI/BD,CAAS,CAAA,SAAA,CACTF,EAASG,CAAS,EACpB,CAAC,CACD,CAAA,OAAO,IAAI/E,EAAA,CAAA,YAAA,CAAa,UAAA,CAAM,OAAA8E,CAAS/F,GAAAA,CAAM,CAAf,CAAgB,CAChD,EACA,qBAAqB,CAAA,UAAA,CAACH,IAAAA,IAAAA,CAAAA,CAAA,EAAAC,CAAAA,CAAAA,CAAA,EAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,CAAA,CAAA,CAAA,UAAAA,CAAA,CAAA,CACZ,IAAAC,CAAazC,CAAAA,CAAAA,CAAA,uBAAsB,QAC3C,CAAA,OAAA,CAAQyC,CAAU,EAAA,qBAAA,EAAyB,uBAAsB,KAAA,CAAA,SAAA,CAAAX,GAAA,EAAA,CAAAC,GAAIQ,CAAI,CAAA,CAAA,CAC3E,EACA,oBAAoB,CAAA,UAAA,SAACA,CAAA,CAAA,GAAAC,CAAA,CAAA,CAAA,CAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,CAAA,CAAA,CAAA,SAAA,CAAAA,CAAA,CACX,CAAA,IAAAC,CAAazC,CAAAA,CAAAA,CAAA,uBAAsB,QAC3C,CAAA,OAAA,CAAQyC,CAAU,EAAA,oBAAA,EAAwB,sBAAqB,KAAA,CAAA,SAAA,CAAAX,EAAA,CAAA,GAAAC,EAAIQ,CAAAA,CAAI,CAAA,CAAA,CACzE,EACA,QAAU,CAAA,SAAA,EAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,eAAA,CAAA,SAAA,CC1CZ,IAAAyF,EAAAA,CAAA,IAEAW,EAAA,CAAA,EAAA,EAAA,CACAC,GAAA,EAuEA,EAAA,CAAA,SAAgBC,GAAgBC,CAAqC,CAAA,CACnE,OAAOA,CAAAA,CAAoBC,GAAuBD,CAAiB,CAAA,CAAIE,EACzE,CAFAhJ,EAAAA,CAAA,gBAAA6I,EAQA,CAAA,SAASE,EAAuBD,CAAAA,CAAAA,CAAqC,CACnE,OAAO,IAAId,GAAA,UAAmD,CAAA,SAAC7C,EAAU,CAIvE,IAAM8D,CAAWH,CAAAA,CAAAA,EAAqBH,GAAA,4BAMhCO,CAAAA,CAAAA,CAAQD,EAAS,GAAG,EAAA,CAEtBE,EAAK,CACHC,CAAAA,CAAAA,CAAM,UAAA,CACLjE,EAAW,MACdgE,GAAAA,CAAAA,CAAKP,GAAA,sBAAuB,CAAA,qBAAA,CAAsB,SAACF,CAAuC,CAAA,CACxFS,CAAK,CAAA,CAAA,CAQL,IAAME,CAAMJ,CAAAA,CAAAA,CAAS,KACrB9D,CAAAA,CAAAA,CAAW,KAAK,CACd,SAAA,CAAW2D,CAAoBO,CAAAA,CAAAA,CAAMX,EACrC,OAASW,CAAAA,CAAAA,CAAMH,EAChB,CACDE,CAAAA,CAAAA,GACF,CAAC,CAAA,EAEL,CAEA,CAAA,OAAAA,GAEO,CAAA,UAAA,CACDD,CACFP,EAAAA,EAAAA,CAAA,uBAAuB,oBAAqBO,CAAAA,CAAE,EAElD,CACF,CAAC,CACH,CAMA,IAAMH,EAA2BD,CAAAA,EAAAA,6GCnIjC,IAAAzI,EAAAA,CAAA,EAqBaN,EAAAA,CAAAA,EAAAA,CAAA,wBAAuDM,EAAA,CAAA,gBAAA,CAClE,SAACH,CAAM,CAAA,CACL,OAAA,UAAoC,CAClCA,CAAO,CAAA,IAAI,EACX,IAAK,CAAA,IAAA,CAAO,0BACZ,IAAK,CAAA,OAAA,CAAU,sBACjB,CAJA,CAIC,EC1BL,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,IAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,SAAA,EAAA,UAAA,CAAA,IAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,MAAA,CAAA,cAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAA,WAAA,KAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,CAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,OAAA,CAAA,EAAA,UAAA,EAAA,CAAA,GAAA,IAAA,CAAA,MAAA,IAAA,SAAA,CAAA,sBAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,+BAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,IAAA,CAAA,WAAA,CAAA,EAAA,CAAA,CAAA,CAAA,SAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,SAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,QAAA,EAAA,SAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,OAAA,MAAA,EAAA,UAAA,EAAA,MAAA,CAAA,QAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,OAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,EAAA,OAAA,CAAA,CAAA,MAAA,EAAA,QAAA,CAAA,OAAA,CAAA,IAAA,CAAA,UAAA,CAAA,OAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,MAAA,GAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,IAAA,SAAA,CAAA,CAAA,CAAA,yBAAA,CAAA,iCAAA,CAAA,CAAA,CAAA,MAAA,CAAA,cAAA,CAAA,CAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,gBAAA,CAAA,CAAA,CAAA,OAAA,CAAA,SAAA,CAAA,IAAA6H,GAAA,CAEArE,EAAAA,CAAAA,EAAAA,CAAA,IAEA2F,EAAA,CAAA,EAAA,EAAA,CACAvI,GAAA,CACAgD,EAAAA,CAAAA,EAAAA,CAAA,EASAwF,EAAAA,CAAAA,EAAAA,CAAA,SAAApJ,CAAA,CAAA,CAAgC8D,GAAAsF,CAAApJ,CAAAA,CAAA,EAwB9B,SAAAoJ,CAAAA,EAAA,CAAA,IAAApF,EAEEhE,CAAA,CAAA,IAAA,CAAA,IAAA,CAAO,EAAA,IAAA,CAzBT,OAAAgE,CAAA,CAAA,MAAA,CAAS,KAEDA,CAAAA,CAAAA,CAAA,iBAAyC,IAGjDA,CAAAA,CAAAA,CAAA,SAA2B,CAAA,GAE3BA,CAAA,CAAA,SAAA,CAAY,KAEZA,CAAAA,CAAAA,CAAA,SAAW,KAEXA,CAAAA,CAAAA,CAAA,YAAmB,IAenB,CAAA,CAAA,CAGA,OAAAoF,CAAA,CAAA,SAAA,CAAA,IAAA,CAAA,SAAQrD,EAAwB,CAC9B,IAAMkC,EAAU,IAAIoB,EAAAA,CAAiB,KAAM,IAAI,CAAA,CAC/C,OAAApB,CAAAA,CAAQ,SAAWlC,CACZkC,CAAAA,CACT,EAGUmB,CAAA,CAAA,SAAA,CAAA,eAAV,UAAA,CACE,GAAI,IAAA,CAAK,OACP,MAAM,IAAID,GAAA,uBAEd,CAAA,CAEAC,EAAA,SAAA,CAAA,IAAA,CAAA,SAAKxJ,CAAAA,CAAQ,CAAb,IAAAoE,CAAAA,CAAA,KACEJ,EAAA,CAAA,YAAA,CAAa,UAAA,CAEX,IAAA,CAAA,CAAA,CAAA,CAAA,GADAI,CAAK,CAAA,cAAA,GACD,CAACA,CAAAA,CAAK,UAAW,CACdA,CAAAA,CAAK,mBACRA,CAAK,CAAA,gBAAA,CAAmB,KAAM,CAAA,IAAA,CAAKA,EAAK,SAAS,CAAA,CAAA,CAAA,GAAA,CAEnD,QAAuBsF,CAAArI,CAAAA,EAAAA,CAAA+C,EAAK,gBAAgB,CAAA,CAAAuF,CAAAD,CAAAA,CAAAA,CAAA,MAAA,CAAA,CAAAC,CAAA,CAAA,IAAA,CAAAA,EAAAD,CAAA,CAAA,IAAA,EAAE,CAAA,CAAzC,IAAME,CAAQD,CAAAA,CAAAA,CAAA,MACjBC,CAAS,CAAA,IAAA,CAAK5J,CAAK,EAGzB,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,IAAA,GAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,MAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAC,EACH,CAAA,CAEAwJ,EAAA,SAAA,CAAA,KAAA,CAAA,SAAM/I,CAAQ,CAAA,CAAd,IAAA2D,CAAA,CAAA,IAAA,CACEJ,EAAA,CAAA,YAAA,CAAa,UAAA,CAEX,GADAI,EAAK,cAAc,EAAA,CACf,CAACA,CAAK,CAAA,SAAA,CAAW,CACnBA,CAAAA,CAAK,SAAWA,CAAK,CAAA,SAAA,CAAY,KACjCA,CAAK,CAAA,WAAA,CAAc3D,EAEnB,IADQoJ,IAAAA,CAAAA,CAAczF,CAAI,CAAA,SAAA,CACnByF,EAAU,MACfA,EAAAA,CAAAA,CAAU,OAAS,CAAA,KAAA,CAAMpJ,CAAG,EAGlC,CAAA,CAAC,EACH,CAAA,CAEA+I,EAAA,SAAA,CAAA,QAAA,CAAA,UAAA,CAAA,IAAApF,EAAA,IACEJ,CAAAA,EAAAA,CAAA,YAAa,CAAA,UAAA,CAEX,GADAI,CAAAA,CAAK,gBACD,CAAA,CAACA,EAAK,SAAW,CAAA,CACnBA,CAAK,CAAA,SAAA,CAAY,KAEjB,IADQyF,IAAAA,CAAAA,CAAczF,CAAI,CAAA,SAAA,CACnByF,EAAU,MACfA,EAAAA,CAAAA,CAAU,KAAK,EAAA,CAAI,WAGzB,CAAA,CAAC,EACH,CAEAL,CAAAA,CAAAA,CAAA,UAAA,WAAA,CAAA,UAAA,CACE,IAAA,CAAK,UAAY,IAAK,CAAA,MAAA,CAAS,KAC/B,IAAK,CAAA,SAAA,CAAY,KAAK,gBAAmB,CAAA,KAC3C,CAEA,CAAA,MAAA,CAAA,eAAIA,CAAA,CAAA,SAAA,CAAA,WAAQ,CAAZ,GAAA,CAAA,UAAA,OACE,OAAOtH,CAAAA,CAAAA,CAAAA,CAAA,IAAK,CAAA,SAAA,IAAS,MAAAA,CAAA,GAAA,SAAA,CAAA,UAAAA,CAAE,CAAA,MAAA,EAAS,CAClC,CAGUsH,CAAAA,UAAAA,CAAAA,KAAAA,CAAAA,YAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAA,SAAA,CAAA,aAAA,CAAV,SAAwBpE,CAAyB,CAAA,CAC/C,YAAK,cAAc,EAAA,CACZhF,EAAA,SAAM,CAAA,aAAA,CAAa,IAAA,CAAA,IAAA,CAACgF,CAAU,CACvC,CAAA,CAGUoE,EAAA,SAAA,CAAA,UAAA,CAAV,SAAqBpE,CAAyB,CAAA,CAC5C,OAAK,IAAA,CAAA,cAAA,GACL,IAAK,CAAA,uBAAA,CAAwBA,CAAU,CAChC,CAAA,IAAA,CAAK,gBAAgBA,CAAU,CACxC,CAGUoE,CAAAA,CAAAA,CAAA,UAAA,eAAV,CAAA,SAA0BpE,EAA2B,CAArD,IAAAhB,EAAA,IACQlC,CAAAA,CAAAA,CAAqC,IAAnC4H,CAAAA,CAAAA,CAAQ5H,EAAA,QAAE6H,CAAAA,CAAAA,CAAS7H,EAAA,SAAE2H,CAAAA,CAAAA,CAAS3H,EAAA,SACtC,CAAA,OAAI4H,CAAYC,EAAAA,CAAAA,CACPnG,GAAA,kBAET,EAAA,IAAA,CAAK,iBAAmB,IACxBiG,CAAAA,CAAAA,CAAU,KAAKzE,CAAU,CAAA,CAClB,IAAIxB,EAAAA,CAAA,aAAa,UAAA,CACtBQ,EAAK,gBAAmB,CAAA,IAAA,CACxBpD,GAAA,SAAU6I,CAAAA,CAAAA,CAAWzE,CAAU,EACjC,CAAC,CACH,CAAA,CAAA,CAGUoE,EAAA,SAAA,CAAA,uBAAA,CAAV,SAAkCpE,CAA2B,CAAA,CACrD,IAAAlD,CAAAA,CAAuC,KAArC4H,CAAQ5H,CAAAA,CAAAA,CAAA,SAAE8H,CAAW9H,CAAAA,CAAAA,CAAA,YAAE6H,CAAS7H,CAAAA,CAAAA,CAAA,SACpC4H,CAAAA,CAAAA,CACF1E,EAAW,KAAM4E,CAAAA,CAAW,EACnBD,CACT3E,EAAAA,CAAAA,CAAW,WAEf,CAAA,CAQAoE,CAAA,CAAA,SAAA,CAAA,aAAA,UAAA,CACE,IAAMpD,CAAkB,CAAA,IAAI6B,GAAA,UAC5B,CAAA,OAAA7B,CAAW,CAAA,MAAA,CAAS,KACbA,CACT,CAAA,CAxHOoD,CAAA,CAAA,MAAA,CAAkC,SAAIrF,CAA0BmC,CAAAA,CAAAA,CAAqB,CAC1F,OAAO,IAAImD,EAAoBtF,CAAAA,CAAAA,CAAamC,CAAM,CACpD,CAAA,CAuHFkD,GA7IgCvB,EAAA,CAAA,UAAU,CAA7BhI,CAAAA,CAAAA,CAAA,QAAAuJ,EAkJb,CAAA,IAAAC,GAAA,SAAArJ,CAAAA,CAAA,CAAyC8D,EAAAuF,CAAAA,CAAAA,CAAArJ,CAAA,CAAA,CACvC,SAAAqJ,CAEStF,CAAAA,CAAAA,CACPmC,EAAsB,CAHxB,IAAAlC,EAKEhE,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,EAAO,KAHA,OAAAgE,CAAAA,CAAA,YAAAD,CAIPC,CAAAA,CAAAA,CAAK,OAASkC,CAChB,CAAA,CAAA,CAEA,OAAAmD,CAAAA,CAAA,UAAA,IAAA,CAAA,SAAKzJ,EAAQ,CACX0J,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAxH,EAAA,IAAK,CAAA,WAAA,IAAW,IAAAA,EAAAA,CAAAA,GAAA,UAAA,SAAAA,CAAAA,CAAAA,CAAE,QAAI,IAAAwH,EAAAA,CAAAA,GAAA,WAAAA,CAAA,CAAA,IAAA,CAAAxH,CAAGlC,CAAAA,CAAK,EAChC,CAEAyJ,CAAAA,CAAAA,CAAA,UAAA,KAAA,CAAA,SAAMhJ,EAAQ,CACZiJ,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAxH,CAAA,CAAA,IAAA,CAAK,eAAW,IAAAA,EAAAA,CAAAA,GAAA,SAAA,CAAA,SAAA,CAAAA,EAAE,KAAK,IAAA,IAAA,EAAAwH,CAAA,GAAA,SAAA,EAAAA,EAAA,IAAAxH,CAAAA,CAAAA,CAAGzB,CAAG,EAC/B,CAAA,CAEAgJ,EAAA,SAAA,CAAA,QAAA,CAAA,UAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CACEC,GAAAxH,CAAA,CAAA,IAAA,CAAK,eAAW,IAAAA,EAAAA,CAAAA,GAAA,UAAA,SAAAA,CAAAA,CAAAA,CAAE,QAAQ,IAAA,IAAA,EAAAwH,IAAA,SAAAA,EAAAA,CAAAA,CAAA,KAAAxH,CAAA,EAC5B,EAGUuH,CAAA,CAAA,SAAA,CAAA,UAAV,CAAA,SAAqBrE,EAAyB,CAC5C,IAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAOsE,GAAAxH,CAAA,CAAA,IAAA,CAAK,UAAM,IAAAA,EAAAA,CAAAA,GAAA,SAAA,CAAA,SAAA,CAAAA,EAAE,SAAUkD,CAAAA,CAAU,KAAC,IAAAsE,EAAAA,CAAAA,GAAA,UAAAA,CAAI9F,CAAAA,EAAAA,CAAA,kBAC/C,CAAA,CACF6F,CAAA,CA1ByCD,CAAAA,EAAO,EAAnCvJ,CAAA,CAAA,gBAAA,CAAAwJ,0lBClKb,IAAAQ,EAAAA,CAAA,CAUAC,EAAAA,CAAAA,EAAAA,CAAA,SAAA9J,CAAA,CAAA,CAAwC8D,GAAAgG,CAAA9J,CAAAA,CAAA,EACtC,SAAA8J,CAAAA,CAAoBC,CAAS,CAAA,CAA7B,IAAA/F,CACEhE,CAAAA,CAAAA,CAAA,IAAA,CAAA,IAAA,GAAO,IADW,CAAA,OAAAgE,CAAA,CAAA,MAAA,CAAA+F,GAEpB,CAEA,OAAA,MAAA,CAAA,eAAID,CAAA,CAAA,SAAA,CAAA,QAAK,CAAT,GAAA,CAAA,UAAA,CACE,OAAO,KAAK,QAAQ,EACtB,uCAGUA,CAAA,CAAA,SAAA,CAAA,WAAV,SAAqB9E,CAAAA,CAAyB,CAC5C,IAAMgF,EAAehK,CAAA,CAAA,SAAA,CAAM,WAAU,IAAA,CAAA,IAAA,CAACgF,CAAU,CAChD,CAAA,OAAA,CAACgF,CAAa,CAAA,MAAA,EAAUhF,EAAW,IAAK,CAAA,IAAA,CAAK,MAAM,CAC5CgF,CAAAA,CACT,EAEAF,CAAA,CAAA,SAAA,CAAA,QAAA,CAAA,UAAA,CACQ,IAAAhI,CAAAA,CAAoC,KAAlC4H,CAAQ5H,CAAAA,CAAAA,CAAA,SAAE8H,CAAW9H,CAAAA,CAAAA,CAAA,WAAEiI,CAAAA,CAAAA,CAAMjI,EAAA,MACrC,CAAA,GAAI4H,EACF,MAAME,CAAAA,CAER,YAAK,cAAc,EAAA,CACZG,CACT,CAAA,CAEAD,EAAA,SAAA,CAAA,IAAA,CAAA,SAAKlK,CAAQ,CAAA,CACXI,EAAA,SAAM,CAAA,IAAA,CAAI,IAAA,CAAA,IAAA,CAAE,KAAK,MAASJ,CAAAA,CAAM,EAClC,CACFkK,CAAAA,CAAA,EA5BwCD,EAAA,CAAA,OAAO,CAAlChK,CAAAA,EAAAA,CAAA,gBAAAiK,GCJAjK,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,qBAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAA,sBAA+C,CAC1D,GAAA,CAAG,UAAA,CAGD,OAAA,CAAQA,EAAA,CAAA,qBAAA,CAAsB,UAAY,IAAM,EAAA,GAAA,EAClD,CACA,CAAA,QAAA,CAAU,gmBCZZ,IAAAgK,EAAAA,CAAA,CAIAI,EAAAA,CAAAA,EAAAA,CAAA,KAgCAC,EAAA,CAAA,SAAAlK,EAAA,CAAsC8D,EAAAA,CAAAoG,EAAAlK,CAAA,CAAA,CAUpC,SAAAkK,CAAAA,CACUC,EACAC,CACAC,CAAAA,CAAAA,CAA6D,CAF7DF,CAAA,GAAA,SAAA,GAAAA,EAAA,CACAC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAA,SAAAA,GAAAA,CAAAA,CAAA,KACAC,CAAA,GAAA,SAAA,GAAAA,EAAwCJ,EAAA,CAAA,qBAAA,CAAA,CAHlD,IAAAjG,CAKEhE,CAAAA,CAAAA,CAAA,IAAA,CAAA,IAAA,GAAO,IAJC,CAAA,OAAAgE,EAAA,WAAAmG,CAAAA,CAAAA,CACAnG,EAAA,WAAAoG,CAAAA,CAAAA,CACApG,CAAA,CAAA,kBAAA,CAAAqG,EAZFrG,CAAA,CAAA,OAAA,CAA0B,EAC1BA,CAAAA,CAAAA,CAAA,oBAAsB,IAc5BA,CAAAA,CAAAA,CAAK,mBAAsBoG,CAAAA,CAAAA,GAAgB,IAC3CpG,CAAK,CAAA,WAAA,CAAc,IAAK,CAAA,GAAA,CAAI,EAAGmG,CAAW,CAAA,CAC1CnG,CAAK,CAAA,WAAA,CAAc,KAAK,GAAI,CAAA,CAAA,CAAGoG,CAAW,CAC5C,CAAA,CAAA,CAEA,OAAAF,CAAA,CAAA,SAAA,CAAA,IAAA,CAAA,SAAKtK,EAAQ,CACL,IAAAkC,EAA+E,IAA7E6H,CAAAA,CAAAA,CAAS7H,EAAA,SAAEwI,CAAAA,CAAAA,CAAOxI,CAAA,CAAA,OAAA,CAAEyI,EAAmBzI,CAAA,CAAA,mBAAA,CAAEuI,EAAkBvI,CAAA,CAAA,kBAAA,CAAEsI,EAAWtI,CAAA,CAAA,WAAA,CAC3E6H,CACHW,GAAAA,CAAAA,CAAQ,KAAK1K,CAAK,CAAA,CAClB,CAAC2K,CAAuBD,EAAAA,CAAAA,CAAQ,KAAKD,CAAmB,CAAA,GAAA,EAAQD,CAAAA,CAAW,GAE7E,IAAK,CAAA,WAAA,GACLpK,CAAA,CAAA,SAAA,CAAM,KAAI,IAAA,CAAA,IAAA,CAACJ,CAAK,EAClB,EAGUsK,CAAA,CAAA,SAAA,CAAA,WAAV,SAAqBlF,CAAAA,CAAyB,CAC5C,IAAK,CAAA,cAAA,EACL,CAAA,IAAA,CAAK,aAQL,CAAA,IAAA,IANMgF,EAAe,IAAK,CAAA,eAAA,CAAgBhF,CAAU,CAE9ClD,CAAAA,CAAAA,CAAmC,IAAjCyI,CAAAA,CAAAA,CAAmBzI,EAAA,mBAAEwI,CAAAA,CAAAA,CAAOxI,CAAA,CAAA,OAAA,CAG9B0I,EAAOF,CAAQ,CAAA,KAAA,EACZG,CAAAA,CAAAA,CAAI,EAAGA,CAAID,CAAAA,CAAAA,CAAK,QAAU,CAACxF,CAAAA,CAAW,OAAQyF,CAAKF,EAAAA,CAAAA,CAAsB,CAAI,CAAA,CAAA,CACpFvF,EAAW,IAAKwF,CAAAA,CAAAA,CAAKC,CAAC,CAAM,CAAA,CAG9B,YAAK,uBAAwBzF,CAAAA,CAAU,CAEhCgF,CAAAA,CACT,EAEQE,CAAA,CAAA,SAAA,CAAA,YAAR,UAAA,CACQ,IAAApI,CAAoE,CAAA,IAAA,CAAlEqI,CAAWrI,CAAAA,CAAAA,CAAA,YAAEuI,CAAkBvI,CAAAA,CAAAA,CAAA,mBAAEwI,CAAOxI,CAAAA,CAAAA,CAAA,QAAEyI,CAAmBzI,CAAAA,CAAAA,CAAA,mBAK/D4I,CAAAA,CAAAA,CAAAA,CAAsBH,EAAsB,CAAI,CAAA,CAAA,EAAKJ,EAK3D,GAJAA,CAAAA,CAAc,KAAYO,CAAqBJ,CAAAA,CAAAA,CAAQ,MAAUA,EAAAA,CAAAA,CAAQ,OAAO,CAAGA,CAAAA,CAAAA,CAAQ,OAASI,CAAkB,CAAA,CAIlH,CAACH,CAAqB,CAAA,CAKxB,IAJMrB,IAAAA,CAAAA,CAAMmB,EAAmB,GAAG,EAAA,CAC9BM,EAAO,CAGFF,CAAAA,CAAAA,CAAI,EAAGA,CAAIH,CAAAA,CAAAA,CAAQ,MAAWA,EAAAA,CAAAA,CAAQG,CAAC,CAAgBvB,EAAAA,CAAAA,CAAKuB,CAAK,EAAA,CAAA,CACxEE,EAAOF,CAETE,CAAAA,CAAAA,EAAQL,CAAQ,CAAA,MAAA,CAAO,EAAGK,CAAO,CAAA,CAAC,GAEtC,CACFT,CAAAA,CAAA,EAzEsCL,EAAA,CAAA,OAAO,CAAhChK,CAAAA,EAAAA,CAAA,cAAAqK,GCpCb,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,SAAA,EAAA,UAAA,CAAA,IAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,MAAA,CAAA,cAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAA,WAAA,KAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,CAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,OAAA,CAAA,EAAA,UAAA,EAAA,CAAA,GAAA,IAAA,CAAA,MAAA,IAAA,SAAA,CAAA,sBAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,+BAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,IAAA,CAAA,WAAA,CAAA,EAAA,CAAA,CAAA,CAAA,SAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,SAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,YAAA,CAAA,SAAA,CAAA,IAAAL,GAAA,CASAe,EAAAA,CAAAA,EAAAA,CAAA,SAAA5K,CAAA,CAAA,CAAqC8D,EAAA8G,CAAAA,CAAAA,CAAA5K,CAAA,CAArC,CAAA,SAAA4K,GAAA,CAAA,IAAA5G,EAAAhE,CAAA,GAAA,IAAA,EAAAA,CAAA,CAAA,KAAA,CAAA,KAAA,SAAA,CAAA,EAAA,KACU,OAAAgE,CAAAA,CAAA,OAAmB,IACnBA,CAAAA,CAAAA,CAAA,SAAY,CAAA,KAAA,CACZA,EAAA,WAAc,CAAA,KAAA,CAAA,CA4BxB,CAzBY,OAAA4G,CAAAA,CAAA,UAAA,uBAAV,CAAA,SAAkC5F,CAAyB,CAAA,CACnD,IAAAlD,CAAuE,CAAA,IAAA,CAArE4H,EAAQ5H,CAAA,CAAA,QAAA,CAAE+I,EAAS/I,CAAA,CAAA,SAAA,CAAEiI,CAAMjI,CAAAA,CAAAA,CAAA,OAAE8H,CAAW9H,CAAAA,CAAAA,CAAA,YAAE6H,CAAS7H,CAAAA,CAAAA,CAAA,UAAEgJ,CAAWhJ,CAAAA,CAAAA,CAAA,WACpE4H,CAAAA,CAAAA,CACF1E,EAAW,KAAM4E,CAAAA,CAAW,GACnBD,CAAamB,EAAAA,CAAAA,IACtBD,GAAa7F,CAAW,CAAA,IAAA,CAAK+E,CAAO,CAAA,CACpC/E,EAAW,QAAQ,EAAA,EAEvB,EAEA4F,CAAA,CAAA,SAAA,CAAA,KAAA,SAAKhL,CAAAA,CAAQ,CACN,IAAA,CAAK,YACR,IAAK,CAAA,MAAA,CAASA,EACd,IAAK,CAAA,SAAA,CAAY,MAErB,CAEAgL,CAAAA,CAAAA,CAAA,SAAA,CAAA,QAAA,CAAA,UAAA,CACQ,IAAA9I,EAAqC,IAAnC+I,CAAAA,CAAAA,CAAS/I,EAAA,SAAEiI,CAAAA,CAAAA,CAAMjI,CAAA,CAAA,MAAA,CAAEgJ,EAAWhJ,CAAA,CAAA,WAAA,CACjCgJ,IACH,IAAK,CAAA,WAAA,CAAc,KACnBD,CAAa7K,EAAAA,CAAAA,CAAA,SAAM,CAAA,IAAA,CAAI,KAAA,IAAC+J,CAAAA,CAAO,EAC/B/J,CAAA,CAAA,SAAA,CAAM,SAAQ,IAAA,CAAA,IAAA,CAElB,EAAA,CAAA,CACF4K,CAAA,CA/BqCf,CAAAA,EAAAA,CAAA,OAAO,CAA/BhK,CAAAA,EAAAA,CAAA,aAAA+K,GCRb,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,SAAA,EAAA,UAAA,CAAA,IAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,MAAA,CAAA,cAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAA,WAAA,KAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,CAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,OAAA,CAAA,EAAA,UAAA,EAAA,CAAA,GAAA,IAAA,CAAA,MAAA,IAAA,SAAA,CAAA,sBAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,+BAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,IAAA,CAAA,WAAA,CAAA,EAAA,CAAA,CAAA,CAAA,SAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,SAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,MAAA,CAAA,SAAA,CAAA,IAAApH,EAAA,CAAA,CAAA,EAAA,CAiBAuH,GAAA,SAAA/K,CAAAA,CAAA,CAA+B8D,EAAAiH,CAAAA,CAAAA,CAAA/K,CAAA,CAC7B,CAAA,SAAA+K,CAAYC,CAAAA,CAAAA,CAAsBC,EAAmD,CACnFjL,OAAAA,CAAAA,CAAA,IAAA,CAAA,IAAA,GAAO,IACT,CAWO,OAAA+K,CAAAA,CAAA,UAAA,QAAP,CAAA,SAAgBG,EAAWC,CAAiB,CAAA,CAAjB,OAClB,IACT,CACFJ,CAAAA,CAAA,EAjB+BvH,EAAA,CAAA,YAAY,EAA9B3D,EAAA,CAAA,MAAA,CAAAkL,GCHAlL,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,MAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,OAAAA,MAAAA,EAAAA,UAAAA,EAAAA,CAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,KAAAA,CAAAA,CAAAA,GAAAA,KAAAA,CAAAA,EAAAA,CAAAA,EAAAA,EAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,EAAAA,IAAAA,EAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,EAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,aAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,gBAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAA,iBAAqC,CAGhD,WAAA,CAAA,SAAYqC,CAAqBC,CAAAA,CAAAA,CAAgB,SAAEC,CAAA,CAAA,EAAAC,CAAAA,CAAAA,CAAA,EAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,EAAA,CAAA,CAAA,CAAA,SAAAA,CAAAA,CAAA,EACzC,IAAAC,CAAAA,CAAazC,EAAA,gBAAgB,CAAA,QAAA,CACrC,OAAIyC,CAAU,EAAA,WAAA,CACLA,CAAS,CAAA,WAAA,CAAW,MAApBA,CAAQX,CAAAA,EAAAA,CAAA,CAAaO,CAASC,CAAAA,CAAO,EAAAP,EAAKQ,CAAAA,CAAI,CAAA,CAAA,EAEhD,WAAW,CAAA,KAAA,CAAA,UAAAT,EAAA,CAAA,CAACO,EAASC,CAAO,CAAA,CAAAP,EAAKQ,CAAAA,CAAI,CAAA,CAAA,CAC9C,CACA,CAAA,aAAA,CAAA,SAAcG,CAAM,CAAA,CACV,IAAAD,CAAAA,CAAazC,EAAA,gBAAgB,CAAA,QAAA,CACrC,QAAQyC,CAAU,EAAA,aAAA,EAAiB,eAAeC,CAAa,CACjE,CACA,CAAA,QAAA,CAAU,8lBC7BZ,IAAA6I,EAAAA,CAAA,KAIAC,EAAA,CAAA,EAAA,EAAA,CACAzK,GAAA,CAGA0K,EAAAA,CAAAA,EAAAA,CAAA,SAAAtL,CAAAA,CAAA,CAAoC8D,EAAAwH,CAAAA,CAAAA,CAAAtL,CAAA,CAOlC,CAAA,SAAAsL,EAAsBN,CAAqCC,CAAAA,CAAAA,CAAmD,CAA9G,IAAAjH,EACEhE,CAAA,CAAA,IAAA,CAAA,KAAMgL,CAAWC,CAAAA,CAAI,GAAC,IADF,CAAA,OAAAjH,CAAA,CAAA,SAAA,CAAAgH,EAAqChH,CAAA,CAAA,IAAA,CAAAiH,EAFjDjH,CAAA,CAAA,OAAA,CAAmB,OAI7B,CAEO,OAAAsH,CAAA,CAAA,SAAA,CAAA,SAAP,SAAgBJ,CAAAA,CAAWC,EAAiB,CAC1C,IAAA,CAAA,CAAA,GADyBA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,CACrB,CAAA,CAAA,IAAA,CAAK,OACP,OAAO,IAAA,CAIT,KAAK,KAAQD,CAAAA,CAAAA,CAEb,IAAMlC,CAAK,CAAA,IAAA,CAAK,EACVgC,CAAAA,CAAAA,CAAY,KAAK,SAuBvB,CAAA,OAAIhC,CAAM,EAAA,IAAA,GACR,KAAK,EAAK,CAAA,IAAA,CAAK,cAAegC,CAAAA,CAAAA,CAAWhC,EAAImC,CAAK,CAAA,CAAA,CAKpD,KAAK,OAAU,CAAA,IAAA,CAEf,KAAK,KAAQA,CAAAA,CAAAA,CAEb,IAAK,CAAA,EAAA,CAAA,CAAKrJ,EAAA,IAAK,CAAA,EAAA,IAAE,MAAAA,CAAA,GAAA,SAAA,CAAAA,EAAI,IAAK,CAAA,cAAA,CAAekJ,CAAW,CAAA,IAAA,CAAK,GAAIG,CAAK,CAAA,CAE3D,IACT,CAEUG,CAAAA,CAAAA,CAAA,UAAA,cAAV,CAAA,SAAyBN,CAA2BO,CAAAA,CAAAA,CAAmBJ,EAAiB,CAAjB,OAAAA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,GAC9DE,EAAA,CAAA,gBAAA,CAAiB,WAAYL,CAAAA,CAAAA,CAAU,MAAM,IAAKA,CAAAA,CAAAA,CAAW,IAAI,CAAGG,CAAAA,CAAK,CAClF,CAEUG,CAAAA,CAAAA,CAAA,SAAA,CAAA,cAAA,CAAV,SAAyBE,CAA4BxC,CAAAA,CAAAA,CAAkBmC,EAAwB,CAE7F,GAFqEA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,CAEjEA,CAAAA,CAAAA,CAAAA,EAAS,MAAQ,IAAK,CAAA,KAAA,GAAUA,GAAS,IAAK,CAAA,OAAA,GAAY,MAC5D,OAAOnC,CAAAA,CAILA,CAAM,EAAA,IAAA,EACRqC,GAAA,gBAAiB,CAAA,aAAA,CAAcrC,CAAE,EAIrC,CAAA,CAMOsC,EAAA,SAAA,CAAA,OAAA,CAAP,SAAeJ,CAAAA,CAAUC,EAAa,CACpC,GAAI,KAAK,MACP,CAAA,OAAO,IAAI,KAAM,CAAA,8BAA8B,CAGjD,CAAA,IAAA,CAAK,QAAU,KACf,CAAA,IAAMpI,EAAQ,IAAK,CAAA,QAAA,CAASmI,EAAOC,CAAK,CAAA,CACxC,GAAIpI,CAAAA,CACF,OAAOA,CACE,CAAA,IAAA,CAAK,UAAY,KAAS,EAAA,IAAA,CAAK,IAAM,IAc9C,GAAA,IAAA,CAAK,EAAK,CAAA,IAAA,CAAK,eAAe,IAAK,CAAA,SAAA,CAAW,KAAK,EAAI,CAAA,IAAI,GAE/D,CAEUuI,CAAAA,CAAAA,CAAA,SAAA,CAAA,QAAA,CAAV,SAAmBJ,CAAUO,CAAAA,CAAAA,CAAc,CACzC,IAAIC,CAAAA,CAAmB,MACnBC,CACJ,CAAA,GAAI,CACF,IAAA,CAAK,KAAKT,CAAK,EAAA,CAAA,MACR7J,EAAG,CACVqK,CAAAA,CAAU,KAIVC,CAAatK,CAAAA,CAAAA,EAAQ,IAAI,KAAA,CAAM,oCAAoC,EAErE,CAAA,GAAIqK,EACF,OAAK,IAAA,CAAA,WAAA,GACEC,CAEX,CAAA,CAEAL,CAAA,CAAA,SAAA,CAAA,YAAA,UAAA,CACE,GAAI,CAAC,KAAK,MAAQ,CAAA,CACV,IAAAxJ,CAAAA,CAAoB,KAAlBkH,CAAElH,CAAAA,CAAAA,CAAA,GAAEkJ,CAASlJ,CAAAA,CAAAA,CAAA,UACb8J,CAAYZ,CAAAA,CAAAA,CAAS,OAE7B,CAAA,IAAA,CAAK,KAAO,IAAK,CAAA,KAAA,CAAQ,KAAK,SAAY,CAAA,IAAA,CAC1C,KAAK,OAAU,CAAA,KAAA,CAEfpK,EAAA,CAAA,SAAA,CAAUgL,EAAS,IAAI,CAAA,CACnB5C,GAAM,IACR,GAAA,IAAA,CAAK,GAAK,IAAK,CAAA,cAAA,CAAegC,CAAWhC,CAAAA,CAAAA,CAAI,IAAI,CAGnD,CAAA,CAAA,IAAA,CAAK,MAAQ,IACbhJ,CAAAA,CAAAA,CAAA,UAAM,WAAW,CAAA,IAAA,CAAA,IAAA,EAAA,CAErB,EACFsL,CAAA,CAAA,CA9IoCF,GAAA,MAAM,CAAA,CAA7BvL,GAAA,WAAAyL,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,SAAAA,CCRb,IAAIO,EAAAA,CAAa,EAEbC,EACEC,CAAAA,EAAAA,CAAwC,EAO9C,CAAA,SAASC,GAAmBzJ,CAAc,CAAA,CACxC,OAAIA,CAAAA,IAAUwJ,IACZ,OAAOA,EAAAA,CAAcxJ,CAAM,CACpB,CAAA,IAAA,EAEF,KACT,CAKa1C,EAAAA,CAAA,SAAY,CAAA,CACvB,aAAA,SAAauD,CAAAA,CAAc,CACzB,IAAMb,EAASsJ,EACf,EAAA,CAAA,OAAAE,EAAcxJ,CAAAA,CAAM,EAAI,IACnBuJ,CAAAA,EAAAA,GACHA,GAAW,OAAQ,CAAA,OAAA,IAErBA,EAAS,CAAA,IAAA,CAAK,UAAA,CAAM,OAAAE,EAAmBzJ,CAAAA,CAAM,GAAKa,CAAE,EAAhC,CAAkC,CAC/Cb,CAAAA,CACT,CAEA,CAAA,cAAA,CAAA,SAAeA,CAAc,CAAA,CAC3ByJ,GAAmBzJ,CAAM,EAC3B,GAMW1C,EAAA,CAAA,SAAA,CAAY,CACvB,OAAA,CAAO,UAAA,CACL,OAAO,OAAO,IAAKkM,CAAAA,EAAa,EAAE,MACpC,CAAA,EAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,IAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,MAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,OAAA,MAAA,EAAA,UAAA,EAAA,CAAA,CAAA,MAAA,CAAA,QAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,GAAA,CAAA,KAAA,CAAA,CAAA,GAAA,KAAA,CAAA,EAAA,CAAA,EAAA,EAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,EAAA,IAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,KAAA,EAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,IAAA,GAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,MAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,aAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,MAAA,CAAA,cAAA,CAAA,CAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,iBAAA,CAAA,SAAA,CC3CF,IAAAE,EAAAA,CAAA,KAEQC,EAAiCD,CAAAA,EAAAA,CAAA,UAAS,YAA5BE,CAAAA,EAAAA,CAAmBF,GAAA,SAAS,CAAA,cAAA,CAgBrCpM,CAAA,CAAA,iBAAA,CAAuC,CAGlD,YAAY,CAAA,UAAA,SAACuC,CAAA,CAAA,GAAAC,CAAA,CAAA,CAAA,CAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,CAAA,CAAA,CAAA,SAAA,CAAAA,CAAA,CACH,CAAA,IAAAC,CAAazC,CAAAA,CAAAA,CAAA,kBAAiB,QACtC,CAAA,OAAA,CAAQyC,CAAU,EAAA,YAAA,EAAgB4J,IAAa,KAAA,CAAA,SAAA,CAAAvK,EAAA,CAAA,GAAAC,EAAIQ,CAAAA,CAAI,CAAA,CAAA,CACzD,EACA,cAAA,CAAA,SAAeG,CAAM,CAAA,CACX,IAAAD,CAAazC,CAAAA,CAAAA,CAAA,kBAAiB,QACtC,CAAA,OAAA,CAAQyC,GAAU,cAAkB6J,EAAAA,EAAAA,EAAgB5J,CAAa,CACnE,EACA,QAAU,CAAA,SAAA,EAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,SAAA,EAAA,UAAA,CAAA,IAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,MAAA,CAAA,cAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAA,WAAA,KAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,CAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,OAAA,CAAA,EAAA,UAAA,EAAA,CAAA,GAAA,IAAA,CAAA,MAAA,IAAA,SAAA,CAAA,sBAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,+BAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,IAAA,CAAA,WAAA,CAAA,EAAA,CAAA,CAAA,CAAA,SAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,SAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,UAAA,CAAA,SAAA,CC7BZ,IAAA6J,EAAA,CAAA,EAAA,EAAA,CAGAC,GAAA,EAGAC,EAAAA,CAAAA,EAAAA,CAAA,SAAAtM,CAAAA,CAAA,CAAmC8D,EAAAwI,CAAAA,CAAAA,CAAAtM,CAAA,CACjC,CAAA,SAAAsM,EAAsBtB,CAAoCC,CAAAA,CAAAA,CAAmD,CAA7G,IAAAjH,EACEhE,CAAA,CAAA,IAAA,CAAA,KAAMgL,CAAWC,CAAAA,CAAI,GAAC,IADF,CAAA,OAAAjH,CAAA,CAAA,SAAA,CAAAgH,EAAoChH,CAAA,CAAA,IAAA,CAAAiH,GAE1D,CAEU,OAAAqB,EAAA,SAAA,CAAA,cAAA,CAAV,SAAyBtB,CAAAA,CAA0BhC,EAAkBmC,CAAiB,CAAA,CAEpF,OAFmEA,CAAA,GAAA,SAAA,GAAAA,EAAA,CAE/DA,CAAAA,CAAAA,CAAAA,GAAU,IAAQA,EAAAA,CAAAA,CAAQ,EACrBnL,CAAA,CAAA,SAAA,CAAM,eAAc,IAAA,CAAA,IAAA,CAACgL,EAAWhC,CAAImC,CAAAA,CAAK,CAGlDH,EAAAA,CAAAA,CAAU,QAAQ,IAAK,CAAA,IAAI,EAIpBA,CAAU,CAAA,UAAA,GAAeA,EAAU,UAAaqB,CAAAA,EAAAA,CAAA,iBAAkB,CAAA,YAAA,CAAarB,EAAU,KAAM,CAAA,IAAA,CAAKA,EAAW,SAAS,CAAC,GAClI,CAEUsB,CAAAA,CAAAA,CAAA,SAAA,CAAA,cAAA,CAAV,SAAyBtB,CAA0BhC,CAAAA,CAAAA,CAAkBmC,EAAiB,CAIpF,IAAA,CAAA,CAAA,GAJmEA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,CAI/DA,CAAAA,CAAAA,CAAAA,EAAS,KAAOA,CAAQ,CAAA,CAAA,CAAI,KAAK,KAAQ,CAAA,CAAA,CAC3C,OAAOnL,CAAA,CAAA,SAAA,CAAM,cAAc,CAAA,IAAA,CAAA,KAACgL,CAAWhC,CAAAA,CAAAA,CAAImC,CAAK,CAK1C,CAAA,IAAAS,EAAYZ,CAAS,CAAA,OAAA,CACzBhC,CAAM,EAAA,IAAA,EAAA,CAAA,CAAQlH,EAAA8J,CAAQA,CAAAA,CAAAA,CAAQ,OAAS,CAAC,CAAA,IAAC,MAAA9J,CAAA,GAAA,SAAA,CAAA,SAAAA,CAAAA,CAAAA,CAAE,MAAOkH,CACpDqD,GAAAA,EAAAA,CAAA,kBAAkB,cAAerD,CAAAA,CAAE,EAC/BgC,CAAU,CAAA,UAAA,GAAehC,CAC3BgC,GAAAA,CAAAA,CAAU,WAAa,SAK7B,CAAA,EAAA,CAAA,CACFsB,CAAA,CAAA,CAtCmCF,GAAA,WAAW,CAAA,CAAjCvM,EAAA,CAAA,UAAA,CAAAyM,+FCHb,IAAArC,EAAAA,CAAA,KAqBAsC,EAAA,CAAA,UAAA,CAGE,SAAAA,CAAAA,CAAoBC,CAAoCtD,CAAAA,CAAAA,CAAiC,CAAjCA,CAAA,GAAA,SAAA,GAAAA,EAAoBqD,CAAU,CAAA,GAAA,CAAA,CAAlE,KAAA,mBAAAC,CAAAA,CAAAA,CAClB,IAAK,CAAA,GAAA,CAAMtD,EACb,CA6BO,OAAAqD,EAAA,SAAA,CAAA,QAAA,CAAP,SAAmBtB,CAAqDE,CAAAA,CAAAA,CAAmBD,CAAS,CAAA,CAA5B,OAAAC,CAAA,GAAA,SAAA,GAAAA,EAAA,CAC/D,CAAA,CAAA,IAAI,KAAK,mBAAuB,CAAA,IAAA,CAAMF,CAAI,CAAA,CAAE,SAASC,CAAOC,CAAAA,CAAK,CAC1E,CAnCcoB,CAAAA,CAAAA,CAAA,IAAoBtC,EAAA,CAAA,qBAAA,CAAsB,GAoC1DsC,CAAAA,CAAAA,CAAAA,GArCa1M,EAAA,CAAA,SAAA,CAAA0M,ylBCxBb,IAAAE,EAAAA,CAAA,KAKAC,EAAA,CAAA,SAAA1M,CAAA,CAAA,CAAoC8D,GAAA4I,CAAA1M,CAAAA,CAAA,EAkBlC,SAAA0M,CAAAA,CAAYC,EAAgCzD,CAAiC,CAAA,CAAjCA,CAAA,GAAA,SAAA,GAAAA,EAAoBuD,EAAA,CAAA,SAAA,CAAU,GAA1E,CAAA,CAAA,IAAAzI,EACEhE,CAAA,CAAA,IAAA,CAAA,IAAM2M,CAAAA,CAAAA,CAAiBzD,CAAG,CAAC,EAAA,IAAA,CAlBtB,OAAAlF,CAAA,CAAA,OAAA,CAAmC,EAOnCA,CAAAA,CAAAA,CAAA,OAAmB,CAAA,KAAA,CAAA,CAY1B,CAEO,OAAA0I,CAAAA,CAAA,UAAA,KAAP,CAAA,SAAaE,EAAwB,CAC3B,IAAAhB,CAAY,CAAA,IAAA,CAAI,QAExB,GAAI,IAAA,CAAK,QAAS,CAChBA,CAAAA,CAAQ,KAAKgB,CAAM,CAAA,CACnB,MAGF,CAAA,IAAI7J,EACJ,IAAK,CAAA,OAAA,CAAU,KAEf,GACE,GAAKA,EAAQ6J,CAAO,CAAA,OAAA,CAAQA,CAAO,CAAA,KAAA,CAAOA,EAAO,KAAK,CAAA,CACpD,YAEMA,CAAShB,CAAAA,CAAAA,CAAQ,OAI3B,EAAA,GAFA,IAAK,CAAA,OAAA,CAAU,MAEX7I,CAAO,CAAA,CACT,KAAQ6J,CAAShB,CAAAA,CAAAA,CAAQ,OACvBgB,EAAAA,CAAAA,CAAO,WAAW,EAAA,CAEpB,MAAM7J,CAEV,CAAA,CAAA,CACF2J,CAAA,CAhDoCD,CAAAA,EAAAA,CAAA,SAAS,CAAhC5M,CAAAA,EAAAA,CAAA,cAAA6M,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,CAAAA,SAAAA,EAAAA,UAAAA,CAAAA,IAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,MAAAA,CAAAA,cAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,WAAAA,KAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,IAAAA,CAAAA,IAAAA,CAAAA,CAAAA,MAAAA,CAAAA,SAAAA,CAAAA,cAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,OAAAA,CAAAA,EAAAA,UAAAA,EAAAA,CAAAA,GAAAA,IAAAA,CAAAA,MAAAA,IAAAA,SAAAA,CAAAA,sBAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,+BAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,IAAAA,CAAAA,WAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,GAAAA,IAAAA,CAAAA,MAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,aAAAA,CAAAA,SAAAA,CCJb,IAAAG,EAAA,CAAA,EAAA,EAAA,CAEAC,EAAA,CAAA,SAAA9M,EAAA,CAAmC8D,EAAAA,CAAAgJ,CAAA9M,CAAAA,CAAA,EAAnC,SAAA8M,CAAAA,EAAA,+CAkCA,CAjCS,OAAAA,EAAA,SAAA,CAAA,KAAA,CAAP,SAAaF,CAAAA,CAAyB,CACpC,IAAK,CAAA,OAAA,CAAU,KAUf,IAAMG,CAAAA,CAAU,KAAK,UACrB,CAAA,IAAA,CAAK,UAAa,CAAA,SAAA,CAEV,IAAAnB,CAAY,CAAA,IAAA,CAAI,QACpB7I,CACJ6J,CAAAA,CAAAA,CAASA,GAAUhB,CAAQ,CAAA,KAAA,EAE3B,CAAA,MACO7I,CAAQ6J,CAAAA,CAAAA,CAAO,QAAQA,CAAO,CAAA,KAAA,CAAOA,EAAO,KAAK,CAAA,CACpD,MAEMA,MAAAA,CAAAA,CAAAA,CAAShB,EAAQ,CAAC,CAAA,GAAMgB,EAAO,EAAOG,GAAAA,CAAAA,EAAWnB,EAAQ,KAAK,EAAA,EAIxE,GAFA,IAAA,CAAK,QAAU,KAEX7I,CAAAA,CAAAA,CAAO,CACT,KAAQ6J,CAAAA,CAAAA,CAAShB,EAAQ,CAAC,CAAA,GAAMgB,CAAO,CAAA,EAAA,GAAOG,GAAWnB,CAAQ,CAAA,KAAA,IAC/DgB,CAAO,CAAA,WAAA,GAET,MAAM7J,CAAAA,CAEV,CACF+J,CAAAA,CAAA,EAlCmCD,EAAA,CAAA,cAAc,EAApChN,EAAA,CAAA,aAAA,CAAAiN,2GCHb,IAAAE,EAAAA,CAAA,EACAC,EAAAA,CAAAA,EAAAA,CAAA,KAqCapN,EAAA,CAAA,aAAA,CAAgB,IAAIoN,EAAA,CAAA,aAAA,CAAcD,GAAA,UAAU,CAAA,CAK5CnN,EAAA,CAAA,IAAA,CAAOA,GAAA,cC3CpB,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,KAAA,CAAA,EAAA,CAAA,cAAA,CAAA,SAAA,CAAA,IAAAuM,GAAA,EACAS,EAAAA,CAAAA,EAAAA,CAAA,KAiDahN,EAAA,CAAA,cAAA,CAAiB,IAAIgN,EAAAA,CAAA,eAAeT,EAAA,CAAA,WAAW,EAK/CvM,EAAA,CAAA,KAAA,CAAQA,GAAA,eCvDrB,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,SAAA,EAAA,UAAA,CAAA,IAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,MAAA,CAAA,cAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAA,WAAA,KAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,CAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,OAAA,CAAA,EAAA,UAAA,EAAA,CAAA,GAAA,IAAA,CAAA,MAAA,IAAA,SAAA,CAAA,sBAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,+BAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,IAAA,CAAA,WAAA,CAAA,EAAA,CAAA,CAAA,CAAA,SAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,SAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,WAAA,CAAA,SAAA,CAAA,IAAAuM,EAAA,CAAA,EAAA,EAAA,CAMAc,GAAA,SAAAlN,CAAAA,CAAA,CAAoC8D,EAAAoJ,CAAAA,CAAAA,CAAAlN,CAAA,CAClC,CAAA,SAAAkN,CAAsBlC,CAAAA,CAAAA,CAAqCC,EAAmD,CAA9G,IAAAjH,EACEhE,CAAA,CAAA,IAAA,CAAA,KAAMgL,CAAWC,CAAAA,CAAI,CAAC,EAAA,IAAA,CADF,OAAAjH,CAAA,CAAA,SAAA,CAAAgH,EAAqChH,CAAA,CAAA,IAAA,CAAAiH,GAE3D,CAEO,OAAAiC,CAAA,CAAA,SAAA,CAAA,SAAP,SAAgBhC,CAAAA,CAAWC,EAAiB,CAC1C,OADyBA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,CACrBA,CAAAA,CAAAA,CAAAA,CAAQ,EACHnL,CAAA,CAAA,SAAA,CAAM,QAAQ,CAAA,IAAA,CAAA,KAACkL,CAAOC,CAAAA,CAAK,CAEpC,EAAA,IAAA,CAAK,MAAQA,CACb,CAAA,IAAA,CAAK,MAAQD,CACb,CAAA,IAAA,CAAK,UAAU,KAAM,CAAA,IAAI,CAClB,CAAA,IAAA,CACT,EAEOgC,CAAA,CAAA,SAAA,CAAA,QAAP,SAAehC,CAAAA,CAAUC,EAAa,CACpC,OAAOA,CAAQ,CAAA,CAAA,EAAK,KAAK,MAASnL,CAAAA,CAAAA,CAAA,UAAM,OAAO,CAAA,IAAA,CAAA,KAACkL,CAAOC,CAAAA,CAAK,CAAI,CAAA,IAAA,CAAK,SAASD,CAAOC,CAAAA,CAAK,CAC5F,CAEU+B,CAAAA,CAAAA,CAAA,UAAA,cAAV,CAAA,SAAyBlC,CAA2BhC,CAAAA,CAAAA,CAAkBmC,EAAiB,CAKrF,OALoEA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,GAK/DA,CAAS,EAAA,IAAA,EAAQA,CAAQ,CAAA,CAAA,EAAOA,GAAS,IAAQ,EAAA,IAAA,CAAK,MAAQ,CAC1DnL,CAAAA,CAAAA,CAAA,UAAM,cAAc,CAAA,IAAA,CAAA,IAACgL,CAAAA,CAAAA,CAAWhC,EAAImC,CAAK,CAAA,EAIlDH,EAAU,KAAM,CAAA,IAAI,EAMb,CACT,CAAA,CAAA,CACFkC,CAAA,CAAA,CArCoCd,GAAA,WAAW,CAAA,CAAlCvM,EAAA,CAAA,WAAA,CAAAqN,ylBCNb,IAAAL,EAAAA,CAAA,EAEAM,EAAAA,CAAAA,EAAAA,CAAA,SAAAnN,CAAA,CAAA,CAAoC8D,GAAAqJ,CAAAnN,CAAAA,CAAA,EAApC,SAAAmN,CAAAA,EAAA,CACA,OAAA,CAAA,GAAA,IAAA,EAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,SAAA,CAAA,EAAA,IAAA,CAAA,OAAAA,CAAA,CAAA,CADoCN,GAAA,cAAc,CAAA,CAArChN,GAAA,cAAAsN,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,KAAAA,CAAAA,EAAAA,CAAAA,cAAAA,CAAAA,SAAAA,CCFb,IAAAC,EAAAA,CAAA,KACAC,EAAA,CAAA,EAAA,EAAA,CAiEaxN,GAAA,cAAiB,CAAA,IAAIwN,GAAA,cAAeD,CAAAA,EAAAA,CAAA,WAAW,CAAA,CAK/CvN,GAAA,KAAQA,CAAAA,EAAAA,CAAA,2mBCvErB,IAAAuM,EAAAA,CAAA,KAGA3D,EAAA,CAAA,EAAA,EAAA,CAGA6E,EAAA,CAAA,SAAAtN,EAAA,CAA6C8D,EAAAA,CAAAwJ,EAAAtN,CAAA,CAAA,CAC3C,SAAAsN,CAAsBtC,CAAAA,CAAAA,CAA8CC,CAAmD,CAAA,CAAvH,IAAAjH,CACEhE,CAAAA,CAAAA,CAAA,KAAA,IAAMgL,CAAAA,CAAAA,CAAWC,CAAI,CAAC,EAAA,IAAA,CADF,OAAAjH,CAAAA,CAAA,UAAAgH,CAA8ChH,CAAAA,CAAAA,CAAA,KAAAiH,CAEpE,CAAA,CAAA,CAEU,OAAAqC,CAAA,CAAA,SAAA,CAAA,cAAV,CAAA,SAAyBtC,EAAoChC,CAAkBmC,CAAAA,CAAAA,CAAiB,CAE9F,OAF6EA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,CAEzEA,CAAAA,CAAAA,CAAAA,GAAU,MAAQA,CAAQ,CAAA,CAAA,CACrBnL,EAAA,SAAM,CAAA,cAAA,CAAc,KAAA,IAACgL,CAAAA,CAAAA,CAAWhC,CAAImC,CAAAA,CAAK,GAGlDH,CAAU,CAAA,OAAA,CAAQ,KAAK,IAAI,CAAA,CAIpBA,EAAU,UAAeA,GAAAA,CAAAA,CAAU,UAAavC,CAAAA,EAAAA,CAAA,uBAAuB,qBAAsB,CAAA,UAAA,CAAM,OAAAuC,CAAAA,CAAU,MAAM,SAAS,CAAzB,CAA0B,CAAA,CAAA,CACtI,EAEUsC,CAAA,CAAA,SAAA,CAAA,eAAV,SAAyBtC,CAAAA,CAAoChC,EAAkBmC,CAAiB,CAAA,CAAA,IAAA,CAAA,CAI9F,GAJ6EA,CAAAA,GAAA,YAAAA,CAAA,CAAA,CAAA,CAAA,CAIzEA,GAAS,IAAOA,CAAAA,CAAAA,CAAQ,EAAI,IAAK,CAAA,KAAA,CAAQ,CAC3C,CAAA,OAAOnL,EAAA,SAAM,CAAA,cAAA,CAAc,KAAA,IAACgL,CAAAA,CAAAA,CAAWhC,EAAImC,CAAK,CAAA,CAK1C,IAAAS,CAAAA,CAAYZ,EAAS,OACzBhC,CAAAA,CAAAA,EAAM,QAAQlH,CAAA8J,CAAAA,CAAAA,CAAQA,EAAQ,MAAS,CAAA,CAAC,CAAC,IAAA,IAAA,EAAA9J,IAAA,SAAA,CAAA,SAAA,CAAAA,EAAE,EAAOkH,IAAAA,CAAAA,GACpDP,GAAA,sBAAuB,CAAA,oBAAA,CAAqBO,CAAY,CAAA,CACxDgC,EAAU,UAAa,CAAA,SAAA,EAI3B,EACFsC,CAAA,CAAA,CApC6ClB,GAAA,WAAW,CAAA,CAA3CvM,EAAA,CAAA,oBAAA,CAAAyN,kmBCLb,IAAAT,EAAAA,CAAA,KAEAU,EAAA,CAAA,SAAAvN,EAAA,CAA6C8D,EAAAA,CAAAyJ,CAAAvN,CAAAA,CAAA,EAA7C,SAAAuN,CAAAA,EAAA,+CAkCA,CAjCS,OAAAA,EAAA,SAAA,CAAA,KAAA,CAAP,SAAaX,CAAAA,CAAyB,CACpC,IAAK,CAAA,OAAA,CAAU,KAUf,IAAMG,CAAAA,CAAU,KAAK,UACrB,CAAA,IAAA,CAAK,UAAa,CAAA,SAAA,CAEV,IAAAnB,CAAY,CAAA,IAAA,CAAI,QACpB7I,CACJ6J,CAAAA,CAAAA,CAASA,GAAUhB,CAAQ,CAAA,KAAA,EAE3B,CAAA,MACO7I,CAAQ6J,CAAAA,CAAAA,CAAO,QAAQA,CAAO,CAAA,KAAA,CAAOA,EAAO,KAAK,CAAA,CACpD,MAEMA,MAAAA,CAAAA,CAAAA,CAAShB,EAAQ,CAAC,CAAA,GAAMgB,EAAO,EAAOG,GAAAA,CAAAA,EAAWnB,EAAQ,KAAK,EAAA,EAIxE,GAFA,IAAA,CAAK,QAAU,KAEX7I,CAAAA,CAAAA,CAAO,CACT,KAAA,CAAQ6J,EAAShB,CAAQ,CAAA,CAAC,CAAMgB,GAAAA,CAAAA,CAAO,KAAOG,CAAWnB,EAAAA,CAAAA,CAAQ,OAC/DgB,EAAAA,CAAAA,CAAO,aAET,CAAA,MAAM7J,CAEV,CAAA,CAAA,CACFwK,CAAA,CAlC6CV,CAAAA,EAAAA,CAAA,cAAc,CAA9ChN,CAAAA,EAAAA,CAAA,wBAAA0N,GCHb,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,cAAA,CAAA,EAAA,CAAA,uBAAA,CAAA,SAAA,CAAA,IAAAC,EAAA,CAAA,EAAA,EAAA,CACAC,GAAA,EAkCa5N,EAAAA,CAAAA,EAAAA,CAAA,wBAA0B,IAAI4N,EAAAA,CAAA,wBAAwBD,EAAA,CAAA,oBAAoB,CAK1E3N,CAAAA,EAAAA,CAAA,eAAiBA,EAAA,CAAA,wBAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,SAAA,EAAA,UAAA,CAAA,IAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,MAAA,CAAA,cAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAA,WAAA,KAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,CAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,OAAA,CAAA,EAAA,UAAA,EAAA,CAAA,GAAA,IAAA,CAAA,MAAA,IAAA,SAAA,CAAA,sBAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,+BAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,SAAA,CAAA,EAAA,CAAA,IAAA,CAAA,WAAA,CAAA,EAAA,CAAA,CAAA,CAAA,SAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,SAAA,CAAA,CAAA,CAAA,SAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,aAAA,CAAA,EAAA,CAAA,oBAAA,CAAA,SAAA,CCxC9B,IAAAuM,EAAA,CAAA,EAAA,EAAA,CACA5I,GAAA,CACAqJ,EAAAA,CAAAA,EAAAA,CAAA,EAIAa,EAAAA,CAAAA,EAAAA,CAAA,SAAA1N,CAAA,CAAA,CAA0C8D,GAAA4J,CAAA1N,CAAAA,CAAA,EAyBxC,SAAA0N,CAAAA,CAAYlB,CAAuEmB,CAAAA,CAAAA,CAA4B,CAAnGnB,CAAA,GAAA,SAAA,GAAAA,EAA0CoB,EAA6BD,CAAAA,CAAAA,CAAAA,GAAA,YAAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAnF,IAAA3J,CAAAA,CACEhE,EAAA,IAAA,CAAA,IAAA,CAAMwM,EAAqB,UAAA,CAAM,OAAAxI,CAAK,CAAA,KAAL,CAAU,CAAA,EAAC,KADqC,OAAAA,CAAAA,CAAA,SAAA2J,CAAAA,CAAAA,CAf5E3J,EAAA,KAAgB,CAAA,CAAA,CAMhBA,CAAA,CAAA,KAAA,CAAgB,IAWvB,CAOO,OAAA0J,EAAA,SAAA,CAAA,KAAA,CAAP,UAAA,CAKE,IAAA,IAJM5L,CAAyB,CAAA,IAAA,CAAvB8J,EAAO9J,CAAA,CAAA,OAAA,CAAE6L,EAAS7L,CAAA,CAAA,SAAA,CACtBiB,EACA6J,CAEIA,CAAAA,CAAAA,CAAAA,CAAShB,CAAQ,CAAA,CAAC,IAAMgB,CAAO,CAAA,KAAA,EAASe,IAC9C/B,CAAQ,CAAA,KAAA,GACR,IAAK,CAAA,KAAA,CAAQgB,CAAO,CAAA,KAAA,CAEf,EAAA7J,CAAQ6J,CAAAA,CAAAA,CAAO,QAAQA,CAAO,CAAA,KAAA,CAAOA,EAAO,KAAK,CAAA,CAAA,CAAA,EAAtD,CAKF,GAAI7J,EAAO,CACT,KAAQ6J,EAAShB,CAAQ,CAAA,KAAA,IACvBgB,CAAO,CAAA,WAAA,EAET,CAAA,MAAM7J,EAEV,CApDO2K,CAAAA,CAAAA,CAAA,gBAAkB,EAqD3BA,CAAAA,CAAAA,CAAAA,CAvD0Cb,GAAA,cAAc,CAAA,CAA3ChN,EAAA,CAAA,oBAAA,CAAA6N,GAyDb,IAAAE,EAAAA,CAAA,SAAA5N,CAAA,CAAA,CAAsC8D,GAAA8J,CAAA5N,CAAAA,CAAA,CAGpC,CAAA,SAAA4N,EACY5C,CACAC,CAAAA,CAAAA,CACAxK,CAAsC,CAAA,CAAtCA,IAAA,SAAAA,GAAAA,CAAAA,CAAiBuK,CAAU,CAAA,KAAA,EAAS,GAHhD,IAAAhH,CAAAA,CAKEhE,EAAA,IAAA,CAAA,IAAA,CAAMgL,EAAWC,CAAI,CAAA,EAAC,IAJZ,CAAA,OAAAjH,EAAA,SAAAgH,CAAAA,CAAAA,CACAhH,EAAA,IAAAiH,CAAAA,CAAAA,CACAjH,EAAA,KAAAvD,CAAAA,CAAAA,CALFuD,CAAA,CAAA,MAAA,CAAkB,KAQ1BA,CAAK,CAAA,KAAA,CAAQgH,EAAU,KAAQvK,CAAAA,CAAAA,CAAAA,CACjC,CAEO,OAAAmN,CAAAA,CAAA,SAAA,CAAA,QAAA,CAAP,SAAgB1C,CAAWC,CAAAA,CAAAA,CAAiB,CAC1C,GADyBA,CAAAA,GAAA,YAAAA,CAAA,CAAA,CAAA,CAAA,CACrB,MAAO,CAAA,QAAA,CAASA,CAAK,CAAG,CAAA,CAC1B,GAAI,CAAC,IAAA,CAAK,GACR,OAAOnL,CAAAA,CAAA,SAAM,CAAA,QAAA,CAAQ,KAAA,IAACkL,CAAAA,CAAAA,CAAOC,CAAK,CAEpC,CAAA,IAAA,CAAK,OAAS,KAKd,CAAA,IAAMyB,CAAS,CAAA,IAAIgB,EAAc,IAAK,CAAA,SAAA,CAAW,KAAK,IAAI,CAAA,CAC1D,YAAK,GAAIhB,CAAAA,CAAM,CACRA,CAAAA,CAAAA,CAAO,SAAS1B,CAAOC,CAAAA,CAAK,OAI5B3H,OAAAA,EAAAA,CAAA,aAAa,KAExB,CAAA,CAEUoK,CAAA,CAAA,SAAA,CAAA,eAAV,SAAyB5C,CAAAA,CAAiChC,EAAUmC,CAAiB,CAAA,CAAjBA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,CAClE,CAAA,CAAA,IAAA,CAAK,MAAQH,CAAU,CAAA,KAAA,CAAQG,EACvB,IAAAS,CAAAA,CAAYZ,EAAS,OAC7B,CAAA,OAAAY,CAAQ,CAAA,IAAA,CAAK,IAAI,CAChBA,CAAAA,CAAAA,CAAoC,KAAKgC,CAAc,CAAA,WAAW,EAC5D,CACT,CAAA,CAEUA,CAAA,CAAA,SAAA,CAAA,eAAV,SAAyB5C,CAAAA,CAAiChC,EAAUmC,CAAiB,CAAA,CAErF,CAAA,CAEUyC,EAAA,SAAA,CAAA,QAAA,CAAV,SAAmB1C,CAAUC,CAAAA,CAAAA,CAAa,CACxC,GAAI,IAAA,CAAK,MAAW,GAAA,IAAA,CAClB,OAAOnL,CAAA,CAAA,SAAA,CAAM,SAAQ,IAAA,CAAA,IAAA,CAACkL,EAAOC,CAAK,CAEtC,CAEeyC,CAAAA,CAAAA,CAAA,YAAf,SAA8BC,CAAAA,CAAqBC,EAAmB,CACpE,OAAID,EAAE,KAAUC,GAAAA,CAAAA,CAAE,KACZD,CAAAA,CAAAA,CAAE,QAAUC,CAAE,CAAA,KAAA,CACT,CACED,CAAAA,CAAAA,CAAE,MAAQC,CAAE,CAAA,KAAA,CACd,CAEA,CAAA,EAAA,CAEAD,EAAE,KAAQC,CAAAA,CAAAA,CAAE,MACd,CAEA,CAAA,EAEX,EACFF,CAAA,CAAA,CAjEsCxB,EAAA,CAAA,WAAW,EAApCvM,EAAA,CAAA,aAAA,CAAA+N,mGC/Db,IAAA/F,EAAAA,CAAA,IAiEahI,EAAA,CAAA,KAAA,CAAQ,IAAIgI,EAAAA,CAAA,WAAkB,SAAC7C,CAAAA,CAAU,CAAK,OAAAA,CAAAA,CAAW,UAAX,CAAqB,CAOhF,CAAA,SAAgBhD,GAAMgJ,CAAyB,CAAA,CAC7C,OAAOA,CAAY+C,CAAAA,EAAAA,CAAe/C,CAAS,CAAInL,CAAAA,EAAAA,CAAA,KACjD,CAFAA,GAAA,KAAAmC,CAAAA,EAAAA,CAIA,SAAS+L,EAAe/C,CAAAA,CAAAA,CAAwB,CAC9C,OAAO,IAAInD,EAAA,CAAA,UAAA,CAAkB,SAAC7C,CAAU,CAAA,CAAK,OAAAgG,CAAU,CAAA,QAAA,CAAS,UAAA,CAAM,OAAAhG,CAAW,CAAA,QAAA,EAAX,CAAqB,CAA9C,CAA+C,CAC9F,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,WAAA,CAAA,SAAA,CC7EA,IAAAtE,EAAA,CAAA,CAAA,EAAA,CAEA,SAAgBsN,EAAAA,CAAYpO,EAAU,CACpC,OAAOA,GAASc,EAAA,CAAA,UAAA,CAAWd,EAAM,QAAQ,CAC3C,CAFAC,EAAAA,CAAA,YAAAmO,GCFA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAA,YAAA,CAAA,EAAA,CAAA,iBAAA,CAAA,SAAA,CAAA,IAAAtN,GAAA,CACAuN,EAAAA,CAAAA,EAAAA,CAAA,KAEA,SAAStD,EAAAA,CAAQpK,CAAQ,CAAA,CACvB,OAAOA,CAAIA,CAAAA,CAAAA,CAAI,OAAS,CAAC,CAC3B,CAEA,SAAgB2N,EAAAA,CAAkB9L,CAAW,CAAA,CAC3C,OAAO1B,EAAA,CAAA,UAAA,CAAWiK,GAAKvI,CAAI,CAAC,EAAIA,CAAK,CAAA,GAAA,EAAQ,CAAA,SAC/C,CAFAvC,EAAA,CAAA,iBAAA,CAAAqO,GAIA,SAAgBC,EAAAA,CAAa/L,EAAW,CACtC,OAAO6L,EAAA,CAAA,WAAA,CAAYtD,GAAKvI,CAAI,CAAC,EAAIA,CAAK,CAAA,GAAA,GAAQ,SAChD,CAFAvC,EAAA,CAAA,YAAA,CAAAsO,GAIA,SAAgBC,EAAAA,CAAUhM,EAAaiM,CAAoB,CAAA,CACzD,OAAO,OAAO1D,EAAAA,CAAKvI,CAAI,CAAA,EAAM,SAAWA,CAAK,CAAA,GAAA,GAASiM,CACxD,CAFAxO,GAAA,SAAAuO,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,WAAAA,CAAAA,SAAAA,CChBavO,EAAA,CAAA,WAAA,CAAe,SAAIsF,CAAM,CAAA,CAAwB,OAAAA,CAAAA,EAAK,OAAOA,CAAE,CAAA,MAAA,EAAW,QAAY,EAAA,OAAOA,GAAM,UAAlD,EAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAA,CAAA,SAAA,CCA9D,IAAAzE,EAAA,CAAA,CAAA,EAAA,CAMA,SAAgB4N,EAAU1O,CAAAA,CAAAA,CAAU,CAClC,OAAOc,GAAA,UAAWd,CAAAA,CAAAA,EAAO,IAAI,CAC/B,CAFAC,GAAA,SAAAyO,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,mBAAAA,CAAAA,SAAAA,CCLA,IAAA3I,EAAAA,CAAA,KACAjF,EAAA,CAAA,CAAA,EAAA,CAGA,SAAgB6N,EAAoB/I,CAAAA,CAAAA,CAAU,CAC5C,OAAO9E,EAAAA,CAAA,UAAW8E,CAAAA,CAAAA,CAAMG,GAAA,UAAiB,CAAC,CAC5C,CAFA9F,EAAAA,CAAA,oBAAA0O,GCLA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,eAAA,CAAA,SAAA,CAAA,IAAA7N,EAAA,CAAA,CAAA,EAAA,CAEA,SAAgB8N,EAAmBC,CAAAA,CAAAA,CAAQ,CACzC,OAAO,MAAA,CAAO,eAAiB/N,EAAA,CAAA,UAAA,CAAW+N,CAAM,GAAA,MAAA,CAAO,aAAa,CAAC,CACvE,CAFA5O,EAAA,CAAA,eAAA,CAAA2O,sHCEA,SAAgBE,EAAAA,CAAiClJ,CAAU,CAAA,CAEzD,OAAO,IAAI,SAAA,CACT,iBACEA,CAAU,GAAA,IAAA,EAAQ,OAAOA,CAAU,EAAA,QAAA,CAAW,mBAAsB,CAAA,GAAA,CAAIA,EAAK,GAAG,CAAA,CAAA,0HACwC,CAE9H,CAPA3F,EAAAA,CAAA,iCAAA6O,GCJA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,QAAA,CAAA,EAAA,CAAA,iBAAA,CAAA,SAAA,CAAA,SAAgBC,EAAiB,EAAA,CAC/B,OAAI,OAAO,MAAA,EAAW,YAAc,CAAC,MAAA,CAAO,SACnC,YAGF,CAAA,MAAA,CAAO,QAChB,CANA9O,GAAA,iBAAA8O,CAAAA,EAAAA,CAQa9O,GAAA,QAAW8O,CAAAA,EAAAA,gGCRxB,IAAAC,EAAAA,CAAA,EACAlO,EAAAA,CAAAA,EAAAA,CAAA,IAGA,SAAgBmO,EAAAA,CAAWrJ,EAAU,CACnC,OAAO9E,GAAA,UAAW8E,CAAAA,CAAAA,GAAQoJ,EAAA,CAAA,QAAe,CAAC,CAC5C,CAFA/O,GAAA,UAAAgP,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,WAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,MAAAA,EAAAA,UAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,UAAAA,CAAAA,OAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,SAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,IAAAA,SAAAA,CAAAA,iCAAAA,CAAAA,CAAAA,KAAAA,CAAAA,EAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,IAAAA,CAAAA,OAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,KAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,KAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,GAAAA,EAAAA,CAAAA,SAAAA,QAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,QAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,GAAAA,EAAAA,CAAAA,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,IAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,OAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,OAAAA,IAAAA,YAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,gBAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,MAAAA,CAAAA,aAAAA,CAAAA,MAAAA,IAAAA,SAAAA,CAAAA,sCAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,aAAAA,CAAAA,CAAAA,UAAAA,CAAAA,OAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,OAAAA,IAAAA,OAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,YAAAA,EAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,CAAAA,CAAAA,MAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,oBAAAA,CAAAA,CAAAA,CAAAA,kCAAAA,CAAAA,SAAAA,CCHA,IAAAnO,EAAA,CAAA,CAAA,EAAA,CAEA,SAAuBoO,EAAAA,CAAsCC,EAAqC,CAC1FC,OAAAA,EAAAA,CAAAA,IAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,EAAAA,CAAAA,IAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,KAAAA,EAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAASD,EAAe,SAAS,EAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAGX,OAAA,CAAA,CAAA,CAAAE,EAAMD,CAAAA,CAAAA,CAAO,MAAM,CAAA,gBAArClN,CAAkBwH,CAAAA,CAAAA,CAAA,MAAhB1J,CAAAA,CAAAA,CAAKkC,CAAA,CAAA,KAAA,CAAEoN,EAAIpN,CAAA,CAAA,IAAA,CACfoN,oBAAA,CAAA,CAAA,CAAA,CAAA,CACF,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA5F,EAAA,IAAA,EAAA,CAEI1J,CAAAA,KAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAM,CAAA,CAAZ,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA0J,EAAA,IAAA,EAAA,SAAA,OAAAA,CAAAA,CAAA,MAGF,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA0F,CAAO,CAAA,WAAA,+BAXXnP,CAAA,CAAA,kCAAA,CAAAiP,GAeA,SAAgBK,EAAAA,CAAwBV,EAAQ,CAG9C,OAAO/N,EAAA,CAAA,UAAA,CAAW+N,GAAK,SAAS,CAClC,CAJA5O,CAAA,CAAA,oBAAA,CAAAsP,s5EClBA,IAAAC,EAAAA,CAAA,EACAC,EAAAA,CAAAA,EAAAA,CAAA,KACAxH,EAAA,CAAA,CAAA,EAAA,CAEAyH,GAAA,EACAC,EAAAA,CAAAA,EAAAA,CAAA,KACAC,EAAA,CAAA,EAAA,EAAA,CACAC,EAAA,CAAA,EAAA,EAAA,CACAC,GAAA,EAEAhP,EAAAA,CAAAA,EAAAA,CAAA,IACA+C,EAAA,CAAA,EAAA,EAAA,CACAkC,GAAA,EAGA,EAAA,CAAA,SAAgBgK,EAAanK,CAAAA,CAAAA,CAAyB,CACpD,GAAIA,CAAAA,YAAiBqC,GAAA,UACnB,CAAA,OAAOrC,EAET,GAAIA,CAAAA,EAAS,IAAM,CAAA,CACjB,GAAI8J,EAAA,CAAA,mBAAA,CAAoB9J,CAAK,CAC3B,CAAA,OAAOoK,GAAsBpK,CAAK,CAAA,CAEpC,GAAI4J,EAAAA,CAAA,YAAY5J,CAAK,CAAA,CACnB,OAAOqK,EAAAA,CAAcrK,CAAK,CAE5B,CAAA,GAAI6J,EAAA,CAAA,SAAA,CAAU7J,CAAK,CACjB,CAAA,OAAOsK,GAAYtK,CAAK,CAAA,CAE1B,GAAI+J,EAAA,CAAA,eAAA,CAAgB/J,CAAK,CAAA,CACvB,OAAOuK,EAAkBvK,CAAAA,CAAK,EAEhC,GAAIiK,EAAAA,CAAA,WAAWjK,CAAK,CAAA,CAClB,OAAOwK,EAAAA,CAAaxK,CAAK,CAE3B,CAAA,GAAIkK,GAAA,oBAAqBlK,CAAAA,CAAK,EAC5B,OAAOyK,EAAAA,CAAuBzK,CAAK,CAAA,CAIvC,MAAMgK,EAAA,CAAA,gCAAA,CAAiChK,CAAK,CAC9C,CA1BA3F,EAAA,SAAA8P,CAAAA,EAAAA,CAgCA,SAAgBC,EAAAA,CAAyBnB,EAAQ,CAC/C,OAAO,IAAI5G,EAAA,CAAA,UAAA,CAAW,SAAC7C,CAAyB,CAAA,CAC9C,IAAMkL,CAAAA,CAAMzB,EAAI9I,EAAA,CAAA,UAAiB,GACjC,CAAA,GAAIjF,GAAA,UAAWwP,CAAAA,CAAAA,CAAI,SAAS,CAAA,CAC1B,OAAOA,CAAI,CAAA,SAAA,CAAUlL,CAAU,CAGjC,CAAA,MAAM,IAAI,SAAU,CAAA,gEAAgE,CACtF,CAAC,CACH,CATAnF,CAAAA,CAAA,qBAAA+P,CAAAA,EAAAA,CAkBA,SAAgBC,EAAiBM,CAAAA,CAAAA,CAAmB,CAClD,OAAO,IAAItI,EAAA,CAAA,UAAA,CAAW,SAAC7C,CAAyB,CAAA,CAU9C,QAASyF,CAAI,CAAA,CAAA,CAAGA,CAAI0F,CAAAA,CAAAA,CAAM,QAAU,CAACnL,CAAAA,CAAW,OAAQyF,CACtDzF,EAAAA,CAAAA,CAAAA,CAAW,KAAKmL,CAAM1F,CAAAA,CAAC,CAAC,CAAA,CAE1BzF,EAAW,QAAQ,GACrB,CAAC,CACH,CAhBAnF,EAAA,aAAAgQ,CAAAA,EAAAA,CAkBA,SAAgBC,EAAAA,CAAeM,EAAuB,CACpD,OAAO,IAAIvI,EAAA,CAAA,UAAA,CAAW,SAAC7C,CAAyB,CAAA,CAC9CoL,CACG,CAAA,IAAA,CACC,SAACxQ,CAAK,CAAA,CACCoF,EAAW,MACdA,GAAAA,CAAAA,CAAW,KAAKpF,CAAK,CAAA,CACrBoF,CAAW,CAAA,QAAA,IAEf,CACA,CAAA,SAAC3E,EAAQ,CAAK,OAAA2E,EAAW,KAAM3E,CAAAA,CAAG,CAApB,CAAqB,EAEpC,IAAK,CAAA,IAAA,CAAMoD,GAAA,oBAAoB,EACpC,CAAC,CACH,CAdA5D,CAAA,CAAA,WAAA,CAAAiQ,GAgBA,SAAgBE,EAAAA,CAAgBK,EAAqB,CACnD,OAAO,IAAIxI,EAAA,CAAA,UAAA,CAAW,SAAC7C,CAAAA,CAAyB,aAC9C,IAAoBsL,IAAAA,CAAAA,CAAArP,GAAAoP,CAAQ,CAAA,CAAAE,EAAAD,CAAA,CAAA,IAAA,EAAA,CAAA,CAAAC,EAAA,IAAAA,CAAAA,CAAAA,CAAAD,EAAA,IAAA,EAAA,CAAE,CAAzB,IAAM1Q,CAAAA,CAAK2Q,CAAA,CAAA,KAAA,CAEd,GADAvL,CAAW,CAAA,IAAA,CAAKpF,CAAK,CACjBoF,CAAAA,CAAAA,CAAW,OACb,MAGJA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,EAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAW,QAAQ,GACrB,CAAC,CACH,CAVAnF,EAAA,YAAAmQ,CAAAA,EAAAA,CAYA,SAAgBD,EAAqBS,CAAAA,CAAAA,CAA+B,CAClE,OAAO,IAAI3I,EAAA,CAAA,UAAA,CAAW,SAAC7C,CAAyB,CAAA,CAC9CyL,GAAQD,CAAexL,CAAAA,CAAU,CAAE,CAAA,KAAA,CAAM,SAAC3E,CAAG,CAAA,CAAK,OAAA2E,CAAW,CAAA,KAAA,CAAM3E,CAAG,CAApB,CAAqB,EACzE,CAAC,CACH,CAJAR,CAAAA,CAAA,kBAAAkQ,EAMA,CAAA,SAAgBE,GAA0BlB,CAAqC,CAAA,CAC7E,OAAOgB,EAAAA,CAAkBL,GAAA,kCAAmCX,CAAAA,CAAc,CAAC,CAC7E,CAFAlP,CAAA,CAAA,sBAAA,CAAAoQ,EAIA,CAAA,SAAeQ,GAAWD,CAAiCxL,CAAAA,CAAAA,CAAyB,6IACxD0L,CAAAC,CAAAA,EAAAA,CAAAH,CAAa,CAIrC,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAJe5Q,CAAKgR,CAAAA,CAAAA,CAAA,MACpB5L,CAAW,CAAA,IAAA,CAAKpF,CAAK,CAGjBoF,CAAAA,CAAAA,CAAW,OACb,OAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,IAAA,GAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,MAAA,CAAA,CAAA,KAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA,KAAA,EAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA,KAAA,EAAA,CAGJ,OAAAA,CAAW,CAAA,QAAA,6GChHb,SAAgB6L,EAAAA,CACdC,EACA9F,CACAC,CAAAA,CAAAA,CACAE,CACA4F,CAAAA,CAAAA,CAAc,CADd5F,CAAA,GAAA,SAAA,GAAAA,EAAA,CACA4F,CAAAA,CAAAA,CAAAA,GAAA,YAAAA,CAAA,CAAA,KAAA,CAAA,CAEA,IAAMC,CAAAA,CAAuBhG,EAAU,QAAS,CAAA,UAAA,CAC9CC,CAAI,EAAA,CACA8F,EACFD,CAAmB,CAAA,GAAA,CAAI,IAAK,CAAA,QAAA,CAAS,KAAM3F,CAAK,CAAC,EAEjD,IAAK,CAAA,WAAA,GAET,CAAGA,CAAAA,CAAK,CAIR,CAAA,GAFA2F,EAAmB,GAAIE,CAAAA,CAAoB,EAEvC,CAACD,CAAAA,CAKH,OAAOC,CAEX,CAzBAnR,EAAA,CAAA,eAAA,CAAAgR,+FChBA,IAAAI,EAAAA,CAAA,CACA3J,EAAAA,CAAAA,EAAAA,CAAA,IACAC,EAAA,CAAA,CAAA,EAAA,CAsDA,SAAgB2J,EAAAA,CAAalG,EAA0BG,CAAS,CAAA,CAAT,OAAAA,CAAA,GAAA,SAAA,GAAAA,EAAA,CAC9C7D,CAAAA,CAAAA,EAAAA,CAAA,OAAQ,CAAA,SAACpB,EAAQlB,CAAU,CAAA,CAChCkB,EAAO,SACLqB,CAAAA,EAAAA,CAAA,yBACEvC,CACA,CAAA,SAACpF,CAAK,CAAA,CAAK,OAAAqR,EAAA,CAAA,eAAA,CAAgBjM,EAAYgG,CAAW,CAAA,UAAA,CAAM,OAAAhG,CAAAA,CAAW,IAAKpF,CAAAA,CAAK,CAArB,CAAwBuL,CAAAA,CAAK,CAA1E,CACX,CAAA,UAAA,CAAM,OAAA8F,EAAAA,CAAA,eAAgBjM,CAAAA,CAAAA,CAAYgG,EAAW,UAAA,CAAM,OAAAhG,CAAW,CAAA,QAAA,EAAX,CAAuBmG,CAAAA,CAAK,CAAzE,CAAA,CACN,SAAC9K,CAAG,CAAA,CAAK,OAAA4Q,EAAA,CAAA,eAAA,CAAgBjM,EAAYgG,CAAW,CAAA,UAAA,CAAM,OAAAhG,EAAW,KAAM3E,CAAAA,CAAG,CAApB,CAAuB8K,CAAAA,CAAK,CAAzE,CAA0E,CACpF,EAEL,CAAC,CACH,CAXAtL,EAAAA,CAAA,SAAAqR,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,WAAAA,CAAAA,SAAAA,CCzDA,IAAA5J,EAAA,CAAA,CAAA,EAAA,CA6DA,SAAgB6J,EAAAA,CAAenG,EAA0BG,CAAiB,CAAA,CAAjB,OAAAA,CAAA,GAAA,SAAA,GAAAA,EAAA,CAChD7D,CAAAA,CAAAA,EAAAA,CAAA,OAAQ,CAAA,SAACpB,EAAQlB,CAAU,CAAA,CAChCA,EAAW,GAAIgG,CAAAA,CAAAA,CAAU,SAAS,UAAA,CAAM,OAAA9E,CAAAA,CAAO,UAAUlB,CAAU,CAA3B,EAA8BmG,CAAK,CAAC,EAC9E,CAAC,CACH,CAJAtL,EAAAA,CAAA,YAAAsR,GC9DA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,kBAAA,CAAA,SAAA,CAAA,IAAAC,GAAA,CACAC,EAAAA,CAAAA,EAAAA,CAAA,KACAC,EAAA,CAAA,EAAA,EAAA,CAGA,SAAgBC,EAAAA,CAAsB/L,EAA6BwF,CAAwB,CAAA,CACzF,OAAOoG,EAAA,CAAA,SAAA,CAAU5L,CAAK,CAAE,CAAA,IAAA,CAAK8L,EAAA,CAAA,WAAA,CAAYtG,CAAS,CAAGqG,CAAAA,EAAAA,CAAA,UAAUrG,CAAS,CAAC,CAC3E,CAFAnL,EAAAA,CAAA,kBAAA0R,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,eAAAA,CAAAA,SAAAA,CCLA,IAAAH,EAAA,CAAA,CAAA,EAAA,CACAC,GAAA,EACAC,EAAAA,CAAAA,EAAAA,CAAA,KAGA,SAAgBE,EAAAA,CAAmBhM,CAAuBwF,CAAAA,CAAAA,CAAwB,CAChF,OAAOoG,EAAAA,CAAA,UAAU5L,CAAK,CAAA,CAAE,KAAK8L,EAAA,CAAA,WAAA,CAAYtG,CAAS,CAAA,CAAGqG,GAAA,SAAUrG,CAAAA,CAAS,CAAC,CAC3E,CAFAnL,GAAA,eAAA2R,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,aAAAA,CAAAA,SAAAA,CCLA,IAAA3J,EAAAA,CAAA,IAGA,SAAgB4J,EAAAA,CAAiBjM,EAAqBwF,CAAwB,CAAA,CAC5E,OAAO,IAAInD,EAAAA,CAAA,UAAc,CAAA,SAAC7C,EAAU,CAElC,IAAIyF,EAAI,CAER,CAAA,OAAOO,EAAU,QAAS,CAAA,UAAA,CACpBP,CAAAA,GAAMjF,EAAM,MAGdR,CAAAA,CAAAA,CAAW,UAIXA,EAAAA,CAAAA,CAAW,KAAKQ,CAAMiF,CAAAA,CAAAA,EAAG,CAAC,CAAA,CAIrBzF,EAAW,MACd,EAAA,IAAA,CAAK,UAGX,EAAA,CAAC,CACH,CAAC,CACH,CAvBAnF,EAAAA,CAAA,cAAA4R,GCHA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,gBAAA,CAAA,SAAA,CAAA,IAAA5J,GAAA,CAEA+G,EAAAA,CAAAA,EAAAA,CAAA,KACAlO,EAAA,CAAA,CAAA,EAAA,CACAuQ,EAAA,CAAA,CAAA,EAAA,CAOA,SAAgBS,EAAoBlM,CAAAA,CAAAA,CAAoBwF,EAAwB,CAC9E,OAAO,IAAInD,EAAA,CAAA,UAAA,CAAc,SAAC7C,CAAAA,CAAU,CAClC,IAAI2M,CAAAA,CAKJ,OAAAV,EAAAA,CAAA,gBAAgBjM,CAAYgG,CAAAA,CAAAA,CAAW,UAAA,CAErC2G,EAAYnM,CAAcoJ,CAAAA,EAAAA,CAAA,QAAe,CAAC,EAAA,CAE1CqC,GAAA,eACEjM,CAAAA,CAAAA,CACAgG,CACA,CAAA,UAAA,OACMpL,CACAsP,CAAAA,CAAAA,CACJ,GAAI,CAEDpN,CAAAA,CAAkB6P,EAAS,IAAI,EAAA,CAA7B/R,CAAKkC,CAAAA,CAAAA,CAAA,MAAEoN,CAAIpN,CAAAA,CAAAA,CAAA,YACPzB,CAAK,CAAA,CAEZ2E,EAAW,KAAM3E,CAAAA,CAAG,CACpB,CAAA,MAAA,CAGE6O,EAKFlK,CAAW,CAAA,QAAA,GAGXA,CAAW,CAAA,IAAA,CAAKpF,CAAK,EAEzB,CAAA,CACA,CACA,CAAA,IAAI,EAER,CAAC,CAAA,CAMM,UAAA,CAAM,OAAAc,GAAA,UAAWiR,CAAAA,CAAAA,EAAU,MAAM,CAAA,EAAKA,EAAS,MAAM,EAA/C,CACf,CAAC,CACH,CAhDA9R,EAAA,CAAA,gBAAA,CAAA6R,GCVA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,IAAA7J,GAAA,CACAoJ,EAAAA,CAAAA,EAAAA,CAAA,IAEA,SAAgBW,EAAAA,CAAyBpM,EAAyBwF,CAAwB,CAAA,CACxF,GAAI,CAACxF,EACH,MAAM,IAAI,KAAM,CAAA,yBAAyB,EAE3C,OAAO,IAAIqC,EAAA,CAAA,UAAA,CAAc,SAAC7C,CAAU,CAAA,CAClCiM,GAAA,eAAgBjM,CAAAA,CAAAA,CAAYgG,EAAW,UAAA,CACrC,IAAM2G,CAAAA,CAAWnM,EAAM,MAAO,CAAA,aAAa,GAC3CyL,CAAAA,EAAAA,CAAA,gBACEjM,CACAgG,CAAAA,CAAAA,CACA,UAAA,CACE2G,EAAS,IAAI,EAAA,CAAG,KAAK,SAACE,CAAAA,CAAM,CACtBA,CAAO,CAAA,IAAA,CAGT7M,CAAW,CAAA,QAAA,GAEXA,CAAW,CAAA,IAAA,CAAK6M,EAAO,KAAK,EAEhC,CAAC,EACH,CAAA,CACA,CACA,CAAA,IAAI,EAER,CAAC,EACH,CAAC,CACH,CA1BAhS,GAAA,qBAAA+R,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,0BAAAA,CAAAA,SAAAA,CCFA,IAAAE,EAAAA,CAAA,KACApC,EAAA,CAAA,EAAA,EAAA,CAEA,SAAgBqC,EAA8BvM,CAAAA,CAAAA,CAA8BwF,EAAwB,CAClG,OAAO8G,EAAA,CAAA,qBAAA,CAAsBpC,GAAA,kCAAmClK,CAAAA,CAAK,EAAGwF,CAAS,CACnF,CAFAnL,EAAA,CAAA,0BAAA,CAAAkS,GCLA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAA,CAAA,SAAA,CAAA,IAAAC,GAAA,EACAC,EAAAA,CAAAA,EAAAA,CAAA,EACAC,EAAAA,CAAAA,EAAAA,CAAA,KACAC,EAAA,CAAA,EAAA,EAAA,CACAL,EAAA,CAAA,EAAA,EAAA,CACAxC,GAAA,EACAD,EAAAA,CAAAA,EAAAA,CAAA,KACAD,EAAA,CAAA,EAAA,EAAA,CACAK,GAAA,EAGAF,EAAAA,CAAAA,EAAAA,CAAA,EACAC,EAAAA,CAAAA,EAAAA,CAAA,KACAE,EAAA,CAAA,EAAA,EAAA,CACA0C,GAAA,EAaA,EAAA,CAAA,SAAgBC,GAAa7M,CAA2BwF,CAAAA,CAAAA,CAAwB,CAC9E,GAAIxF,GAAS,IAAM,CAAA,CACjB,GAAI8J,EAAA,CAAA,mBAAA,CAAoB9J,CAAK,CAC3B,CAAA,OAAOwM,EAAA,CAAA,kBAAA,CAAmBxM,EAAOwF,CAAS,CAAA,CAE5C,GAAIoE,EAAA,CAAA,WAAA,CAAY5J,CAAK,CACnB,CAAA,OAAO0M,EAAA,CAAA,aAAA,CAAc1M,EAAOwF,CAAS,CAAA,CAEvC,GAAIqE,EAAA,CAAA,SAAA,CAAU7J,CAAK,CACjB,CAAA,OAAOyM,EAAA,CAAA,eAAA,CAAgBzM,EAAOwF,CAAS,CAAA,CAEzC,GAAIuE,EAAA,CAAA,eAAA,CAAgB/J,CAAK,CACvB,CAAA,OAAOsM,EAAA,CAAA,qBAAA,CAAsBtM,EAAOwF,CAAS,CAAA,CAE/C,GAAIyE,EAAA,CAAA,UAAA,CAAWjK,CAAK,CAClB,CAAA,OAAO2M,EAAA,CAAA,gBAAA,CAAiB3M,EAAOwF,CAAS,CAAA,CAE1C,GAAI0E,EAAA,CAAA,oBAAA,CAAqBlK,CAAK,CAC5B,CAAA,OAAO4M,EAAA,CAAA,0BAAA,CAA2B5M,EAAOwF,CAAS,CAAA,CAGtD,MAAMwE,EAAA,CAAA,gCAAA,CAAiChK,CAAK,CAC9C,CAtBA3F,EAAA,CAAA,SAAA,CAAAwS,yFCzBA,IAAAC,EAAAA,CAAA,KACAlB,EAAA,CAAA,CAAA,EAAA,CAkGA,SAAgBmB,EAAQ/M,CAAAA,CAAAA,CAA2BwF,CAAyB,CAAA,CAC1E,OAAOA,CAAYsH,CAAAA,EAAAA,CAAA,UAAU9M,CAAOwF,CAAAA,CAAS,EAAIoG,EAAA,CAAA,SAAA,CAAU5L,CAAK,CAClE,CAFA3F,EAAA,CAAA,IAAA,CAAA0S,wFCnGA,IAAAC,EAAAA,CAAA,IACAC,EAAA,CAAA,CAAA,EAAA,CA4EA,SAAgBC,EAAAA,EAAE,SAAItQ,CAAA,CAAA,GAAAC,CAAA,CAAA,CAAA,CAAAA,EAAA,SAAA,CAAA,MAAA,CAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,CAAA,CAAA,CAAA,SAAA,CAAAA,CAAA,CACpB,CAAA,IAAM2I,EAAYwH,EAAA,CAAA,YAAA,CAAapQ,CAAI,CAAA,CACnC,OAAOqQ,EAAA,CAAA,IAAA,CAAKrQ,EAAa4I,CAAS,CACpC,CAHAnL,EAAA,CAAA,EAAA,CAAA6S,GC/EA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,UAAA,CAAA,SAAA,CAAA,IAAA7K,GAAA,CAGAnH,EAAAA,CAAAA,EAAAA,CAAA,CAqHA,EAAA,CAAA,SAAgBiS,GAAWC,CAA0B5H,CAAAA,CAAAA,CAAyB,CAC5E,IAAM6H,EAAenS,EAAA,CAAA,UAAA,CAAWkS,CAAmB,CAAIA,CAAAA,CAAAA,CAAsB,UAAA,CAAM,OAAAA,CAAA,CAAA,CAC7EhM,EAAO,SAAC5B,CAAAA,CAA6B,CAAK,OAAAA,CAAAA,CAAW,MAAM6N,CAAY,EAAE,CAA/B,CAAA,CAChD,OAAO,IAAIhL,EAAAA,CAAA,WAAWmD,CAAY,CAAA,SAAChG,EAAU,CAAK,OAAAgG,CAAU,CAAA,QAAA,CAASpE,EAAa,CAAG5B,CAAAA,CAAU,CAA7C,CAAiD4B,CAAAA,CAAI,CACzG,CAJA/G,EAAAA,CAAA,UAAA8S,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,CAAAA,YAAAA,CAAAA,CAAAA,CAAAA,gBAAAA,CAAAA,SAAAA,KCtHAG,EAAA,CAAA,CAAA,EAAA,CACAC,GAAA,EACAC,EAAAA,CAAAA,EAAAA,CAAA,KACAtS,EAAA,CAAA,CAAA,EAAA,CAOA,CAAA,SAAYuS,EAAgB,CAC1BA,CAAAA,CAAA,KAAA,GACAA,CAAAA,CAAAA,CAAA,MAAA,GACAA,CAAAA,CAAAA,CAAA,QAAA,CAAA,IACF,GAJYpT,CAAAA,CAAA,mBAAAA,CAAA,CAAA,gBAAA,CAAgB,EAAA,CAAA,CAAA,CAsB5B,IAAAqT,EAAAA,CAAA,UAAA,CA6BE,SAAAA,CAA4BjQ,CAAAA,CAAAA,CAAuCrD,EAA2BmD,CAAW,CAAA,CAA7E,IAAA,CAAA,IAAA,CAAAE,EAAuC,IAAA,CAAA,KAAA,CAAArD,EAA2B,IAAA,CAAA,KAAA,CAAAmD,EAC5F,IAAK,CAAA,QAAA,CAAWE,CAAS,GAAA,IAC3B,CAQA,OAAAiQ,CAAAA,CAAA,UAAA,OAAA,CAAA,SAAQ1J,EAA4B,CAClC,OAAO2J,EAAoB,CAAA,IAAA,CAAmC3J,CAAQ,CACxE,CAAA,CA4BA0J,EAAA,SAAA,CAAA,EAAA,CAAA,SAAGE,CAAiCC,CAAAA,CAAAA,CAAmCC,CAA4B,CAAA,CAC3F,IAAAxR,CAAyB,CAAA,IAAA,CAAvBmB,EAAInB,CAAA,CAAA,IAAA,CAAElC,EAAKkC,CAAA,CAAA,KAAA,CAAEiB,CAAKjB,CAAAA,CAAAA,CAAA,MAC1B,OAAOmB,CAAAA,GAAS,IAAMmQ,CAAcxT,GAAAA,CAAM,EAAIqD,CAAS,GAAA,GAAA,CAAMoQ,CAAetQ,GAAAA,CAAK,EAAIuQ,CAAe,IACtG,EAqCAJ,CAAA,CAAA,SAAA,CAAA,OAAA,SAAOK,CAAAA,CAA2DxQ,CAA4BmB,CAAAA,CAAAA,CAAqB,OACjH,OAAOxD,EAAAA,CAAA,YAAWoB,CAACyR,CAAAA,CAAAA,IAAsB,MAAAzR,CAAA,GAAA,SAAA,CAAA,SAAAA,CAAAA,CAAAA,CAAE,IAAI,CAC3C,CAAA,IAAA,CAAK,OAAQyR,CAAAA,CAAoC,EACjD,IAAK,CAAA,EAAA,CAAGA,CAAsCxQ,CAAAA,CAAAA,CAAcmB,CAAe,CACjF,CAAA,CASAgP,EAAA,SAAA,CAAA,YAAA,CAAA,UAAA,CACQ,IAAApR,CAAyB,CAAA,IAAA,CAAvBmB,EAAInB,CAAA,CAAA,IAAA,CAAElC,EAAKkC,CAAA,CAAA,KAAA,CAAEiB,EAAKjB,CAAA,CAAA,KAAA,CAEpB+P,CACJ5O,CAAAA,CAAAA,GAAS,IAEL8P,EAAA,CAAA,EAAA,CAAGnT,CAAM,CAEXqD,CAAAA,CAAAA,GAAS,IAEP+P,EAAA,CAAA,UAAA,CAAW,UAAA,CAAM,OAAAjQ,CAAA,CAAK,EAExBE,CAAS,GAAA,GAAA,CAEP6P,GAAA,KAEA,CAAA,CAAA,CACN,GAAI,CAACjB,EAIH,MAAM,IAAI,UAAU,+BAAgC5O,CAAAA,CAAM,EAE5D,OAAO4O,CACT,CAeOqB,CAAAA,CAAAA,CAAA,WAAP,SAAqBtT,CAAAA,CAAQ,CAC3B,OAAO,IAAIsT,EAAa,GAAKtT,CAAAA,CAAK,CACpC,CAAA,CAcOsT,EAAA,WAAP,CAAA,SAAmB7S,EAAS,CAC1B,OAAO,IAAI6S,CAAa,CAAA,GAAA,CAAK,SAAW7S,CAAAA,CAAG,CAC7C,CAWO6S,CAAAA,CAAAA,CAAA,eAAP,UAAA,CACE,OAAOA,CAAa,CAAA,oBACtB,CA5CeA,CAAAA,CAAAA,CAAA,qBAAuB,IAAIA,CAAAA,CAAa,GAAG,CA6C5DA,CAAAA,CAAAA,CAAAA,GAjMarT,CAAA,CAAA,YAAA,CAAAqT,EA0Mb,CAAA,SAAgBC,GAAuBpO,CAAyCyE,CAAAA,CAAAA,CAA4B,WACpGgK,CAAyBzO,CAAAA,CAAAA,CAAvB9B,EAAIuQ,CAAA,CAAA,IAAA,CAAE5T,CAAK4T,CAAAA,CAAAA,CAAA,MAAEzQ,CAAKyQ,CAAAA,CAAAA,CAAA,MAC1B,GAAI,OAAOvQ,GAAS,QAClB,CAAA,MAAM,IAAI,SAAA,CAAU,sCAAsC,CAE5DA,CAAAA,CAAAA,GAAS,KAAMnB,CAAA0H,CAAAA,CAAAA,CAAS,QAAI,IAAA1H,EAAAA,CAAAA,GAAA,SAAAA,EAAAA,CAAAA,CAAA,KAAb0H,CAAgB5J,CAAAA,CAAM,EAAIqD,CAAS,GAAA,GAAA,CAAA,CAAMqG,EAAAE,CAAS,CAAA,KAAA,IAAK,IAAAF,EAAAA,CAAAA,GAAA,WAAAA,CAAA,CAAA,IAAA,CAAdE,EAAiBzG,CAAK,CAAA,CAAA,CAAIwG,EAAAC,CAAS,CAAA,QAAA,IAAQ,IAAAD,EAAAA,CAAAA,GAAA,WAAAA,CAAA,CAAA,IAAA,CAAjBC,CAAQ,EAC5F,CANA3J,EAAA,mBAAAsT,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,SAAAA,CC3OA,IAAAtL,EAAAA,CAAA,IACAnH,EAAA,CAAA,CAAA,EAAA,CAMA,SAAgB+S,EAAAA,CAAahF,EAAQ,CAGnC,OAAO,CAAC,CAACA,IAAQA,CAAe5G,YAAAA,EAAAA,CAAA,YAAenH,EAAA,CAAA,UAAA,CAAW+N,EAAI,IAAI,CAAA,EAAK/N,EAAA,CAAA,UAAA,CAAW+N,EAAI,SAAS,CAAA,CACjG,CAJA5O,EAAA,CAAA,YAAA,CAAA4T,gGCRA,IAAAtT,EAAAA,CAAA,EAwBaN,EAAAA,CAAAA,EAAAA,CAAA,WAA6BM,EAAA,CAAA,gBAAA,CAAiB,SAACH,CAAM,CAAA,CAAK,OAAA,UAAuB,CAC5FA,CAAO,CAAA,IAAI,EACX,IAAK,CAAA,IAAA,CAAO,aACZ,IAAK,CAAA,OAAA,CAAU,0BACjB,CAJuE,CAItE,EC3BD,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,aAAA,CAAA,SAAA,CAAA,IAAA0T,GAAA,EAoDA,EAAA,CAAA,SAAgBC,GAAoBzN,CAAuB0N,CAAAA,CAAAA,CAA+B,CACxF,IAAMC,CAAAA,CAAY,OAAOD,CAAAA,EAAW,SACpC,OAAO,IAAI,QAAe,SAACtN,CAAAA,CAASC,EAAM,CACxC,IAAIsE,CAAY,CAAA,KAAA,CACZd,EACJ7D,CAAO,CAAA,SAAA,CAAU,CACf,IAAM,CAAA,SAACtG,EAAK,CACVmK,CAAAA,CAASnK,CACTiL,CAAAA,CAAAA,CAAY,KACd,CACA,CAAA,KAAA,CAAOtE,CACP,CAAA,QAAA,CAAU,UAAA,CACJsE,CAAAA,CACFvE,CAAQyD,CAAAA,CAAM,EACL8J,CACTvN,CAAAA,CAAAA,CAAQsN,EAAQ,YAAY,CAAA,CAE5BrN,EAAO,IAAImN,EAAAA,CAAA,UAAY,EAE3B,EACD,EACH,CAAC,CACH,CAtBA7T,EAAAA,CAAA,cAAA8T,GCpDA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,cAAA,CAAA,SAAA,CAAA,IAAAD,EAAA,CAAA,EAAA,EAAA,CACAhO,GAAA,EAqDA,EAAA,CAAA,SAAgBoO,GAAqB5N,CAAuB0N,CAAAA,CAAAA,CAAgC,CAC1F,IAAMC,CAAAA,CAAY,OAAOD,CAAAA,EAAW,SACpC,OAAO,IAAI,QAAe,SAACtN,CAAAA,CAASC,EAAM,CACxC,IAAMvB,CAAa,CAAA,IAAIU,GAAA,cAAkB,CAAA,CACvC,KAAM,SAAC9F,CAAAA,CAAK,CACV0G,CAAQ1G,CAAAA,CAAK,CACboF,CAAAA,CAAAA,CAAW,cACb,CAAA,CACA,MAAOuB,CACP,CAAA,QAAA,CAAU,UAAA,CACJsN,CAAAA,CACFvN,CAAQsN,CAAAA,CAAAA,CAAQ,YAAY,CAE5BrN,CAAAA,CAAAA,CAAO,IAAImN,EAAA,CAAA,UAAY,EAE3B,CACD,CAAA,CAAA,CACDxN,CAAO,CAAA,SAAA,CAAUlB,CAAU,EAC7B,CAAC,CACH,CAnBAnF,GAAA,cAAAiU,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,uBAAAA,CAAAA,SAAAA,CCvDA,IAAA3T,EAAAA,CAAA,KAsBaN,EAAA,CAAA,uBAAA,CAAuDM,GAAA,gBAClE,CAAA,SAACH,EAAM,CACL,OAAA,UAAoC,CAClCA,EAAO,IAAI,CAAA,CACX,KAAK,IAAO,CAAA,yBAAA,CACZ,KAAK,OAAU,CAAA,wBACjB,CAJA,CAIC,kGC5BL,IAAAG,EAAAA,CAAA,KAoBaN,EAAA,CAAA,aAAA,CAAmCM,GAAA,gBAC9C,CAAA,SAACH,CAAM,CAAA,CACL,OAAA,SAAsC+T,CAAAA,CAAe,CACnD/T,CAAO,CAAA,IAAI,EACX,IAAK,CAAA,IAAA,CAAO,eACZ,CAAA,IAAA,CAAK,QAAU+T,EACjB,CAJA,CAIC,EC1BL,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,aAAA,CAAA,SAAA,CAAA,IAAA5T,GAAA,EAoBaN,EAAAA,CAAAA,EAAAA,CAAA,aAAmCM,CAAAA,EAAAA,CAAA,iBAC9C,SAACH,CAAAA,CAAM,CACL,OAAA,SAAsC+T,EAAe,CACnD/T,CAAAA,CAAO,IAAI,CAAA,CACX,KAAK,IAAO,CAAA,eAAA,CACZ,KAAK,OAAU+T,CAAAA,EACjB,CAJA,CAIC,EAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,WAAA,CAAA,SAAA,CCnBL,SAAgBC,EAAAA,CAAYpU,EAAU,CACpC,OAAOA,aAAiB,IAAQ,EAAA,CAAC,MAAMA,CAAY,CACrD,CAFAC,EAAAA,CAAA,YAAAmU,GCPA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,EAAA,CAAA,YAAA,CAAA,SAAA,CAAA,IAAAC,GAAA,CAEAC,EAAAA,CAAAA,EAAAA,CAAA,KAEA5M,EAAA,CAAA,CAAA,EAAA,CAEA8J,EAAA,CAAA,CAAA,EAAA,CACAjR,GAAA,EACAoH,EAAAA,CAAAA,EAAAA,CAAA,IACA0J,EAAA,CAAA,CAAA,EAAA,CA8EapR,GAAA,YAAiCM,CAAAA,EAAAA,CAAA,gBAC5C,CAAA,SAACH,EAAM,CACL,OAAA,SAAqCmU,CAAoC,CAAA,CAApCA,IAAA,SAAAA,GAAAA,CAAAA,CAAA,IACnCnU,CAAAA,CAAAA,CAAAA,CAAO,IAAI,CACX,CAAA,IAAA,CAAK,QAAU,sBACf,CAAA,IAAA,CAAK,KAAO,cACZ,CAAA,IAAA,CAAK,IAAOmU,CAAAA,EACd,CALA,CAKC,CAAA,CA8ML,SAAgBhS,EACdyR,CAAAA,CAAAA,CACAQ,EAA4B,CAStB,IAAAtS,CAMDoS,CAAAA,EAAAA,CAAA,YAAYN,CAAM,CAAA,CAAI,CAAE,KAAOA,CAAAA,CAAM,EAAK,OAAOA,CAAAA,EAAW,QAAW,CAAA,CAAE,KAAMA,CAAM,CAAA,CAAKA,EAL7FS,CAAKvS,CAAAA,CAAAA,CAAA,MACLwS,CAAIxS,CAAAA,CAAAA,CAAA,IACJwH,CAAAA,CAAAA,CAAAxH,EAAA,IAAMyS,CAAAA,CAAAA,CAAKjL,CAAA,GAAA,SAAA,CAAGkL,GAAmBlL,CACjCC,CAAAA,CAAAA,CAAAzH,CAAA,CAAA,SAAA,CAAAkJ,EAASzB,CAAA,GAAA,SAAA,CAAG6K,GAAgBH,EAAA,CAAA,cAAA,CAAc1K,EAC1CiK,CAAA1R,CAAAA,CAAAA,CAAA,IAAA2S,CAAAA,CAAAA,CAAIjB,IAAA,SAAG,CAAA,IAAA,CAAKA,EAGd,GAAIa,CAAAA,EAAS,MAAQC,CAAQ,EAAA,IAAA,CAE3B,MAAM,IAAI,UAAU,sBAAsB,CAAA,CAG5C,OAAOhN,EAAA,CAAA,OAAA,CAAQ,SAACpB,CAAQlB,CAAAA,CAAAA,CAAU,CAMhC,IAAI0P,EAGAC,CAGAC,CAAAA,CAAAA,CAAsB,KAGtBC,CAAO,CAAA,CAAA,CACLC,EAAa,SAAC3J,CAAAA,CAAa,CAC/BwJ,CAAAA,CAAoB1D,GAAA,eAClBjM,CAAAA,CAAAA,CACAgG,EACA,UAAA,CACE,GAAI,CACF0J,CAAAA,CAA2B,WAAW,EAAA,CACtCtD,GAAA,SACEmD,CAAAA,CAAAA,CAAO,CACL,IAAIE,CAAAA,CAAAA,CACJ,UAASG,CACT,CAAA,IAAA,CAAIC,CACL,CAAA,CAAC,EACF,SAAU7P,CAAAA,CAAU,SACf3E,CAAK,CAAA,CACZ2E,EAAW,KAAM3E,CAAAA,CAAG,EAExB,CAAA,CAAA,CACA8K,CAAK,EAET,CAAA,CAEAuJ,CAA6BxO,CAAAA,CAAAA,CAAO,UAClCqB,EAAA,CAAA,wBAAA,CACEvC,CACA,CAAA,SAACpF,EAAQ,CAEP+U,CAAAA,EAAmB,aACnBE,CAAAA,CAAAA,EAAAA,CAEA7P,EAAW,IAAM4P,CAAAA,CAAAA,CAAYhV,CAAM,CAAA,CAEnC0U,EAAQ,CAAKQ,EAAAA,CAAAA,CAAWR,CAAK,EAC/B,CAAA,CACA,UACA,SACA,CAAA,UAAA,CACOK,CAAAA,EAAmB,QACtBA,CAAmB,EAAA,WAAA,GAIrBC,CAAY,CAAA,KACd,CAAC,CACF,CAAA,CASH,CAACC,CAAAA,EAAQC,EAAWT,CAAS,EAAA,IAAA,CAAQ,OAAOA,CAAU,EAAA,QAAA,CAAWA,EAAQ,CAACA,CAAAA,CAAQrJ,CAAW,CAAA,GAAA,GAASsJ,CAAK,EAC7G,CAAC,CACH,CA/FAzU,GAAA,OAAAsC,CAAAA,EAAAA,CAsGA,SAASqS,EAAAA,CAAoBL,EAAsB,CACjD,MAAM,IAAItU,EAAA,CAAA,YAAA,CAAasU,CAAI,CAC7B,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,GAAA,CAAA,SAAA,CCnZA,IAAA7M,EAAAA,CAAA,IACAC,EAAA,CAAA,CAAA,EAAA,CA6CA,SAAgBwN,EAAUC,CAAAA,CAAAA,CAAyCxQ,EAAa,CAC9E,OAAO8C,EAAA,CAAA,OAAA,CAAQ,SAACpB,CAAQlB,CAAAA,CAAAA,CAAU,CAEhC,IAAIvE,EAAQ,CAGZyF,CAAAA,CAAAA,CAAO,SACLqB,CAAAA,EAAAA,CAAA,yBAAyBvC,CAAY,CAAA,SAACpF,EAAQ,CAG5CoF,CAAAA,CAAW,KAAKgQ,CAAQ,CAAA,IAAA,CAAKxQ,CAAS5E,CAAAA,CAAAA,CAAOa,GAAO,CAAC,EACvD,CAAC,CAAC,EAEN,CAAC,CACH,CAdAZ,EAAA,CAAA,GAAA,CAAAkV,ggBC9CA,IAAAE,EAAAA,CAAA,KAEQC,EAAY,CAAA,KAAA,CAAK,QAEzB,SAASC,EAAAA,CAAkB5Q,CAA6BnC,CAAAA,CAAAA,CAAW,CAC/D,OAAO8S,EAAAA,CAAQ9S,CAAI,CAAImC,CAAAA,CAAAA,CAAE,MAAA,SAAA5C,CAAAA,EAAAA,CAAA,EAAA,CAAAC,GAAIQ,CAAI,CAAA,CAAA,CAAImC,CAAAA,CAAAA,CAAGnC,CAAI,CAChD,CAMA,SAAgBgT,EAAAA,CAAuB7Q,EAA2B,CAC9D,OAAO0Q,GAAA,GAAI,CAAA,SAAA7S,EAAI,CAAI,OAAA+S,EAAY5Q,CAAAA,CAAAA,CAAInC,CAAI,CAApB,CAAqB,CAC5C,CAFAvC,EAAAA,CAAA,iBAAAuV,GCZA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,MAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,OAAA,MAAA,EAAA,UAAA,EAAA,CAAA,CAAA,MAAA,CAAA,QAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,GAAA,CAAA,KAAA,CAAA,CAAA,GAAA,KAAA,CAAA,EAAA,CAAA,EAAA,EAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,EAAA,IAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,KAAA,EAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,IAAA,GAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,MAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,aAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,IAAAnH,EAAA,CAAA,EAAA,EAAA,CACApG,GAAA,CACAyJ,EAAAA,CAAAA,EAAAA,CAAA,KACA+D,EAAA,CAAA,EAAA,EAAA,CACAhE,GAAA,EACAiE,EAAAA,CAAAA,EAAAA,CAAA,EAEA,EAAA,CAAA,SAAgBC,GACdC,CACAC,CAAAA,CAAAA,CACAC,EACA1K,CAAyB,CAAA,CAEzB,GAAI0K,CACF,CAAA,GAAIzH,EAAA,CAAA,WAAA,CAAYyH,CAAc,CAC5B1K,CAAAA,CAAAA,CAAY0K,OAGL,OAAA,UAAA,SAAqBtT,CAAA,CAAA,EAAAC,CAAAA,CAAAA,CAAA,EAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,CAAA,CAAA,CAAA,SAAA,CAAAA,CAAA,CAAA,CAC1B,OAAQkT,EAAsBC,CAAAA,CAAAA,CAAaC,EAAczK,CAAS,CAAA,CAC/D,MAAM,IAAM5I,CAAAA,CAAI,CAChB,CAAA,IAAA,CAAKiT,GAAA,gBAAiBK,CAAAA,CAAqB,CAAC,CACjD,CAAA,CAMJ,OAAI1K,CACK,CAAA,UAAA,CAAqB5I,IAAAA,IAAAA,CAAAA,CAAA,EAAAC,CAAAA,CAAAA,CAAA,EAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,CAAA,CAAA,CAAA,UAAAA,CAAA,CAAA,CAC1B,OAAQkT,EAAsBC,CAAAA,CAAAA,CAAaC,CAAY,CACpD,CAAA,KAAA,CAAM,IAAMrT,CAAAA,CAAI,EAChB,IAAKkP,CAAAA,EAAAA,CAAA,WAAYtG,CAAAA,CAAU,EAAGqG,EAAA,CAAA,SAAA,CAAUrG,CAAU,CAAC,CACxD,CAGK,CAAA,UAAA,SAAAhH,CAAA,CAAA,IAAA,CAAqB5B,EAAA,EAAA,CAAAC,CAAA,CAAA,CAAA,CAAAA,EAAA,SAAA,CAAA,MAAA,CAAAA,IAAAD,CAAAC,CAAAA,CAAA,EAAA,SAAAA,CAAAA,CAAA,CAG1B,CAAA,IAAM4F,EAAU,IAAIqN,EAAAA,CAAA,aAGhBK,CAAgB,CAAA,IAAA,CACpB,OAAO,IAAI9N,EAAAA,CAAA,UAAW,CAAA,SAAC7C,EAAU,CAE/B,IAAM4Q,EAAO3N,CAAQ,CAAA,SAAA,CAAUjD,CAAU,CAEzC,CAAA,GAAI2Q,CAAe,CAAA,CACjBA,EAAgB,KAMhB,CAAA,IAAIE,EAAU,KAGVC,CAAAA,CAAAA,CAAa,MAKjBL,CAAa,CAAA,KAAA,CAEXzR,CAAIrC,CAAAA,EAAAA,CAAAA,GAAA,EAAA,CAAAC,GAGCQ,CAAI,CAAA,EAAA,CAEP,UAAA,CAAC2T,IAAAA,IAAAA,CAAAA,CAAA,EAAA1T,CAAAA,CAAAA,CAAA,EAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAA0T,EAAAA,CAAAA,CAAAA,CAAA1T,CAAA,CAAA,CAAA,UAAAA,CAAA,CAAA,CACC,GAAImT,CAAAA,CAAa,CAIf,IAAMnV,CAAAA,CAAM0V,CAAQ,CAAA,KAAA,GACpB,GAAI1V,CAAAA,EAAO,KAAM,CACf4H,CAAAA,CAAQ,MAAM5H,CAAG,CAAA,CAGjB,MAOJ4H,CAAAA,CAAAA,CAAAA,CAAQ,KAAK,CAAI8N,CAAAA,CAAAA,CAAQ,OAASA,CAAUA,CAAAA,CAAAA,CAAQ,CAAC,CAAC,CAAA,CAGtDD,CAAa,CAAA,IAAA,CAMTD,GACF5N,CAAQ,CAAA,QAAA,GAEZ,CAMA6N,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EACF7N,EAAQ,QAAQ,EAAA,CAKlB4N,CAAU,CAAA,KAAA,CAIZ,OAAOD,CACT,CAAC,CACH,CACF,CA9GA/V,GAAA,qBAAA0V,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,SAAAA,CCLA,IAAAS,EAAAA,CAAA,KAuIA,SAAgBC,EAAAA,CACdR,EACAC,CACA1K,CAAAA,CAAAA,CAAyB,CAEzB,OAAOgL,EAAAA,CAAA,qBAAsB,CAAA,KAAA,CAAOP,EAAcC,CAAgB1K,CAAAA,CAAS,CAC7E,CANAnL,EAAAA,CAAA,aAAAoW,GCvIA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,gBAAA,CAAA,SAAA,CAAA,IAAAD,EAAA,CAAA,EAAA,EAAA,CAsHA,SAAgBE,EACdT,CAAAA,CAAAA,CACAC,EACA1K,CAAyB,CAAA,CAEzB,OAAOgL,EAAA,CAAA,qBAAA,CAAsB,IAAMP,CAAAA,CAAAA,CAAcC,EAAgB1K,CAAS,CAC5E,CANAnL,EAAAA,CAAA,iBAAAqW,GCzHQ,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,IAAAhB,EAAY,CAAA,KAAA,CAAK,QACjBiB,EAA0D,CAAA,MAAA,CAAM,eAArCC,EAA+B,CAAA,MAAA,CAAM,UAAlBC,EAAY,CAAA,MAAA,CAAM,IAQxE,CAAA,SAAgBC,GAAqDlU,CAAuB,CAAA,CAC1F,GAAIA,CAAK,CAAA,MAAA,GAAW,EAAG,CACrB,IAAMmU,CAAQnU,CAAAA,CAAAA,CAAK,CAAC,CACpB,CAAA,GAAI8S,GAAQqB,CAAK,CAAA,CACf,OAAO,CAAE,IAAA,CAAMA,CAAO,CAAA,IAAA,CAAM,IAAI,CAElC,CAAA,GAAIC,GAAOD,CAAK,CAAA,CAAG,CACjB,IAAME,CAAAA,CAAOJ,EAAQE,CAAAA,CAAK,EAC1B,OAAO,CACL,KAAME,CAAK,CAAA,GAAA,CAAI,SAACC,CAAG,CAAA,CAAK,OAAAH,CAAAA,CAAMG,CAAG,CAAT,CAAU,EAClC,IAAID,CAAAA,CAAAA,CAAAA,CAAAA,CAKV,OAAO,CAAE,IAAA,CAAMrU,CAAa,CAAA,IAAA,CAAM,IAAI,CACxC,CAhBAvC,GAAA,oBAAAyW,CAAAA,EAAAA,CAkBA,SAASE,EAAO/H,CAAAA,CAAAA,CAAQ,CACtB,OAAOA,GAAO,OAAOA,CAAAA,EAAQ,UAAY0H,EAAe1H,CAAAA,CAAG,IAAM2H,EACnE,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,YAAA,CAAA,SAAA,CC7BA,SAAgBO,EAAAA,CAAaF,EAAgBG,CAAa,CAAA,CACxD,OAAOH,CAAK,CAAA,MAAA,CAAO,SAAC5E,CAAQ6E,CAAAA,CAAAA,CAAK,CAAC,CAAA,CAAK,OAAE7E,CAAO6E,CAAAA,CAAG,EAAIE,CAAO,CAAA,CAAC,EAAI/E,CAA5B,CAAA,CAAqC,EAAS,CACvF,CAFAhS,EAAAA,CAAA,aAAA8W,GCAA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,iBAAA,CAAA,EAAA,CAAA,aAAA,CAAA,SAAA,CAAA,IAAA9O,GAAA,CAEAgP,EAAAA,CAAAA,EAAAA,CAAA,EAEApE,EAAAA,CAAAA,EAAAA,CAAA,IACArN,EAAA,CAAA,CAAA,EAAA,CAEAiQ,GAAA,EACA7C,EAAAA,CAAAA,EAAAA,CAAA,IACAsE,EAAA,CAAA,EAAA,EAAA,CACAvP,EAAA,CAAA,CAAA,EAAA,CAEA0J,GAAA,CA4LA,EAAA,CAAA,SAAgB8F,IAAa,CAAoC3U,IAAAA,IAAAA,CAAAA,CAAA,EAAAC,CAAAA,CAAAA,CAAA,CAAAA,CAAAA,CAAAA,CAAA,UAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAD,EAAAC,CAAA,CAAA,CAAA,UAAAA,CAAA,CAAA,CAC/D,IAAM2I,CAAAA,CAAYwH,GAAA,YAAapQ,CAAAA,CAAI,EAC7BsT,CAAiBlD,CAAAA,EAAAA,CAAA,kBAAkBpQ,CAAI,CAAA,CAEvCN,CAA8B+U,CAAAA,EAAAA,CAAA,qBAAqBzU,CAAI,CAAA,CAA/C4U,CAAWlV,CAAAA,CAAAA,CAAA,KAAE2U,CAAI3U,CAAAA,CAAAA,CAAA,IAE/B,CAAA,GAAIkV,EAAY,MAAW,GAAA,CAAA,CAIzB,OAAOvE,EAAA,CAAA,IAAA,CAAK,EAAIzH,CAAAA,CAAgB,CAGlC,CAAA,IAAM6G,EAAS,IAAIhK,EAAAA,CAAA,WACjBoP,EACED,CAAAA,CAAAA,CACAhM,EACAyL,CAEI,CAAA,SAACG,CAAM,CAAA,CAAK,OAAAE,EAAA,CAAA,YAAA,CAAaL,EAAMG,CAAM,CAAzB,EAEZxR,EAAA,CAAA,QAAQ,CACb,CAAA,CAGH,OAAOsQ,CAAkB7D,CAAAA,CAAAA,CAAO,KAAKwD,EAAA,CAAA,gBAAA,CAAiBK,CAAc,CAAC,CAAA,CAAsB7D,CAC7F,CA1BAhS,GAAA,aAAAkX,CAAAA,EAAAA,CA4BA,SAAgBE,EACdD,CAAAA,CAAAA,CACAhM,EACAkM,CAAiD,CAAA,CAAjD,OAAAA,CAAAA,GAAA,YAAAA,CAAyC9R,CAAAA,EAAAA,CAAA,UAElC,SAACJ,CAAAA,CAA2B,CAGjCmS,EACEnM,CAAAA,CAAAA,CACA,UAAA,CAaE,QAZQoM,CAAWJ,CAAAA,CAAAA,CAAW,OAExBJ,CAAS,CAAA,IAAI,MAAMQ,CAAM,CAAA,CAG3BC,CAASD,CAAAA,CAAAA,CAITE,EAAuBF,CAGlB3M,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAC,CACR0M,EACEnM,CAAAA,CAAAA,CACA,UAAA,CACE,IAAM9E,CAASuM,CAAAA,EAAAA,CAAA,KAAKuE,CAAYvM,CAAAA,CAAC,EAAGO,CAAgB,CAAA,CAChDuM,EAAgB,KACpBrR,CAAAA,CAAAA,CAAO,SACLqB,CAAAA,EAAAA,CAAA,yBACEvC,CACA,CAAA,SAACpF,EAAK,CAEJgX,CAAAA,CAAOnM,CAAC,CAAI7K,CAAAA,CAAAA,CACP2X,CAEHA,GAAAA,CAAAA,CAAgB,KAChBD,CAEGA,EAAAA,CAAAA,CAAAA,CAAAA,EAGHtS,EAAW,IAAKkS,CAAAA,CAAAA,CAAeN,EAAO,KAAK,EAAE,CAAC,EAElD,EACA,UAAA,CACO,EAAES,CAGLrS,EAAAA,CAAAA,CAAW,WAEf,CAAC,CACF,EAEL,EACAA,CAAU,EAAA,CAAA,CAjCLyF,EAAI,CAAGA,CAAAA,CAAAA,CAAI2M,EAAQ3M,CAAnBA,EAAAA,CAAAA,CAAAA,CAAAA,CAAC,EAoCZ,CAAA,CACAzF,CAAU,EAEd,CACF,CA/DAnF,EAAA,CAAA,iBAAA,CAAAoX,GAqEA,SAASE,EAAAA,CAAcnM,CAAsCwM,CAAAA,CAAAA,CAAqBxN,EAA0B,CACtGgB,CAAAA,CACFiG,GAAA,eAAgBjH,CAAAA,CAAAA,CAAcgB,EAAWwM,CAAO,CAAA,CAEhDA,CAAO,GAEX,kGC9SA,IAAApG,EAAAA,CAAA,CAGAH,EAAAA,CAAAA,EAAAA,CAAA,IACA1J,EAAA,CAAA,CAAA,EAAA,CAeA,SAAgBkQ,EAAAA,CACdvR,EACAlB,CACAgQ,CAAAA,CAAAA,CACA0C,EACAC,CACAC,CAAAA,CAAAA,CACAC,EACAC,CAAgC,CAAA,CAGhC,IAAMC,CAAAA,CAAc,EAEhBV,CAAAA,CAAAA,CAAS,EAET5W,CAAQ,CAAA,CAAA,CAERuX,EAAa,KAKXC,CAAAA,CAAAA,CAAgB,UAAA,CAIhBD,GAAc,CAACD,CAAAA,CAAO,QAAU,CAACV,CAAAA,EACnCrS,EAAW,QAAQ,GAEvB,CAGMkT,CAAAA,CAAAA,CAAY,SAACtY,CAAQ,CAAA,CAAK,OAACyX,CAASK,CAAAA,CAAAA,CAAaS,EAAWvY,CAAK,CAAA,CAAImY,CAAO,CAAA,IAAA,CAAKnY,CAAK,CAA5D,CAAA,CAE1BuY,EAAa,SAACvY,CAAAA,CAAQ,CAI1BgY,CAAU5S,EAAAA,CAAAA,CAAW,IAAKpF,CAAAA,CAAY,EAItCyX,CAKA,EAAA,CAAA,IAAIe,EAAgB,KAGpBhH,CAAAA,EAAAA,CAAA,UAAU4D,CAAQpV,CAAAA,CAAAA,CAAOa,CAAO,EAAA,CAAC,EAAE,SACjC8G,CAAAA,EAAAA,CAAA,yBACEvC,CACA,CAAA,SAACqT,EAAU,CAGTV,CAAAA,GAAeU,CAAU,CAAA,CAErBT,EAGFM,CAAUG,CAAAA,CAAiB,EAG3BrT,CAAW,CAAA,IAAA,CAAKqT,CAAU,EAE9B,CAAA,CACA,UAAA,CAGED,EAAgB,KAClB,CAAA,CAEA,UACA,UAAA,CAIE,GAAIA,CAKF,CAAA,GAAI,CAIFf,CAAAA,EAAAA,CAKA,qBACE,IAAMiB,CAAAA,CAAgBP,EAAO,KAAK,EAAA,CAI9BF,EACF5G,EAAA,CAAA,eAAA,CAAgBjM,CAAY6S,CAAAA,CAAAA,CAAmB,UAAA,CAAM,OAAAM,EAAWG,CAAa,CAAxB,CAAyB,CAE9EH,CAAAA,CAAAA,CAAWG,CAAa,EAAA,CAAA,CARrBP,EAAO,MAAUV,EAAAA,CAAAA,CAASK,OAYjCO,CAAa,GAAA,CAAA,MACN5X,EAAK,CACZ2E,CAAAA,CAAW,KAAM3E,CAAAA,CAAG,GAG1B,CAAC,CACF,EAEL,CAGA,CAAA,OAAA6F,EAAO,SACLqB,CAAAA,EAAAA,CAAA,wBAAyBvC,CAAAA,CAAAA,CAAYkT,EAAW,UAAA,CAE9CF,EAAa,IACbC,CAAAA,CAAAA,GACF,CAAC,CAAC,CAKG,CAAA,UAAA,CACLH,CAAmB,KACrB,CACF,CAhIAjY,EAAAA,CAAA,eAAA4X,GCnBA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,QAAA,CAAA,SAAA,CAAA,IAAAxC,EAAA,CAAA,EAAA,EAAA,CACA7D,GAAA,CACA9J,EAAAA,CAAAA,EAAAA,CAAA,CACAiR,EAAAA,CAAAA,EAAAA,CAAA,KACA7X,EAAA,CAAA,CAAA,EAAA,CA6EA,SAAgB8X,EAAAA,CACdxD,EACAU,CACAgC,CAAAA,CAAAA,CAA6B,CAE7B,OAFAA,CAAAA,GAAA,YAAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAEIhX,EAAA,CAAA,UAAA,CAAWgV,CAAc,CAEpB8C,CAAAA,EAAAA,CAAS,SAAC3K,CAAG,CAAA,CAAA,CAAC,CAAK,OAAAoH,EAAAA,CAAA,GAAI,CAAA,SAACnH,EAAQ2K,CAAU,CAAA,CAAK,OAAA/C,CAAe7H,CAAAA,CAAAA,CAAGC,EAAG,CAAG2K,CAAAA,CAAE,CAA1B,CAA2B,EAAErH,EAAA,CAAA,SAAA,CAAU4D,EAAQnH,CAAG,CAAA,CAAC,CAAC,CAAC,CAAjF,CAAoF6J,CAAAA,CAAU,GAC/G,OAAOhC,CAAAA,EAAmB,WACnCgC,CAAahC,CAAAA,CAAAA,CAAAA,CAGRpO,GAAA,OAAQ,CAAA,SAACpB,CAAQlB,CAAAA,CAAAA,CAAU,CAAK,OAAAuT,EAAAA,CAAA,eAAerS,CAAQlB,CAAAA,CAAAA,CAAYgQ,EAAS0C,CAAU,CAAtD,CAAuD,CAAA,CAChG,CAbA7X,EAAA,CAAA,QAAA,CAAA2Y,8FClFA,IAAAE,EAAAA,CAAA,KACAtT,EAAA,CAAA,CAAA,EAAA,CA8DA,SAAgBuT,EAAAA,CAAyCjB,EAA6B,CAA7B,OAAAA,CAAA,GAAA,SAAA,GAAAA,EAAA,CAChDgB,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAA,QAAStT,CAAAA,EAAAA,CAAA,SAAUsS,CAAU,CACtC,CAFA7X,EAAA,CAAA,QAAA,CAAA8Y,+FC/DA,IAAAC,EAAAA,CAAA,EA2DA,EAAA,CAAA,SAAgBC,IAAS,CACvB,OAAOD,GAAA,QAAS,CAAA,CAAC,CACnB,CAFA/Y,EAAAA,CAAA,SAAAgZ,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,MAAAA,CAAAA,SAAAA,CCzDA,IAAAC,EAAA,CAAA,EAAA,EAAA,CACAtG,GAAA,CACAC,EAAAA,CAAAA,EAAAA,CAAA,IA4GA,SAAgBsG,EAAAA,EAAM,CAAC3W,IAAAA,IAAAA,CAAAA,CAAA,EAAAC,CAAAA,CAAAA,CAAA,EAAAA,CAAA,CAAA,SAAA,CAAA,OAAAA,CAAAD,EAAAA,CAAAA,CAAAA,CAAAC,CAAA,CAAA,CAAA,UAAAA,CAAA,CAAA,CACrB,OAAOyW,EAAA,CAAA,SAAA,GAAYrG,EAAA,CAAA,IAAA,CAAKrQ,CAAMoQ,CAAAA,EAAAA,CAAA,aAAapQ,CAAI,CAAC,CAAC,CACnD,CAFAvC,GAAA,MAAAkZ,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,EAAAA,CAAAA,YAAAA,CAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,KAAAA,CAAAA,SAAAA,CChHA,IAAAlR,EAAAA,CAAA,IAEAuJ,EAAA,CAAA,CAAA,EAAA,CAkDA,SAAgB4H,EAAsCC,CAAAA,CAAAA,CAA0B,CAC9E,OAAO,IAAIpR,EAAA,CAAA,UAAA,CAA+B,SAAC7C,CAAU,CAAA,CACnDoM,EAAA,CAAA,SAAA,CAAU6H,GAAmB,CAAA,CAAE,SAAUjU,CAAAA,CAAU,EACrD,CAAC,CACH,CAJAnF,EAAA,CAAA,KAAA,CAAAmZ,iGCnDA,IAAAnP,EAAAA,CAAA,CAEAhC,EAAAA,CAAAA,EAAAA,CAAA,IACAqR,EAAA,CAAA,EAAA,EAAA,CAsBMC,GAA6C,CACjD,SAAA,CAAW,UAAA,CAAM,OAAA,IAAItP,EAAAA,CAAA,OAAJ,CACjB,CAAA,iBAAA,CAAmB,MAWrB,SAAgBuP,EAAAA,CAAelT,EAA4B0N,CAA6C,CAAA,CAA7CA,CAAA,GAAA,SAAA,GAAAA,EAAAuF,EAEzD,CAAA,CAAA,IAAI1R,EAAkC,IAC9B4R,CAAAA,CAAAA,CAAwCzF,EAAM,SAAnC9R,CAAAA,CAAAA,CAA6B8R,CAAM,CAAA,iBAAA,CAAnC0F,EAAiBxX,CAAA,GAAA,SAAA,CAAG,KAAIA,CACvCmG,CAAAA,CAAAA,CAAUoR,GAERxH,CAAAA,CAAAA,CAAc,IAAIhK,EAAAA,CAAA,WAAc,SAAC7C,CAAAA,CAAU,CAC/C,OAAOiD,CAAAA,CAAQ,UAAUjD,CAAU,CACrC,CAAC,CAAA,CAKD,OAAA6M,CAAO,CAAA,OAAA,CAAU,UAAA,CACf,OAAA,CAAI,CAACpK,CAAcA,EAAAA,CAAAA,CAAW,MAC5BA,IAAAA,CAAAA,CAAayR,GAAA,KAAM,CAAA,UAAA,CAAM,OAAAhT,CAAA,CAAM,CAAE,CAAA,SAAA,CAAU+B,CAAO,CAAA,CAC9CqR,GACF7R,CAAW,CAAA,GAAA,CAAI,UAAA,CAAM,OAACQ,EAAUoR,CAAS,EAApB,CAAuB,CAAA,CAAA,CAGzC5R,CACT,CAEOoK,CAAAA,CACT,CAxBAhS,EAAA,CAAA,WAAA,CAAAuZ,8FCvCA,IAAAvR,EAAAA,CAAA,CAEAgP,EAAAA,CAAAA,EAAAA,CAAA,KACAzF,EAAA,CAAA,CAAA,EAAA,CACAoB,GAAA,CACAjL,EAAAA,CAAAA,EAAAA,CAAA,IACA8N,EAAA,CAAA,EAAA,EAAA,CACAyB,EAAA,CAAA,EAAA,EAAA,CA2IA,SAAgByC,EAAQ,EAAA,CAAA,IAAA,IAACnX,EAAA,EAAA,CAAAC,EAAA,CAAAA,CAAAA,CAAAA,CAAA,SAAA,CAAA,MAAA,CAAAA,IAAAD,CAAAC,CAAAA,CAAA,EAAA,SAAAA,CAAAA,CAAA,EACvB,IAAMqT,CAAAA,CAAiBlD,EAAA,CAAA,iBAAA,CAAkBpQ,CAAI,CACvCN,CAAAA,CAAAA,CAA0B+U,GAAA,oBAAqBzU,CAAAA,CAAI,EAA3CoX,CAAO1X,CAAAA,CAAAA,CAAA,IAAE2U,CAAAA,CAAAA,CAAI3U,EAAA,IACrB+P,CAAAA,CAAAA,CAAS,IAAIhK,EAAA,CAAA,UAAA,CAAW,SAAC7C,CAAU,CAAA,CAC/B,IAAAoS,CAAAA,CAAWoC,EAAO,MAC1B,CAAA,GAAI,CAACpC,CAAAA,CAAQ,CACXpS,CAAW,CAAA,QAAA,EACX,CAAA,MAAA,CAKF,QAHM4R,CAAS,CAAA,IAAI,MAAMQ,CAAM,CAAA,CAC3BqC,EAAuBrC,CACvBsC,CAAAA,CAAAA,CAAqBtC,CAChBuC,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAW,CAClB,IAAIC,CAAAA,CAAW,MACfxI,EAAA,CAAA,SAAA,CAAUoI,EAAQG,CAAW,CAAC,CAAE,CAAA,SAAA,CAC9BpS,GAAA,wBACEvC,CAAAA,CAAAA,CACA,SAACpF,CAAK,CAAA,CACCga,IACHA,CAAW,CAAA,IAAA,CACXF,CAEF9C,EAAAA,CAAAA,CAAAA,CAAAA,CAAO+C,CAAW,CAAI/Z,CAAAA,EACxB,EACA,UAAA,CAAM,OAAA6Z,CAAA,EAAA,CAAA,CACN,SACA,CAAA,UAAA,EACM,CAACA,CAAAA,EAAwB,CAACG,CACvBF,IAAAA,CAAAA,EACH1U,EAAW,IAAKyR,CAAAA,CAAAA,CAAOK,EAAA,CAAA,YAAA,CAAaL,EAAMG,CAAM,CAAA,CAAIA,CAAM,CAE5D5R,CAAAA,CAAAA,CAAW,UAEf,EAAA,CAAC,CACF,EAAA,CAAA,CAtBI2U,EAAc,CAAGA,CAAAA,CAAAA,CAAcvC,EAAQuC,CAAvCA,EAAAA,CAAAA,CAAAA,CAAAA,CAAW,EAyBtB,CAAC,CAAA,CACD,OAAOjE,CAAAA,CAAiB7D,EAAO,IAAKwD,CAAAA,EAAAA,CAAA,gBAAiBK,CAAAA,CAAc,CAAC,CAAI7D,CAAAA,CAC1E,CAvCAhS,EAAAA,CAAA,SAAA0Z,GClJA,CAAA,CAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,IAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,MAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,OAAA,MAAA,EAAA,UAAA,EAAA,CAAA,CAAA,MAAA,CAAA,QAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,GAAA,CAAA,KAAA,CAAA,CAAA,GAAA,KAAA,CAAA,EAAA,CAAA,EAAA,EAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,EAAA,IAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,KAAA,EAAA,CAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,IAAA,GAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,EAAA,CAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,MAAA,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,MAAA,CAAA,cAAA,CAAA,EAAA,CAAA,YAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAA,CAAA,SAAA,CAAA,IAAAnI,GAAA,CACAvJ,EAAAA,CAAAA,EAAAA,CAAA,IACA6Q,EAAA,CAAA,EAAA,EAAA,CACAtJ,EAAA,CAAA,EAAA,EAAA,CACA1O,GAAA,CACA2U,EAAAA,CAAAA,EAAAA,CAAA,KAGMwE,EAA0B,CAAA,CAAC,cAAe,gBAAgB,CAAA,CAC1DC,EAAqB,CAAA,CAAC,mBAAoB,qBAAqB,CAAA,CAC/DC,GAAgB,CAAC,IAAA,CAAM,KAAK,CAkOlC,CAAA,SAAgBC,EACdC,CAAAA,CAAAA,CACAC,EACAC,CACAzE,CAAAA,CAAAA,CAAsC,CAMtC,GAJIhV,EAAAA,CAAA,WAAWyZ,CAAO,CAAA,GACpBzE,CAAiByE,CAAAA,CAAAA,CACjBA,EAAU,SAERzE,CAAAA,CAAAA,CAAAA,CACF,OAAOsE,EAAaC,CAAAA,CAAAA,CAAQC,EAAWC,CAA+B,CAAA,CAAE,IAAK9E,CAAAA,EAAAA,CAAA,iBAAiBK,CAAc,CAAC,EAUzG,IAAA5T,CAAAA,CAAAF,GAEJwY,EAAcH,CAAAA,CAAM,CAChBH,CAAAA,EAAAA,CAAmB,IAAI,SAACO,CAAAA,CAAU,CAAK,OAAA,SAACnY,EAAY,CAAK,OAAA+X,CAAOI,CAAAA,CAAU,EAAEH,CAAWhY,CAAAA,CAAAA,CAASiY,CAA+B,CAAtE,CAAlB,CAAyF,CAAA,CAElIG,EAAwBL,CAAAA,CAAM,EAC5BJ,EAAwB,CAAA,GAAA,CAAIU,GAAwBN,CAAQC,CAAAA,CAAS,CAAC,CACtEM,CAAAA,EAAAA,CAA0BP,CAAM,CAAA,CAChCF,GAAc,GAAIQ,CAAAA,EAAAA,CAAwBN,EAAQC,CAAS,CAAC,EAC5D,EAAA,CAAE,CAAA,CAAA,CATDO,EAAG3Y,CAAA,CAAA,CAAA,EAAE4Y,CAAM5Y,CAAAA,CAAAA,CAAA,CAAA,CAgBlB,CAAA,GAAI,CAAC2Y,CAAAA,EACCrL,GAAA,WAAY6K,CAAAA,CAAM,EACpB,OAAOvB,EAAAA,CAAA,SAAS,SAACiC,CAAAA,CAAc,CAAK,OAAAX,GAAUW,CAAWT,CAAAA,CAAAA,CAAWC,CAA+B,CAA/D,CAAgE,EAClG/I,EAAA,CAAA,SAAA,CAAU6I,CAAM,CAAC,EAOvB,GAAI,CAACQ,EACH,MAAM,IAAI,UAAU,sBAAsB,CAAA,CAG5C,OAAO,IAAI5S,GAAA,UAAc,CAAA,SAAC7C,EAAU,CAIlC,IAAM9C,EAAU,UAAA,CAAA,IAAA,IAACE,CAAA,CAAA,GAAAC,CAAA,CAAA,CAAA,CAAAA,EAAA,SAAA,CAAA,MAAA,CAAAA,IAAAD,CAAAC,CAAAA,CAAA,CAAA,CAAA,SAAA,CAAAA,CAAA,CAAmB,CAAA,OAAA2C,EAAW,IAAK,CAAA,CAAA,CAAI5C,EAAK,MAASA,CAAAA,CAAAA,CAAOA,CAAK,CAAA,CAAC,CAAC,CAAhD,CAAA,CAEpC,OAAAqY,CAAIvY,CAAAA,CAAO,EAEJ,UAAA,CAAM,OAAAwY,CAAAA,CAAQxY,CAAO,CAAf,CACf,CAAC,CACH,CA7DArC,GAAA,SAAAma,CAAAA,EAAAA,CAsEA,SAASO,EAAAA,CAAwBN,EAAaC,CAAiB,CAAA,CAC7D,OAAO,SAACG,CAAAA,CAAkB,CAAK,OAAA,SAACnY,CAAY,CAAA,CAAK,OAAA+X,CAAOI,CAAAA,CAAU,EAAEH,CAAWhY,CAAAA,CAAO,CAArC,CAAlB,CACjC,CAOA,SAASoY,GAAwBL,CAAW,CAAA,CAC1C,OAAOvZ,EAAA,CAAA,UAAA,CAAWuZ,EAAO,WAAW,CAAA,EAAKvZ,EAAA,CAAA,UAAA,CAAWuZ,EAAO,cAAc,CAC3E,CAOA,SAASO,EAAAA,CAA0BP,EAAW,CAC5C,OAAOvZ,EAAA,CAAA,UAAA,CAAWuZ,EAAO,EAAE,CAAA,EAAKvZ,EAAA,CAAA,UAAA,CAAWuZ,EAAO,GAAG,CACvD,CAOA,SAASG,GAAcH,CAAW,CAAA,CAChC,OAAOvZ,EAAA,CAAA,UAAA,CAAWuZ,EAAO,gBAAgB,CAAA,EAAKvZ,EAAA,CAAA,UAAA,CAAWuZ,EAAO,mBAAmB,CACrF,oGC/UA,IAAApS,EAAAA,CAAA,IACAnH,EAAA,CAAA,CAAA,EAAA,CAEA2U,EAAA,CAAA,EAAA,EAAA,CAyIA,SAAgBuF,EACdC,CAAAA,CAAAA,CACAC,EACApF,CAAsC,CAAA,CAEtC,OAAIA,CACKkF,CAAAA,EAAAA,CAAoBC,CAAYC,CAAAA,CAAa,EAAE,IAAKzF,CAAAA,EAAAA,CAAA,iBAAiBK,CAAc,CAAC,EAGtF,IAAI7N,EAAAA,CAAA,UAAoB,CAAA,SAAC7C,EAAU,CACxC,IAAM9C,EAAU,UAAA,CAAA,IAAA,IAACb,EAAA,EAAA,CAAAgB,CAAA,CAAA,CAAA,CAAAA,EAAA,SAAA,CAAA,MAAA,CAAAA,IAAAhB,CAAAgB,CAAAA,CAAA,EAAA,SAAAA,CAAAA,CAAA,CAAc,CAAA,OAAA2C,EAAW,IAAK3D,CAAAA,CAAAA,CAAE,SAAW,CAAIA,CAAAA,CAAAA,CAAE,CAAC,CAAIA,CAAAA,CAAC,CAAzC,CAAA,CACzB0Z,EAAWF,CAAW3Y,CAAAA,CAAO,CACnC,CAAA,OAAOxB,GAAA,UAAWoa,CAAAA,CAAa,CAAI,CAAA,UAAA,CAAM,OAAAA,CAAAA,CAAc5Y,EAAS6Y,CAAQ,CAA/B,EAAmC,SAC9E,CAAC,CACH,CAdAlb,GAAA,gBAAA+a,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,CAAAA,WAAAA,EAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,MAAAA,EAAAA,UAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,UAAAA,CAAAA,OAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,SAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,IAAAA,SAAAA,CAAAA,iCAAAA,CAAAA,CAAAA,KAAAA,CAAAA,EAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,IAAAA,CAAAA,OAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,KAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,KAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,GAAAA,EAAAA,CAAAA,SAAAA,QAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,QAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,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","file":"index.js","sourcesContent":["/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n","/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n","import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n","/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n","import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n","import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n","import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n","import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n","import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n","import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n","import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param bufferSize The size of the buffer to replay on subscription\n   * @param windowTime The amount of time the buffered items will stay buffered\n   * @param timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n","let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n","import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');","import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n","import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n","import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n","/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n","import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n","import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n","import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n","/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n","import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n","import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n","import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param {ObservableInput<T>} A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param {SchedulerLike} An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return {Observable<T>}\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n","import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n","import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n","/** prettier */\nimport { Observable } from '../Observable';\nimport { isFunction } from './isFunction';\n\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\nexport function isObservable(obj: any): obj is Observable<unknown> {\n  // The !! is to ensure that this publicly exposed function returns\n  // `false` if something like `null` or `0` is passed.\n  return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass((_super) => function EmptyErrorImpl(this: any) {\n  _super(this);\n  this.name = 'EmptyError';\n  this.message = 'no elements in sequence';\n});\n","import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\n\nexport interface LastValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * waiting for it to complete, and resolving the returned promise with the\n * last value from the observed stream.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will complete. If the source\n * observable does not complete, you will end up with a promise that is hung up, and\n * potentially all of the state of an async function hanging out in memory. To avoid\n * this situation, look into adding something like {@link timeout}, {@link take},\n * {@link takeWhile}, or {@link takeUntil} amongst others.\n *\n * ## Example\n *\n * Wait for the last value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, take, lastValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000).pipe(take(10));\n *   const finalNumber = await lastValueFrom(source$);\n *   console.log(`The final number is ${ finalNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The final number is 9'\n * ```\n *\n * @see {@link firstValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    let _hasValue = false;\n    let _value: T;\n    source.subscribe({\n      next: (value) => {\n        _value = value;\n        _hasValue = true;\n      },\n      error: reject,\n      complete: () => {\n        if (_hasValue) {\n          resolve(_value);\n        } else if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n  });\n}\n","import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\n\nexport interface FirstValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * and returning a promise that will resolve as soon as the first value\n * arrives from the observable. The subscription will then be closed.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\n * *OR* complete. If the source observable does not emit one value or complete, you will\n * end up with a promise that is hung up, and potentially all of the state of an\n * async function hanging out in memory. To avoid this situation, look into adding\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\n * amongst others.\n *\n * ## Example\n *\n * Wait for the first value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, firstValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000);\n *   const firstNumber = await firstValueFrom(source$);\n *   console.log(`The first number is ${ firstNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The first number is 0'\n * ```\n *\n * @see {@link lastValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    const subscriber = new SafeSubscriber<T>({\n      next: (value) => {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: () => {\n        if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n    source.subscribe(subscriber);\n  });\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n *\n * @class NotFoundError\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n *\n * @class SequenceError\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n","/**\n * Checks to see if a value is not only a `Date` object,\n * but a *valid* `Date` object that can be converted to a\n * number. For example, `new Date('blah')` is indeed an\n * `instanceof Date`, however it cannot be converted to a\n * number.\n */\nexport function isValidDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(value as any);\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n","import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}","import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { Observable } from '../Observable';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { observeOn } from '../operators/observeOn';\nimport { AsyncSubject } from '../AsyncSubject';\n\nexport function bindCallbackInternals(\n  isNodeStyle: boolean,\n  callbackFunc: any,\n  resultSelector?: any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<unknown> {\n  if (resultSelector) {\n    if (isScheduler(resultSelector)) {\n      scheduler = resultSelector;\n    } else {\n      // The user provided a result selector.\n      return function (this: any, ...args: any[]) {\n        return (bindCallbackInternals(isNodeStyle, callbackFunc, scheduler) as any)\n          .apply(this, args)\n          .pipe(mapOneOrManyArgs(resultSelector as any));\n      };\n    }\n  }\n\n  // If a scheduler was passed, use our `subscribeOn` and `observeOn` operators\n  // to compose that behavior for the user.\n  if (scheduler) {\n    return function (this: any, ...args: any[]) {\n      return (bindCallbackInternals(isNodeStyle, callbackFunc) as any)\n        .apply(this, args)\n        .pipe(subscribeOn(scheduler!), observeOn(scheduler!));\n    };\n  }\n\n  return function (this: any, ...args: any[]): Observable<any> {\n    // We're using AsyncSubject, because it emits when it completes,\n    // and it will play the value to all late-arriving subscribers.\n    const subject = new AsyncSubject<any>();\n\n    // If this is true, then we haven't called our function yet.\n    let uninitialized = true;\n    return new Observable((subscriber) => {\n      // Add our subscriber to the subject.\n      const subs = subject.subscribe(subscriber);\n\n      if (uninitialized) {\n        uninitialized = false;\n        // We're going to execute the bound function\n        // This bit is to signal that we are hitting the callback asynchronously.\n        // Because we don't have any anti-\"Zalgo\" guarantees with whatever\n        // function we are handed, we use this bit to figure out whether or not\n        // we are getting hit in a callback synchronously during our call.\n        let isAsync = false;\n\n        // This is used to signal that the callback completed synchronously.\n        let isComplete = false;\n\n        // Call our function that has a callback. If at any time during this\n        // call, an error is thrown, it will be caught by the Observable\n        // subscription process and sent to the consumer.\n        callbackFunc.apply(\n          // Pass the appropriate `this` context.\n          this,\n          [\n            // Pass the arguments.\n            ...args,\n            // And our callback handler.\n            (...results: any[]) => {\n              if (isNodeStyle) {\n                // If this is a node callback, shift the first value off of the\n                // results and check it, as it is the error argument. By shifting,\n                // we leave only the argument(s) we want to pass to the consumer.\n                const err = results.shift();\n                if (err != null) {\n                  subject.error(err);\n                  // If we've errored, we can stop processing this function\n                  // as there's nothing else to do. Just return to escape.\n                  return;\n                }\n              }\n              // If we have one argument, notify the consumer\n              // of it as a single value, otherwise, if there's more than one, pass\n              // them as an array. Note that if there are no arguments, `undefined`\n              // will be emitted.\n              subject.next(1 < results.length ? results : results[0]);\n              // Flip this flag, so we know we can complete it in the synchronous\n              // case below.\n              isComplete = true;\n              // If we're not asynchronous, we need to defer the `complete` call\n              // until after the call to the function is over. This is because an\n              // error could be thrown in the function after it calls our callback,\n              // and if that is the case, if we complete here, we are unable to notify\n              // the consumer than an error occurred.\n              if (isAsync) {\n                subject.complete();\n              }\n            },\n          ]\n        );\n        // If we flipped `isComplete` during the call, we resolved synchronously,\n        // notify complete, because we skipped it in the callback to wait\n        // to make sure there were no errors during the call.\n        if (isComplete) {\n          subject.complete();\n        }\n\n        // We're no longer synchronous. If the callback is called at this point\n        // we can notify complete on the spot.\n        isAsync = true;\n      }\n\n      // Return the subscription from adding our subscriber to the subject.\n      return subs;\n    });\n  };\n}\n","/* @prettier */\nimport { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { bindCallbackInternals } from './bindCallbackInternals';\n\nexport function bindCallback(\n  callbackFunc: (...args: any[]) => void,\n  resultSelector: (...args: any[]) => any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any>;\n\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\nexport function bindCallback<A extends readonly unknown[], R extends readonly unknown[]>(\n  callbackFunc: (...args: [...A, (...res: R) => void]) => void,\n  schedulerLike?: SchedulerLike\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\n\n/**\n * Converts a callback API to a function that returns an Observable.\n *\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n * it will return a function `g` that when called as `g(x)` will output an\n * Observable.</span>\n *\n * `bindCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters. The\n * last parameter must be a callback function that `func` calls when it is\n * done.\n *\n * The output of `bindCallback` is a function that takes the same parameters\n * as `func`, except the last one (the callback). When the output function\n * is called with arguments it will return an Observable. If function `func`\n * calls its callback with one argument, the Observable will emit that value.\n * If on the other hand the callback is called with multiple values the resulting\n * Observable will emit an array with said values as arguments.\n *\n * It is **very important** to remember that input function `func` is not called\n * when the output function is, but rather when the Observable returned by the output\n * function is subscribed. This means if `func` makes an AJAX request, that request\n * will be made every time someone subscribes to the resulting Observable, but not before.\n *\n * The last optional parameter - `scheduler` - can be used to control when the call\n * to `func` happens after someone subscribes to Observable, as well as when results\n * passed to callback will be emitted. By default, the subscription to an Observable calls `func`\n * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler\n * and call `subscribe` on the output Observable, all function calls that are currently executing\n * will end before `func` is invoked.\n *\n * By default, results passed to the callback are emitted immediately after `func` invokes the callback.\n * In particular, if the callback is called synchronously, then the subscription of the resulting Observable\n * will call the `next` function synchronously as well.  If you want to defer that call,\n * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n *\n * Note that the Observable created by the output function will always emit a single value\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n * calls will not appear in the stream. If you need to listen for multiple calls,\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n *\n * If `func` depends on some context (`this` property) and is not already bound, the context of `func`\n * will be the context that the output function has at call time. In particular, if `func`\n * is called as a method of some object and if `func` is not already bound, in order to preserve the context\n * it is recommended that the context of the output function is set to that object as well.\n *\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n * provides convenient error handling and probably is a better choice.\n * `bindCallback` will treat such functions the same as any other and error parameters\n * (whether passed or not) will always be interpreted as regular callback argument.\n *\n * ## Examples\n *\n * ### Convert jQuery's getJSON to an Observable API\n * ```ts\n * import { bindCallback } from 'rxjs';\n * import * as jQuery from 'jquery';\n *\n * // Suppose we have jQuery.getJSON('/my/url', callback)\n * const getJSONAsObservable = bindCallback(jQuery.getJSON);\n * const result = getJSONAsObservable('/my/url');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * ### Receive an array of arguments passed to a callback\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const someFunction = (n, s, cb) => {\n *   cb(n, s, { someProperty: 'someValue' });\n * };\n *\n * const boundSomeFunction = bindCallback(someFunction);\n * boundSomeFunction(5, 'some string').subscribe((values) => {\n *   console.log(values); // [5, 'some string', {someProperty: 'someValue'}]\n * });\n * ```\n *\n * ### Compare behaviour with and without async Scheduler\n * ```ts\n * import { bindCallback, asyncScheduler } from 'rxjs';\n *\n * function iCallMyCallbackSynchronously(cb) {\n *   cb();\n * }\n *\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);\n *\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\n * console.log('This happened...');\n *\n * // Logs:\n * // I was sync!\n * // This happened...\n * // I was async!\n * ```\n *\n * ### Use bindCallback on an object method\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const boundMethod = bindCallback(someObject.methodWithCallback);\n * boundMethod\n *   .call(someObject) // make sure methodWithCallback has access to someObject\n *   .subscribe(subscriber);\n * ```\n *\n * @see {@link bindNodeCallback}\n * @see {@link from}\n *\n * @param {function} func A function with a callback as the last parameter.\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\n * callbacks.\n * @return {function(...params: *): Observable} A function which returns the\n * Observable that delivers the same values the callback would deliver.\n */\nexport function bindCallback(\n  callbackFunc: (...args: [...any[], (...res: any) => void]) => void,\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<unknown> {\n  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\n}\n","/* @prettier */\nimport { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { bindCallbackInternals } from './bindCallbackInternals';\n\nexport function bindNodeCallback(\n  callbackFunc: (...args: any[]) => void,\n  resultSelector: (...args: any[]) => any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any>;\n\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\nexport function bindNodeCallback<A extends readonly unknown[], R extends readonly unknown[]>(\n  callbackFunc: (...args: [...A, (err: any, ...res: R) => void]) => void,\n  schedulerLike?: SchedulerLike\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\n\n/**\n * Converts a Node.js-style callback API to a function that returns an\n * Observable.\n *\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\n * callback is expected to be of type `callback(error, result)`.</span>\n *\n * `bindNodeCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters, but the\n * last parameter must be a callback function that `func` calls when it is\n * done. The callback function is expected to follow Node.js conventions,\n * where the first argument to the callback is an error object, signaling\n * whether call was successful. If that object is passed to callback, it means\n * something went wrong.\n *\n * The output of `bindNodeCallback` is a function that takes the same\n * parameters as `func`, except the last one (the callback). When the output\n * function is called with arguments, it will return an Observable.\n * If `func` calls its callback with error parameter present, Observable will\n * error with that value as well. If error parameter is not passed, Observable will emit\n * second parameter. If there are more parameters (third and so on),\n * Observable will emit an array with all arguments, except first error argument.\n *\n * Note that `func` will not be called at the same time output function is,\n * but rather whenever resulting Observable is subscribed. By default call to\n * `func` will happen synchronously after subscription, but that can be changed\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\n * can also control when values from callback will be emitted by Observable.\n * To find out more, check out documentation for {@link bindCallback}, where\n * {@link SchedulerLike} works exactly the same.\n *\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n * of returned function, when it is called.\n *\n * After Observable emits value, it will complete immediately. This means\n * even if `func` calls callback again, values from second and consecutive\n * calls will never appear on the stream. If you need to handle functions\n * that call callbacks multiple times, check out {@link fromEvent} or\n * {@link fromEventPattern} instead.\n *\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n * \"Node.js-style\" callbacks are just a convention, so if you write for\n * browsers or any other environment and API you use implements that callback style,\n * `bindNodeCallback` can be safely used on that API functions as well.\n *\n * Remember that Error object passed to callback does not have to be an instance\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n * Error parameter of callback function is interpreted as \"present\", when value\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n * string or boolean `true`. In all of these cases resulting Observable would error\n * with that value. This means usually regular style callbacks will fail very often when\n * `bindNodeCallback` is used. If your Observable errors much more often then you\n * would expect, check if callback really is called in Node.js-style and, if not,\n * switch to {@link bindCallback} instead.\n *\n * Note that even if error parameter is technically present in callback, but its value\n * is falsy, it still won't appear in array emitted by Observable.\n *\n * ## Examples\n * ###  Read a file from the filesystem and get the data as an Observable\n * ```ts\n * import * as fs from 'fs';\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * ### Use on function calling callback with multiple arguments\n * ```ts\n * someFunction((err, a, b) => {\n *   console.log(err); // null\n *   console.log(a); // 5\n *   console.log(b); // \"some string\"\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(value => {\n *   console.log(value); // [5, \"some string\"]\n * });\n * ```\n *\n * ### Use on function calling callback in regular style\n * ```ts\n * someFunction(a => {\n *   console.log(a); // 5\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(\n *   value => {}             // never gets called\n *   err => console.log(err) // 5\n * );\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link from}\n *\n * @param {function} func Function with a Node.js-style callback as the last parameter.\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\n * callbacks.\n * @return {function(...params: *): Observable} A function which returns the\n * Observable that delivers the same values the Node.js callback would\n * deliver.\n */\nexport function bindNodeCallback(\n  callbackFunc: (...args: [...any[], (err: any, ...res: any) => void]) => void,\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any> {\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","export function createObject(keys: string[], values: any[]) {\n  return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {} as any);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf, ObservableInputTuple } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { Subscriber } from '../Subscriber';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { Subscription } from '../Subscription';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { AnyCatcher } from '../AnyCatcher';\nimport { executeSchedule } from '../util/executeSchedule';\n\n// combineLatest(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function combineLatest<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// combineLatest([a, b, c])\nexport function combineLatest(sources: []): Observable<never>;\nexport function combineLatest<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R,\n  scheduler: SchedulerLike\n): Observable<R>;\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  sources: readonly [...ObservableInputTuple<A>],\n  scheduler: SchedulerLike\n): Observable<A>;\n\n// combineLatest(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelectorAndScheduler: [...ObservableInputTuple<A>, (...values: A) => R, SchedulerLike]\n): Observable<R>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): Observable<A>;\n\n// combineLatest({a, b, c})\nexport function combineLatest(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function combineLatest<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed in the\n * observables array. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to this operator,\n * the returned Observable will always emit an array of `n` values, in an order\n * corresponding to the order of the passed Observables (the value from the first Observable\n * will be at index 0 of the array and so on).\n *\n * Static version of `combineLatest` accepts an array of Observables. Note that an array of\n * Observables is a good choice, if you don't know beforehand how many Observables\n * you will combine. Passing an empty array will result in an Observable that\n * completes immediately.\n *\n * To ensure the output array always has the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all these values but the last\n * will be lost. On the other hand, if some Observable does not emit a value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will now be impossible to include a value from the\n * completed Observable in the resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, the resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, the result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of a completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * ## Examples\n *\n * Combine two timer Observables\n *\n * ```ts\n * import { timer, combineLatest } from 'rxjs';\n *\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest([firstTimer, secondTimer]);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * Combine a dictionary of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = {\n *   a: of(1).pipe(delay(1000), startWith(0)),\n *   b: of(5).pipe(delay(5000), startWith(0)),\n *   c: of(10).pipe(delay(10000), startWith(0))\n * };\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // { a: 0, b: 0, c: 0 } immediately\n * // { a: 1, b: 0, c: 0 } after 1s\n * // { a: 1, b: 5, c: 0 } after 5s\n * // { a: 1, b: 5, c: 10 } after 10s\n * ```\n *\n * Combine an array of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000), // emit 0 and then emit n after n seconds\n *     startWith(0)\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n * Use map operator to dynamically calculate the Body-Mass Index\n *\n * ```ts\n * import { of, combineLatest, map } from 'rxjs';\n *\n * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest([weight, height]).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} [observables] An array of input Observables to combine with each other.\n * An array of Observables must be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\nexport function combineLatest<O extends ObservableInput<any>, R>(...args: any[]): Observable<R> | Observable<ObservedValueOf<O>[]> {\n  const scheduler = popScheduler(args);\n  const resultSelector = popResultSelector(args);\n\n  const { args: observables, keys } = argsArgArrayOrObject(args);\n\n  if (observables.length === 0) {\n    // If no observables are passed, or someone has passed an empty array\n    // of observables, or even an empty object POJO, we need to just\n    // complete (EMPTY), but we have to honor the scheduler provided if any.\n    return from([], scheduler as any);\n  }\n\n  const result = new Observable<ObservedValueOf<O>[]>(\n    combineLatestInit(\n      observables as ObservableInput<ObservedValueOf<O>>[],\n      scheduler,\n      keys\n        ? // A handler for scrubbing the array of args into a dictionary.\n          (values) => createObject(keys, values)\n        : // A passthrough to just return the array\n          identity\n    )\n  );\n\n  return resultSelector ? (result.pipe(mapOneOrManyArgs(resultSelector)) as Observable<R>) : result;\n}\n\nexport function combineLatestInit(\n  observables: ObservableInput<any>[],\n  scheduler?: SchedulerLike,\n  valueTransform: (values: any[]) => any = identity\n) {\n  return (subscriber: Subscriber<any>) => {\n    // The outer subscription. We're capturing this in a function\n    // because we may have to schedule it.\n    maybeSchedule(\n      scheduler,\n      () => {\n        const { length } = observables;\n        // A store for the values each observable has emitted so far. We match observable to value on index.\n        const values = new Array(length);\n        // The number of currently active subscriptions, as they complete, we decrement this number to see if\n        // we are all done combining values, so we can complete the result.\n        let active = length;\n        // The number of inner sources that still haven't emitted the first value\n        // We need to track this because all sources need to emit one value in order\n        // to start emitting values.\n        let remainingFirstValues = length;\n        // The loop to kick off subscription. We're keying everything on index `i` to relate the observables passed\n        // in to the slot in the output array or the key in the array of keys in the output dictionary.\n        for (let i = 0; i < length; i++) {\n          maybeSchedule(\n            scheduler,\n            () => {\n              const source = from(observables[i], scheduler as any);\n              let hasFirstValue = false;\n              source.subscribe(\n                createOperatorSubscriber(\n                  subscriber,\n                  (value) => {\n                    // When we get a value, record it in our set of values.\n                    values[i] = value;\n                    if (!hasFirstValue) {\n                      // If this is our first value, record that.\n                      hasFirstValue = true;\n                      remainingFirstValues--;\n                    }\n                    if (!remainingFirstValues) {\n                      // We're not waiting for any more\n                      // first values, so we can emit!\n                      subscriber.next(valueTransform(values.slice()));\n                    }\n                  },\n                  () => {\n                    if (!--active) {\n                      // We only complete the result if we have no more active\n                      // inner observables.\n                      subscriber.complete();\n                    }\n                  }\n                )\n              );\n            },\n            subscriber\n          );\n        }\n      },\n      subscriber\n    );\n  };\n}\n\n/**\n * A small utility to handle the couple of locations where we want to schedule if a scheduler was provided,\n * but we don't if there was no scheduler.\n */\nfunction maybeSchedule(scheduler: SchedulerLike | undefined, execute: () => void, subscription: Subscription) {\n  if (scheduler) {\n    executeSchedule(subscription, scheduler, execute);\n  } else {\n    execute();\n  }\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n","import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Infinity] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n","import { mergeAll } from './mergeAll';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * ![](concatAll.svg)\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, map, interval, take, concatAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(4)))\n * );\n * const firstOrder = higherOrder.pipe(concatAll());\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaustAll}\n * @see {@link mergeAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable emitting values from all the\n * inner Observables concatenated.\n */\nexport function concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeAll(1);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple, SchedulerLike } from '../types';\nimport { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function concat<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function concat<T extends readonly unknown[]>(\n  ...inputsAndScheduler: [...ObservableInputTuple<T>, SchedulerLike]\n): Observable<T[number]>;\n\n/**\n * Creates an output Observable which sequentially emits all values from the first given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * ![](concat.png)\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * ## Examples\n *\n * Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\n *\n * ```ts\n * import { interval, take, range, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(4));\n * const sequence = range(1, 10);\n * const result = concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n * ```\n *\n * Concatenate 3 Observables\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const result = concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n * ```\n *\n * Concatenate the same Observable to repeat it\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(2));\n *\n * concat(timer, timer) // concatenating the same Observable!\n *   .subscribe({\n *     next: value => console.log(value),\n *     complete: () => console.log('...and it is done!')\n *   });\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // '...and it is done!' also after 4s\n * ```\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link startWith}\n * @see {@link endWith}\n *\n * @param args Input Observables to concatenate.\n */\nexport function concat(...args: any[]): Observable<unknown> {\n  return concatAll()(from(args, popScheduler(args)));\n}\n","import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInput } from '../types';\nimport { innerFrom } from './innerFrom';\n\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create an Observable only when the Observer\n * subscribes. It waits until an Observer subscribes to it, calls the given\n * factory function to get an Observable -- where a factory function typically\n * generates a new Observable -- and subscribes the Observer to this Observable.\n * In case the factory function returns a falsy value, then EMPTY is used as\n * Observable instead. Last but not least, an exception during the factory\n * function call is transferred to the Observer by calling `error`.\n *\n * ## Example\n *\n * Subscribe to either an Observable of clicks or an Observable of interval, at random\n *\n * ```ts\n * import { defer, fromEvent, interval } from 'rxjs';\n *\n * const clicksOrInterval = defer(() => {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param {function(): ObservableInput} observableFactory The Observable\n * factory function to invoke for each Observer that subscribes to the output\n * Observable. May also return a Promise, which will be converted on the fly\n * to an Observable.\n * @return {Observable} An Observable whose Observers' subscriptions trigger\n * an invocation of the given Observable factory function.\n */\nexport function defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\n  return new Observable<ObservedValueOf<R>>((subscriber) => {\n    innerFrom(observableFactory()).subscribe(subscriber);\n  });\n}\n","import { Connectable, ObservableInput, SubjectLike } from '../types';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { defer } from './defer';\n\nexport interface ConnectableConfig<T> {\n  /**\n   * A factory function used to create the Subject through which the source\n   * is multicast. By default this creates a {@link Subject}.\n   */\n  connector: () => SubjectLike<T>;\n  /**\n   * If true, the resulting observable will reset internal state upon disconnection\n   * and return to a \"cold\" state. This allows the resulting observable to be\n   * reconnected.\n   * If false, upon disconnection, the connecting subject will remain the\n   * connecting subject, meaning the resulting observable will not go \"cold\" again,\n   * and subsequent repeats or resubscriptions will resubscribe to that same subject.\n   */\n  resetOnDisconnect?: boolean;\n}\n\n/**\n * The default configuration for `connectable`.\n */\nconst DEFAULT_CONFIG: ConnectableConfig<unknown> = {\n  connector: () => new Subject<unknown>(),\n  resetOnDisconnect: true,\n};\n\n/**\n * Creates an observable that multicasts once `connect()` is called on it.\n *\n * @param source The observable source to make connectable.\n * @param config The configuration object for `connectable`.\n * @returns A \"connectable\" observable, that has a `connect()` method, that you must call to\n * connect the source to all consumers through the subject provided as the connector.\n */\nexport function connectable<T>(source: ObservableInput<T>, config: ConnectableConfig<T> = DEFAULT_CONFIG): Connectable<T> {\n  // The subscription representing the connection.\n  let connection: Subscription | null = null;\n  const { connector, resetOnDisconnect = true } = config;\n  let subject = connector();\n\n  const result: any = new Observable<T>((subscriber) => {\n    return subject.subscribe(subscriber);\n  });\n\n  // Define the `connect` function. This is what users must call\n  // in order to \"connect\" the source to the subject that is\n  // multicasting it.\n  result.connect = () => {\n    if (!connection || connection.closed) {\n      connection = defer(() => source).subscribe(subject);\n      if (resetOnDisconnect) {\n        connection.add(() => (subject = connector()));\n      }\n    }\n    return connection;\n  };\n\n  return result;\n}\n","import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInputTuple, ObservableInput } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { innerFrom } from './innerFrom';\nimport { popResultSelector } from '../util/args';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { createObject } from '../util/createObject';\nimport { AnyCatcher } from '../AnyCatcher';\n\n// forkJoin(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function forkJoin<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// forkJoin(null | undefined)\nexport function forkJoin(scheduler: null | undefined): Observable<never>;\n\n// forkJoin([a, b, c])\nexport function forkJoin(sources: readonly []): Observable<never>;\nexport function forkJoin<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\nexport function forkJoin<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n\n// forkJoin(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function forkJoin<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function forkJoin<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n\n// forkJoin({a, b, c})\nexport function forkJoin(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function forkJoin<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\n * or a dictionary of values in the same shape as the passed dictionary.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted;\n * complete immediately if an empty array is passed.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\n * or a dictionary of input observables. If no input observables are provided (e.g. an empty array is passed),\n * then the resulting stream will complete immediately.\n *\n * `forkJoin` will wait for all passed observables to emit and complete and then it will emit an array or an object with last\n * values from corresponding observables.\n *\n * If you pass an array of `n` observables to the operator, then the resulting\n * array will have `n` values, where the first value is the last one emitted by the first observable,\n * second value is the last one emitted by the second observable and so on.\n *\n * If you pass a dictionary of observables to the operator, then the resulting\n * objects will have the same keys as the dictionary passed, with their last values they have emitted\n * located at the corresponding key.\n *\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\n * values not only at the end of the lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for the resulting array to have the same length as the number of input observables, whenever any of\n * the given observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other observables.\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete either,\n * unless at any point some other observable completes without emitting a value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all given observables\n * have to emit something at least once and complete.\n *\n * If any given observable errors at some point, `forkJoin` will error as well and immediately unsubscribe\n * from the other observables.\n *\n * Optionally `forkJoin` accepts a `resultSelector` function, that will be called with values which normally\n * would land in the emitted array. Whatever is returned by the `resultSelector`, will appear in the output\n * observable instead. This means that the default `resultSelector` can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that the `resultSelector` will be called only\n * when `forkJoin` is supposed to emit a result.\n *\n * ## Examples\n *\n * Use `forkJoin` with a dictionary of observable inputs\n *\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin({\n *   foo: of(1, 2, 3, 4),\n *   bar: Promise.resolve(8),\n *   baz: timer(4000)\n * });\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\n * // 'This is how it ends!' immediately after\n * ```\n *\n * Use `forkJoin` with an array of observable inputs\n *\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin([\n *   of(1, 2, 3, 4),\n *   Promise.resolve(8),\n *   timer(4000)\n * ]);\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // [4, 8, 0] after 4 seconds\n * // 'This is how it ends!' immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} args Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin(...args: any[]): Observable<any> {\n  const resultSelector = popResultSelector(args);\n  const { args: sources, keys } = argsArgArrayOrObject(args);\n  const result = new Observable((subscriber) => {\n    const { length } = sources;\n    if (!length) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(length);\n    let remainingCompletions = length;\n    let remainingEmissions = length;\n    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n      let hasValue = false;\n      innerFrom(sources[sourceIndex]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            if (!hasValue) {\n              hasValue = true;\n              remainingEmissions--;\n            }\n            values[sourceIndex] = value;\n          },\n          () => remainingCompletions--,\n          undefined,\n          () => {\n            if (!remainingCompletions || !hasValue) {\n              if (!remainingEmissions) {\n                subscriber.next(keys ? createObject(keys, values) : values);\n              }\n              subscriber.complete();\n            }\n          }\n        )\n      );\n    }\n  });\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * // note optional configuration parameter which will be passed to addEventListener\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\n * const clicksInDiv = fromEvent(div, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n * @param {string} eventName The event name of interest, being emitted by the\n * `target`.\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n * @return {Observable<T>}\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  // Figure out our add and remove methods. In order to do this,\n  // we are going to analyze the target in a preferred order, if\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\n  // method names and apply them to a map to create opposite versions of the\n  // same function. This is because they all operate in duplicate pairs,\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\n  // The call only differs by method name, as to whether or not you're adding or removing.\n  const [add, remove] =\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n    isEventTarget(target)\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\n      : // In all other cases, the call pattern is identical with the exception of the method names.\n      isNodeStyleEventEmitter(target)\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n      : isJQueryStyleEventEmitter(target)\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n      : [];\n\n  // If add is falsy, it's because we didn't match a pattern above.\n  // Check to see if it is an ArrayLike, because if it is, we want to\n  // try to apply fromEvent to all of it's items. We do this check last,\n  // because there are may be some types that are both ArrayLike *and* implement\n  // event registry points, and we'd rather delegate to that when possible.\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\n        innerFrom(target)\n      ) as Observable<T>;\n    }\n  }\n\n  // If add is falsy and we made it here, it's because we didn't\n  // match any valid target objects above.\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    // The handler we are going to register. Forwards the event object, by itself, or\n    // an array of arguments to the event handler, if there is more than one argument,\n    // to the consumer.\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    // Do the work of adding the handler to the target.\n    add(handler);\n    // When we finalize, we want to remove the handler and free up memory.\n    return () => remove!(handler);\n  });\n}\n\n/**\n * Used to create `add` and `remove` functions to register and unregister event handlers\n * from a target in the most common handler pattern, where there are only two arguments.\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\n * @param target The target we're calling methods on\n * @param eventName The event name for the event we're creating register or unregister functions for\n */\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n","import { Observable } from '../Observable';\nimport { isFunction } from '../util/isFunction';\nimport { NodeEventHandler } from './fromEvent';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n/* tslint:disable:max-line-length */\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void\n): Observable<T>;\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n  resultSelector?: (...args: any[]) => T\n): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an Observable from an arbitrary API for registering event handlers.\n *\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\n * was not prepared for.</span>\n *\n * ![](fromEventPattern.png)\n *\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\n * for events. It is similar to {@link fromEvent}, but far\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\n * `fromEventPattern` (although in slightly more verbose way).\n *\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\n * handler parameter. That handler is actually an event handler function that you now can pass\n * to API expecting it. `addHandler` will be called whenever Observable\n * returned by the operator is subscribed, so registering handler in API will not\n * necessarily happen when `fromEventPattern` is called.\n *\n * After registration, every time an event that we listen to happens,\n * Observable returned by `fromEventPattern` will emit value that event handler\n * function was called with. Note that if event handler was called with more\n * than one argument, second and following arguments will not appear in the Observable.\n *\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\n * another function - `removeHandler` - as a second parameter. It will be injected\n * with the same handler function as before, which now you can use to unregister\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\n * unsubscribes from it.\n *\n * In some APIs unregistering is actually handled differently. Method registering an event handler\n * returns some kind of token, which is later used to identify which function should\n * be unregistered or it itself has method that unregisters event handler.\n * If that is the case with your API, make sure token returned\n * by registering method is returned by `addHandler`. Then it will be passed\n * as a second argument to `removeHandler`, where you will be able to use it.\n *\n * If you need access to all event handler parameters (not only the first one),\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\n * third parameter - project function which will accept all arguments passed to\n * event handler when it is called. Whatever is returned from project function will appear on\n * resulting stream instead of usual event handlers first argument. This means\n * that default project can be thought of as function that takes its first parameter\n * and ignores the rest.\n *\n * ## Examples\n *\n * Emits clicks happening on the DOM document\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * function addClickHandler(handler) {\n *   document.addEventListener('click', handler);\n * }\n *\n * function removeClickHandler(handler) {\n *   document.removeEventListener('click', handler);\n * }\n *\n * const clicks = fromEventPattern(\n *   addClickHandler,\n *   removeClickHandler\n * );\n * clicks.subscribe(x => console.log(x));\n *\n * // Whenever you click anywhere in the browser, DOM MouseEvent\n * // object will be logged.\n * ```\n *\n * Use with API that returns cancellation token\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * const token = someAPI.registerEventHandler(function() {});\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\n *                                        // not handler itself, but special token.\n *\n * const someAPIObservable = fromEventPattern(\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\n * );\n * ```\n *\n * Use with project function\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * someAPI.registerEventHandler((eventType, eventMessage) => {\n *   console.log(eventType, eventMessage); // Logs 'EVENT_TYPE' 'EVENT_MESSAGE' to console.\n * });\n *\n * const someAPIObservable = fromEventPattern(\n *   handler => someAPI.registerEventHandler(handler),\n *   handler => someAPI.unregisterEventHandler(handler)\n *   (eventType, eventMessage) => eventType + ' --- ' + eventMessage // without that function only 'EVENT_TYPE'\n * );                                                                // would be emitted by the Observable\n *\n * someAPIObservable.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'EVENT_TYPE --- EVENT_MESSAGE'\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n *\n * @param {function(handler: Function): any} addHandler A function that takes\n * a `handler` function as argument and attaches it somehow to the actual\n * source of events.\n * @param {function(handler: Function, token?: any): void} [removeHandler] A function that\n * takes a `handler` function as an argument and removes it from the event source. If `addHandler`\n * returns some kind of token, `removeHandler` function will have it as a second parameter.\n * @param {function(...args: any): T} [project] A function to\n * transform results. It takes the arguments from the event handler and\n * should return a single value.\n * @return {Observable<T>} Observable which, when an event happens, emits first parameter\n * passed to registered event handler. Alternatively it emits whatever project function returns\n * at that moment.\n */\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n  resultSelector?: (...args: any[]) => T\n): Observable<T | T[]> {\n  if (resultSelector) {\n    return fromEventPattern<T>(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  return new Observable<T | T[]>((subscriber) => {\n    const handler = (...e: T[]) => subscriber.next(e.length === 1 ? e[0] : e);\n    const retValue = addHandler(handler);\n    return isFunction(removeHandler) ? () => removeHandler(handler, retValue) : undefined;\n  });\n}\n","import { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { defer } from './defer';\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\n\ntype ConditionFunc<S> = (state: S) => boolean;\ntype IterateFunc<S> = (state: S) => S;\ntype ResultFunc<S, T> = (state: S) => T;\n\nexport interface GenerateBaseOptions<S> {\n  /**\n   * Initial state.\n   */\n  initialState: S;\n  /**\n   * Condition function that accepts state and returns boolean.\n   * When it returns false, the generator stops.\n   * If not specified, a generator never stops.\n   */\n  condition?: ConditionFunc<S>;\n  /**\n   * Iterate function that accepts state and returns new state.\n   */\n  iterate: IterateFunc<S>;\n  /**\n   * SchedulerLike to use for generation process.\n   * By default, a generator starts immediately.\n   */\n  scheduler?: SchedulerLike;\n}\n\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n  /**\n   * Result selection function that accepts state and returns a value to emit.\n   */\n  resultSelector: ResultFunc<S, T>;\n}\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Produces sequence of numbers\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1, x => x);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * ```\n *\n * Use `asapScheduler`\n *\n * ```ts\n * import { generate, asapScheduler } from 'rxjs';\n *\n * const result = generate(1, x => x < 5, x => x * 2, x => x + 1, asapScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 2\n * // 3\n * // 5\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\n * @returns {Observable<T>} The generated sequence.\n * @deprecated Instead of passing separate arguments, use the options argument. Signatures taking separate arguments will be removed in v8.\n */\nexport function generate<T, S>(\n  initialState: S,\n  condition: ConditionFunc<S>,\n  iterate: IterateFunc<S>,\n  resultSelector: ResultFunc<S, T>,\n  scheduler?: SchedulerLike\n): Observable<T>;\n\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * ![](generate.png)\n *\n * `generate` allows you to create a stream of values generated with a loop very similar to\n * a traditional for loop. The first argument of `generate` is a beginning value. The second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * then the loop continues, if not, it stops. The third value is a function which takes the\n * previously defined value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in a traditional for loop: the first expression\n * initializes some state (for example, a numeric index), the second tests if the loop can perform the next\n * iteration (for example, if the index is lower than 10) and the third states how the defined value\n * will be modified on every step (for example, the index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First of all, the condition function is ran. If it returns true, then the Observable\n * emits the currently stored value (initial value at the first iteration) and finally updates\n * that value with iterate function. If at some point the condition returns false, then the Observable\n * completes at that moment.\n *\n * Optionally you can pass a fourth parameter to `generate` - a result selector function which allows you\n * to immediately map the value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * a single object to the operator instead where the object has the properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, or in other words the resulting Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of a multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is a `resultSelector`\n * function or not). In case of a single-parameter call, you can provide it as a\n * `scheduler` property on the object passed to the operator. In both cases, a scheduler decides when\n * the next iteration of the loop will happen and therefore when the next value will be emitted\n * by the Observable. For example, to ensure that each value is pushed to the Observer\n * on a separate task in the event loop, you could use the `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * ## Examples\n *\n * Use with condition and iterate functions\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1);\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * Use with condition, iterate and resultSelector functions\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 'Complete!'\n * ```\n *\n * Use with options object\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 'Complete!'\n * ```\n *\n * Use options object without condition function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!') // This will never run\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n * ```\n *\n * @see {@link from}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\n * @return {Observable<T>} The generated sequence.\n * @deprecated Instead of passing separate arguments, use the options argument. Signatures taking separate arguments will be removed in v8.\n */\nexport function generate<S>(\n  initialState: S,\n  condition: ConditionFunc<S>,\n  iterate: IterateFunc<S>,\n  scheduler?: SchedulerLike\n): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Use options object with condition function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition: x => x < 3,\n *   iterate: x => x + 1\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns {Observable<S>} The generated sequence.\n */\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Use options object with condition and iterate function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition: x => x < 3,\n *   iterate: x => x + 1,\n *   resultSelector: x => x\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns {Observable<T>} The generated sequence.\n */\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n\nexport function generate<T, S>(\n  initialStateOrOptions: S | GenerateOptions<T, S>,\n  condition?: ConditionFunc<S>,\n  iterate?: IterateFunc<S>,\n  resultSelectorOrScheduler?: ResultFunc<S, T> | SchedulerLike,\n  scheduler?: SchedulerLike\n): Observable<T> {\n  let resultSelector: ResultFunc<S, T>;\n  let initialState: S;\n\n  // TODO: Remove this as we move away from deprecated signatures\n  // and move towards a configuration object argument.\n  if (arguments.length === 1) {\n    // If we only have one argument, we can assume it is a configuration object.\n    // Note that folks not using TypeScript may trip over this.\n    ({\n      initialState,\n      condition,\n      iterate,\n      resultSelector = identity as ResultFunc<S, T>,\n      scheduler,\n    } = initialStateOrOptions as GenerateOptions<T, S>);\n  } else {\n    // Deprecated arguments path. Figure out what the user\n    // passed and set it here.\n    initialState = initialStateOrOptions as S;\n    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\n      resultSelector = identity as ResultFunc<S, T>;\n      scheduler = resultSelectorOrScheduler as SchedulerLike;\n    } else {\n      resultSelector = resultSelectorOrScheduler as ResultFunc<S, T>;\n    }\n  }\n\n  // The actual generator used to \"generate\" values.\n  function* gen() {\n    for (let state = initialState; !condition || condition(state); state = iterate!(state)) {\n      yield resultSelector(state);\n    }\n  }\n\n  // We use `defer` because we want to defer the creation of the iterator from the iterable.\n  return defer(\n    (scheduler\n      ? // If a scheduler was provided, use `scheduleIterable` to ensure that iteration/generation\n        // happens on the scheduler.\n        () => scheduleIterable(gen(), scheduler!)\n      : // Otherwise, if there's no scheduler, we can just use the generator function directly in\n        // `defer` and executing it will return the generator (which is iterable).\n        gen) as () => ObservableInput<T>\n  );\n}\n","import { Observable } from '../Observable';\nimport { defer } from './defer';\nimport { ObservableInput } from '../types';\n\n/**\n * Checks a boolean at subscription time, and chooses between one of two observable sources\n *\n * `iif` expects a function that returns a boolean (the `condition` function), and two sources,\n * the `trueResult` and the `falseResult`, and returns an Observable.\n *\n * At the moment of subscription, the `condition` function is called. If the result is `true`, the\n * subscription will be to the source passed as the `trueResult`, otherwise, the subscription will be\n * to the source passed as the `falseResult`.\n *\n * If you need to check more than two options to choose between more than one observable, have a look at the {@link defer} creation method.\n *\n * ## Examples\n *\n * Change at runtime which Observable will be subscribed\n *\n * ```ts\n * import { iif, of } from 'rxjs';\n *\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second')\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'first'\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'second'\n * ```\n *\n * Control access to an Observable\n *\n * ```ts\n * import { iif, of, EMPTY } from 'rxjs';\n *\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'),\n *   EMPTY\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('The end')\n * });\n *\n * // Logs:\n * // 'It seems you have an access...'\n * // 'The end'\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('The end')\n * });\n *\n * // Logs:\n * // 'The end'\n * ```\n *\n * @see {@link defer}\n *\n * @param condition Condition which Observable should be chosen.\n * @param trueResult An Observable that will be subscribed if condition is true.\n * @param falseResult An Observable that will be subscribed if condition is false.\n * @return An observable that proxies to `trueResult` or `falseResult`, depending on the result of the `condition` function.\n */\nexport function iif<T, F>(condition: () => boolean, trueResult: ObservableInput<T>, falseResult: ObservableInput<F>): Observable<T | F> {\n  return defer(() => (condition() ? trueResult : falseResult));\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\n\n/**\n * Creates an observable that will wait for a specified time period, or exact date, before\n * emitting the number 0.\n *\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\n *\n * This observable is useful for creating delays in code, or racing against other values\n * for ad-hoc timeouts.\n *\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Examples\n *\n * Wait 3 seconds and start another observable\n *\n * You might want to use `timer` to delay subscription to an\n * observable by a set amount of time. Here we use a timer with\n * {@link concatMapTo} or {@link concatMap} in order to wait\n * a few seconds and start a subscription to a source.\n *\n * ```ts\n * import { of, timer, concatMap } from 'rxjs';\n *\n * // This could be any observable\n * const source = of(1, 2, 3);\n *\n * timer(3000)\n *   .pipe(concatMap(() => source))\n *   .subscribe(console.log);\n * ```\n *\n * Take all values until the start of the next minute\n *\n * Using a `Date` as the trigger for the first emission, you can\n * do things like wait until midnight to fire an event, or in this case,\n * wait until a new minute starts (chosen so the example wouldn't take\n * too long to run) in order to stop watching a stream. Leveraging\n * {@link takeUntil}.\n *\n * ```ts\n * import { interval, takeUntil, timer } from 'rxjs';\n *\n * // Build a Date object that marks the\n * // next minute.\n * const currentDate = new Date();\n * const startOfNextMinute = new Date(\n *   currentDate.getFullYear(),\n *   currentDate.getMonth(),\n *   currentDate.getDate(),\n *   currentDate.getHours(),\n *   currentDate.getMinutes() + 1\n * );\n *\n * // This could be any observable stream\n * const source = interval(1000);\n *\n * const result = source.pipe(\n *   takeUntil(timer(startOfNextMinute))\n * );\n *\n * result.subscribe(console.log);\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `dueTime`.\n *\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\n * If a `Date`, the exact time at which to emit.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\n\n/**\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\n * on each interval after words.\n *\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Example\n *\n * ### Start an interval that starts right away\n *\n * Since {@link interval} waits for the passed delay before starting,\n * sometimes that's not ideal. You may want to start an interval immediately.\n * `timer` works well for this. Here we have both side-by-side so you can\n * see them in comparison.\n *\n * Note that this observable will never complete.\n *\n * ```ts\n * import { timer, interval } from 'rxjs';\n *\n * timer(0, 1000).subscribe(n => console.log('timer', n));\n * interval(1000).subscribe(n => console.log('interval', n));\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `startDue`.\n * @param startDue If a `number`, is the time to wait before starting the interval.\n * If a `Date`, is the exact time at which to start the interval.\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\n * negative number here will result in immediate completion after the first value is emitted, as though\n * no `intervalDuration` was passed at all.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\n\n/**\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\n */\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\n\nexport function timer(\n  dueTime: number | Date = 0,\n  intervalOrScheduler?: number | SchedulerLike,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  // Since negative intervalDuration is treated as though no\n  // interval was specified at all, we start with a negative number.\n  let intervalDuration = -1;\n\n  if (intervalOrScheduler != null) {\n    // If we have a second argument, and it's a scheduler,\n    // override the scheduler we had defaulted. Otherwise,\n    // it must be an interval.\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      // Note that this *could* be negative, in which case\n      // it's like not passing an intervalDuration at all.\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n\n  return new Observable((subscriber) => {\n    // If a valid date is passed, calculate how long to wait before\n    // executing the first value... otherwise, if it's a number just schedule\n    // that many milliseconds (or scheduler-specified unit size) in the future.\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\n\n    if (due < 0) {\n      // Ensure we don't schedule in the future.\n      due = 0;\n    }\n\n    // The incrementing value we emit.\n    let n = 0;\n\n    // Start the timer.\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        // Emit the next value and increment.\n        subscriber.next(n++);\n\n        if (0 <= intervalDuration) {\n          // If we have a interval after the initial timer,\n          // reschedule with the period.\n          this.schedule(undefined, intervalDuration);\n        } else {\n          // We didn't have an interval. So just complete.\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}\n","import { Observable } from '../Observable';\nimport { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike } from '../types';\nimport { timer } from './timer';\n\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.</span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n *\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param {number} [period=0] The interval size in milliseconds (by default)\n * or the time unit determined by the scheduler's clock.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a sequential number each time\n * interval.\n */\nexport function interval(period = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number> {\n  if (period < 0) {\n    // We cannot schedule an interval in the past.\n    period = 0;\n  }\n\n  return timer(period, period, scheduler);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      innerFrom(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(from(sources, scheduler));\n}\n","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n","const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from './innerFrom';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function onErrorResumeNext<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\n\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits a complete or an error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the result of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * ## Example\n *\n * Subscribe to the next Observable after map fails\n *\n * ```ts\n * import { onErrorResumeNext, of, map } from 'rxjs';\n *\n * onErrorResumeNext(\n *   of(1, 2, 3, 0).pipe(\n *     map(x => {\n *       if (x === 0) {\n *         throw Error();\n *       }\n *       return 10 / x;\n *     })\n *   ),\n *   of(1, 2, 3)\n * )\n * .subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(err),     // Will never be called.\n *   complete: () => console.log('done')\n * });\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // 'done'\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\n * @return {Observable} An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\nexport function onErrorResumeNext<A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): Observable<A[number]> {\n  const nextSources: ObservableInputTuple<A> = argsOrArgArray(sources) as any;\n\n  return new Observable((subscriber) => {\n    let sourceIndex = 0;\n    const subscribeNext = () => {\n      if (sourceIndex < nextSources.length) {\n        let nextSource: Observable<A[number]>;\n        try {\n          nextSource = innerFrom(nextSources[sourceIndex++]);\n        } catch (err) {\n          subscribeNext();\n          return;\n        }\n        const innerSubscriber = new OperatorSubscriber(subscriber, undefined, noop, noop);\n        nextSource.subscribe(innerSubscriber);\n        innerSubscriber.add(subscribeNext);\n      } else {\n        subscriber.complete();\n      }\n    };\n    subscribeNext();\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { from } from './from';\n\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<T>(arr: readonly T[], scheduler?: SchedulerLike): Observable<[string, T]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<O extends Record<string, unknown>>(obj: O, scheduler?: SchedulerLike): Observable<[keyof O, O[keyof O]]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<T>(iterable: Iterable<T>, scheduler?: SchedulerLike): Observable<[string, T]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs(\n  n: number | bigint | boolean | ((...args: any[]) => any) | symbol,\n  scheduler?: SchedulerLike\n): Observable<[never, never]>;\n\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * ![](pairs.png)\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default, these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * ## Example\n *\n * Converts an object to an Observable\n *\n * ```ts\n * import { pairs } from 'rxjs';\n *\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj).subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // ['foo', 42]\n * // ['bar', 56]\n * // ['baz', 78]\n * // 'Complete!'\n * ```\n *\n * ### Object.entries required\n *\n * In IE, you will need to polyfill `Object.entries` in order to use this.\n * [MDN has a polyfill here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n *\n * @param {Object} obj The object to inspect and turn into an\n * Observable sequence.\n * @param {Scheduler} [scheduler] An optional IScheduler to schedule\n * when resulting Observable will emit values.\n * @returns {(Observable<Array<string|T>>)} An observable sequence of\n * [key, value] pairs from the object.\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs(obj: any, scheduler?: SchedulerLike) {\n  return from(Object.entries(obj), scheduler as any);\n}\n","export function not<T>(pred: (value: T, index: number) => boolean, thisArg: any): (value: T, index: number) => boolean {\n  return (value: T, index: number) => !pred.call(thisArg, value, index); \n}","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n *\n * Emit only click events whose target was a DIV element\n *\n * ```ts\n * import { fromEvent, filter } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param thisArg An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits items from the\n * source Observable that satisfy the specified `predicate`.\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // An index passed to our predicate function on each call.\n    let index = 0;\n\n    // Subscribe to the source, all errors and completions are\n    // forwarded to the consumer.\n    source.subscribe(\n      // Call the predicate with the appropriate `this` context,\n      // if the predicate returns `true`, then send the value\n      // to the consumer.\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\n    );\n  });\n}\n","import { not } from '../util/not';\nimport { filter } from '../operators/filter';\nimport { ObservableInput } from '../types';\nimport { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function partition<T, U extends T, A>(\n  source: ObservableInput<T>,\n  predicate: (this: A, value: T, index: number) => value is U,\n  thisArg: A\n): [Observable<U>, Observable<Exclude<T, U>>];\nexport function partition<T, U extends T>(\n  source: ObservableInput<T>,\n  predicate: (value: T, index: number) => value is U\n): [Observable<U>, Observable<Exclude<T, U>>];\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function partition<T, A>(\n  source: ObservableInput<T>,\n  predicate: (this: A, value: T, index: number) => boolean,\n  thisArg: A\n): [Observable<T>, Observable<T>];\nexport function partition<T>(source: ObservableInput<T>, predicate: (value: T, index: number) => boolean): [Observable<T>, Observable<T>];\n\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n *\n * Partition a set of numbers into odds and evens observables\n *\n * ```ts\n * import { of, partition } from 'rxjs';\n *\n * const observableValues = of(1, 2, 3, 4, 5, 6);\n * const [evens$, odds$] = partition(observableValues, value => value % 2 === 0);\n *\n * odds$.subscribe(x => console.log('odds', x));\n * evens$.subscribe(x => console.log('evens', x));\n *\n * // Logs:\n * // odds 1\n * // odds 3\n * // odds 5\n * // evens 2\n * // evens 4\n * // evens 6\n * ```\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n */\nexport function partition<T>(\n  source: ObservableInput<T>,\n  predicate: (this: any, value: T, index: number) => boolean,\n  thisArg?: any\n): [Observable<T>, Observable<T>] {\n  return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))] as [\n    Observable<T>,\n    Observable<T>\n  ];\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { Subscriber } from '../Subscriber';\n\nexport function race<T extends readonly unknown[]>(inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function race<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\n\n/**\n * Returns an observable that mirrors the first source observable to emit an item.\n *\n * ![](race.png)\n *\n * `race` returns an observable, that when subscribed to, subscribes to all source observables immediately.\n * As soon as one of the source observables emits a value, the result unsubscribes from the other sources.\n * The resulting observable will forward all notifications, including error and completion, from the \"winning\"\n * source observable.\n *\n * If one of the used source observable throws an errors before a first notification\n * the race operator will also throw an error, no matter if another source observable\n * could potentially win the race.\n *\n * `race` can be useful for selecting the response from the fastest network connection for\n * HTTP or WebSockets. `race` can also be useful for switching observable context based on user\n * input.\n *\n * ## Example\n *\n * Subscribes to the observable that was the first to start emitting.\n *\n * ```ts\n * import { interval, map, race } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * race(obs1, obs2, obs3)\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param {...Observables} ...observables sources used to race for which Observable emits first.\n * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.\n */\nexport function race<T>(...sources: (ObservableInput<T> | ObservableInput<T>[])[]): Observable<any> {\n  sources = argsOrArgArray(sources);\n  // If only one source was passed, just return it. Otherwise return the race.\n  return sources.length === 1 ? innerFrom(sources[0] as ObservableInput<T>) : new Observable<T>(raceInit(sources as ObservableInput<T>[]));\n}\n\n/**\n * An observable initializer function for both the static version and the\n * operator version of race.\n * @param sources The sources to race\n */\nexport function raceInit<T>(sources: ObservableInput<T>[]) {\n  return (subscriber: Subscriber<T>) => {\n    let subscriptions: Subscription[] = [];\n\n    // Subscribe to all of the sources. Note that we are checking `subscriptions` here\n    // Is is an array of all actively \"racing\" subscriptions, and it is `null` after the\n    // race has been won. So, if we have racer that synchronously \"wins\", this loop will\n    // stop before it subscribes to any more.\n    for (let i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {\n      subscriptions.push(\n        innerFrom(sources[i] as ObservableInput<T>).subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            if (subscriptions) {\n              // We're still racing, but we won! So unsubscribe\n              // all other subscriptions that we have, except this one.\n              for (let s = 0; s < subscriptions.length; s++) {\n                s !== i && subscriptions[s].unsubscribe();\n              }\n              subscriptions = null!;\n            }\n            subscriber.next(value);\n          })\n        )\n      );\n    }\n  };\n}\n","import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { EMPTY } from './empty';\n\nexport function range(start: number, count?: number): Observable<number>;\n\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. Use `range(start, count).pipe(observeOn(scheduler))` instead. Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function range(start: number, count: number | undefined, scheduler: SchedulerLike): Observable<number>;\n\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n *\n * Produce a range of numbers\n *\n * ```ts\n * import { range } from 'rxjs';\n *\n * const numbers = range(1, 3);\n *\n * numbers.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 1\n * // 2\n * // 3\n * // 'Complete!'\n * ```\n *\n * @see {@link timer}\n * @see {@link interval}\n *\n * @param {number} [start=0] The value of the first integer in the sequence.\n * @param {number} count The number of sequential integers to generate.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emissions of the notifications.\n * @return {Observable} An Observable of numbers that emits a finite range of\n * sequential integers.\n */\nexport function range(start: number, count?: number, scheduler?: SchedulerLike): Observable<number> {\n  if (count == null) {\n    // If one argument was passed, it's the count, not the start.\n    count = start;\n    start = 0;\n  }\n\n  if (count <= 0) {\n    // No count? We're going nowhere. Return EMPTY.\n    return EMPTY;\n  }\n\n  // Where the range should stop.\n  const end = count + start;\n\n  return new Observable(\n    scheduler\n      ? // The deprecated scheduled path.\n        (subscriber) => {\n          let n = start;\n          return scheduler.schedule(function () {\n            if (n < end) {\n              subscriber.next(n++);\n              this.schedule();\n            } else {\n              subscriber.complete();\n            }\n          });\n        }\n      : // Standard synchronous range.\n        (subscriber) => {\n          let n = start;\n          while (n < end && !subscriber.closed) {\n            subscriber.next(n++);\n          }\n          subscriber.complete();\n        }\n  );\n}\n","import { Observable } from '../Observable';\nimport { Unsubscribable, ObservableInput, ObservedValueOf } from '../types';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\n\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\n * that implements `unsubscribe` method.\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\n * creates an Observable, that can use injected resource object.\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport function using<T extends ObservableInput<any>>(\n  resourceFactory: () => Unsubscribable | void,\n  observableFactory: (resource: Unsubscribable | void) => T | void\n): Observable<ObservedValueOf<T>> {\n  return new Observable<ObservedValueOf<T>>((subscriber) => {\n    const resource = resourceFactory();\n    const result = observableFactory(resource);\n    const source = result ? innerFrom(result) : EMPTY;\n    source.subscribe(subscriber);\n    return () => {\n      // NOTE: Optional chaining did not work here.\n      // Related TS Issue: https://github.com/microsoft/TypeScript/issues/40818\n      if (resource) {\n        resource.unsubscribe();\n      }\n    };\n  });\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple } from '../types';\nimport { innerFrom } from './innerFrom';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { EMPTY } from './empty';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { popResultSelector } from '../util/args';\n\nexport function zip<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A>;\nexport function zip<A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\nexport function zip<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\nexport function zip<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the last parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * ## Example\n *\n * Combine age and name from different sources\n *\n * ```ts\n * import { of, zip, map } from 'rxjs';\n *\n * const age$ = of(27, 25, 29);\n * const name$ = of('Foo', 'Bar', 'Beer');\n * const isDev$ = of(true, true, false);\n *\n * zip(age$, name$, isDev$).pipe(\n *   map(([age, name, isDev]) => ({ age, name, isDev }))\n * )\n * .subscribe(x => console.log(x));\n *\n * // Outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n * ```\n *\n * @param sources\n * @return {Observable<R>}\n */\nexport function zip(...args: unknown[]): Observable<unknown> {\n  const resultSelector = popResultSelector(args);\n\n  const sources = argsOrArgArray(args) as Observable<unknown>[];\n\n  return sources.length\n    ? new Observable<unknown[]>((subscriber) => {\n        // A collection of buffers of values from each source.\n        // Keyed by the same index with which the sources were passed in.\n        let buffers: unknown[][] = sources.map(() => []);\n\n        // An array of flags of whether or not the sources have completed.\n        // This is used to check to see if we should complete the result.\n        // Keyed by the same index with which the sources were passed in.\n        let completed = sources.map(() => false);\n\n        // When everything is done, release the arrays above.\n        subscriber.add(() => {\n          buffers = completed = null!;\n        });\n\n        // Loop over our sources and subscribe to each one. The index `i` is\n        // especially important here, because we use it in closures below to\n        // access the related buffers and completion properties\n        for (let sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n          innerFrom(sources[sourceIndex]).subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              (value) => {\n                buffers[sourceIndex].push(value);\n                // if every buffer has at least one value in it, then we\n                // can shift out the oldest value from each buffer and emit\n                // them as an array.\n                if (buffers.every((buffer) => buffer.length)) {\n                  const result: any = buffers.map((buffer) => buffer.shift()!);\n                  // Emit the array. If theres' a result selector, use that.\n                  subscriber.next(resultSelector ? resultSelector(...result) : result);\n                  // If any one of the sources is both complete and has an empty buffer\n                  // then we complete the result. This is because we cannot possibly have\n                  // any more values to zip together.\n                  if (buffers.some((buffer, i) => !buffer.length && completed[i])) {\n                    subscriber.complete();\n                  }\n                }\n              },\n              () => {\n                // This source completed. Mark it as complete so we can check it later\n                // if we have to.\n                completed[sourceIndex] = true;\n                // But, if this complete source has nothing in its buffer, then we\n                // can complete the result, because we can't possibly have any more\n                // values from this to zip together with the other values.\n                !buffers[sourceIndex].length && subscriber.complete();\n              }\n            )\n          );\n        }\n\n        // When everything is done, release the arrays above.\n        return () => {\n          buffers = completed = null!;\n        };\n      })\n    : EMPTY;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\n\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.svg)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, audit, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function audit<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    let durationSubscriber: Subscriber<any> | null = null;\n    let isComplete = false;\n\n    const endDuration = () => {\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n      isComplete && subscriber.complete();\n    };\n\n    const cleanupDuration = () => {\n      durationSubscriber = null;\n      isComplete && subscriber.complete();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          lastValue = value;\n          if (!durationSubscriber) {\n            innerFrom(durationSelector(value)).subscribe(\n              (durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration))\n            );\n          }\n        },\n        () => {\n          isComplete = true;\n          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source value, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, auditTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function auditTime<T>(duration: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return audit(() => timer(duration, scheduler));\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * ![](buffer.png)\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * `ObservableInput` (that internally gets converted to an Observable)\n * emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```ts\n * import { fromEvent, interval, buffer } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const intervalEvents = interval(1000);\n * const buffered = intervalEvents.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param closingNotifier An `ObservableInput` that signals the\n * buffer to be emitted on the output Observable.\n * @return A function that returns an Observable of buffers, which are arrays\n * of values.\n */\nexport function buffer<T>(closingNotifier: ObservableInput<any>): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    // The current buffered values.\n    let currentBuffer: T[] = [];\n\n    // Subscribe to our source.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => currentBuffer.push(value),\n        () => {\n          subscriber.next(currentBuffer);\n          subscriber.complete();\n        }\n      )\n    );\n\n    // Subscribe to the closing notifier.\n    innerFrom(closingNotifier).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          // Start a new buffer and emit the previous one.\n          const b = currentBuffer;\n          currentBuffer = [];\n          subscriber.next(b);\n        },\n        noop\n      )\n    );\n\n    return () => {\n      // Ensure buffered values are released on finalization.\n      currentBuffer = null!;\n    };\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * ![](bufferCount.png)\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent, bufferCount } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent, bufferCount } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number | null = null): OperatorFunction<T, T[]> {\n  // If no `startBufferEvery` value was supplied, then we're\n  // opening and closing on the bufferSize itself.\n  startBufferEvery = startBufferEvery ?? bufferSize;\n\n  return operate((source, subscriber) => {\n    let buffers: T[][] = [];\n    let count = 0;\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          let toEmit: T[][] | null = null;\n\n          // Check to see if we need to start a buffer.\n          // This will start one at the first value, and then\n          // a new one every N after that.\n          if (count++ % startBufferEvery! === 0) {\n            buffers.push([]);\n          }\n\n          // Push our value into our active buffers.\n          for (const buffer of buffers) {\n            buffer.push(value);\n            // Check to see if we're over the bufferSize\n            // if we are, record it so we can emit it later.\n            // If we emitted it now and removed it, it would\n            // mutate the `buffers` array while we're looping\n            // over it.\n            if (bufferSize <= buffer.length) {\n              toEmit = toEmit ?? [];\n              toEmit.push(buffer);\n            }\n          }\n\n          if (toEmit) {\n            // We have found some buffers that are over the\n            // `bufferSize`. Emit them, and remove them from our\n            // buffers list.\n            for (const buffer of toEmit) {\n              arrRemove(buffers, buffer);\n              subscriber.next(buffer);\n            }\n          }\n        },\n        () => {\n          // When the source completes, emit all of our\n          // active buffers.\n          for (const buffer of buffers) {\n            subscriber.next(buffer);\n          }\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Clean up our memory when we finalize\n          buffers = null!;\n        }\n      )\n    );\n  });\n}\n","import { Subscription } from '../Subscription';\nimport { OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  maxBufferSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active buffers, their related subscriptions, and removal functions.\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\n    // this is only really used for when *just* the buffer time span is passed.\n    let restartOnEmit = false;\n\n    /**\n     * Does the work of emitting the buffer from the record, ensuring that the\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\n     * after the emit.\n     */\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\n      const { buffer, subs } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    /**\n     * Called every time we start a new buffer. This does\n     * the work of scheduling a job at the requested bufferTimeSpan\n     * that will emit the buffer (if it's not unsubscribed before then).\n     */\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer: T[] = [];\n        const record = {\n          buffer,\n          subs,\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      // The user passed both a bufferTimeSpan (required), and a creation interval\n      // That means we need to start new buffers on the interval, and those buffers need\n      // to wait the required time span before emitting.\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n\n    const bufferTimeSubscriber = createOperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Copy the records, so if we need to remove one we\n        // don't mutate the array. It's hard, but not impossible to\n        // set up a buffer time that could mutate the array and\n        // cause issues here.\n        const recordsCopy = bufferRecords!.slice();\n        for (const record of recordsCopy) {\n          // Loop over all buffers and\n          const { buffer } = record;\n          buffer.push(value);\n          // If the buffer is over the max size, we need to emit it.\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      },\n      () => {\n        // The source completed, emit all of the active\n        // buffers we have before we complete.\n        while (bufferRecords?.length) {\n          subscriber.next(bufferRecords.shift()!.buffer);\n        }\n        bufferTimeSubscriber?.unsubscribe();\n        subscriber.complete();\n        subscriber.unsubscribe();\n      },\n      // Pass all errors through to consumer.\n      undefined,\n      // Clean up\n      () => (bufferRecords = null)\n    );\n\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n","import { Subscription } from '../Subscription';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * ![](bufferToggle.png)\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, bufferToggle, EMPTY } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : EMPTY\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferToggle<T, O>(\n  openings: ObservableInput<O>,\n  closingSelector: (value: O) => ObservableInput<any>\n): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    const buffers: T[][] = [];\n\n    // Subscribe to the openings notifier first\n    innerFrom(openings).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (openValue) => {\n          const buffer: T[] = [];\n          buffers.push(buffer);\n          // We use this composite subscription, so that\n          // when the closing notifier emits, we can tear it down.\n          const closingSubscription = new Subscription();\n\n          const emitBuffer = () => {\n            arrRemove(buffers, buffer);\n            subscriber.next(buffer);\n            closingSubscription.unsubscribe();\n          };\n\n          // The line below will add the subscription to the parent subscriber *and* the closing subscription.\n          closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));\n        },\n        noop\n      )\n    );\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Value from our source. Add it to all pending buffers.\n          for (const buffer of buffers) {\n            buffer.push(value);\n          }\n        },\n        () => {\n          // Source complete. Emit all pending buffers.\n          while (buffers.length > 0) {\n            subscriber.next(buffers.shift()!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * ![](bufferWhen.svg)\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, bufferWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(\n *   bufferWhen(() => interval(1000 + Math.random() * 4000))\n * );\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    // The buffer we keep and emit.\n    let buffer: T[] | null = null;\n    // A reference to the subscriber used to subscribe to\n    // the closing notifier. We need to hold this so we can\n    // end the subscription after the first notification.\n    let closingSubscriber: Subscriber<T> | null = null;\n\n    // Ends the previous closing notifier subscription, so it\n    // terminates after the first emission, then emits\n    // the current buffer  if there is one, starts a new buffer, and starts a\n    // new closing notifier.\n    const openBuffer = () => {\n      // Make sure to finalize the closing subscription, we only cared\n      // about one notification.\n      closingSubscriber?.unsubscribe();\n      // emit the buffer if we have one, and start a new buffer.\n      const b = buffer;\n      buffer = [];\n      b && subscriber.next(b);\n\n      // Get a new closing notifier and subscribe to it.\n      innerFrom(closingSelector()).subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop)));\n    };\n\n    // Start the first buffer.\n    openBuffer();\n\n    // Subscribe to our source.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        // Add every new value to the current buffer.\n        (value) => buffer?.push(value),\n        // When we complete, emit the buffer if we have one,\n        // then complete the result.\n        () => {\n          buffer && subscriber.next(buffer);\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        // Release memory on finalization\n        () => (buffer = closingSubscriber = null!)\n      )\n    );\n  });\n}\n","import { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { Subscription } from '../Subscription';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\n\n/* tslint:disable:max-line-length */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <span class=\"informal\">\n * It only listens to the error channel and ignores notifications.\n * Handles errors from the source observable, and maps them to a new observable.\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\n * </span>\n *\n * ![](catch.png)\n *\n * This operator handles errors, but forwards along all other events to the resulting observable.\n * If the source observable terminates with an error, it will map that error to a new observable,\n * subscribe to it, and forward all of its events to the resulting observable.\n *\n * ## Examples\n *\n * Continue with a different Observable when there's an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\n *\n * ```ts\n * import { of, map, catchError, take } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30)\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throw a new error when the source Observable throws an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     })\n *   )\n *   .subscribe({\n *     next: x => console.log(x),\n *     error: err => console.log(err)\n *   });\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n * @see {@link onErrorResumeNext}\n * @see {@link repeat}\n * @see {@link repeatWhen}\n * @see {@link retry }\n * @see {@link retryWhen}\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n * is returned by the `selector` will be used to continue the observable chain.\n * @return A function that returns an Observable that originates from either\n * the source or the Observable returned by the `selector` function.\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null = null;\n    let syncUnsub = false;\n    let handledResult: Observable<ObservedValueOf<O>>;\n\n    innerSub = source.subscribe(\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\n        if (innerSub) {\n          innerSub.unsubscribe();\n          innerSub = null;\n          handledResult.subscribe(subscriber);\n        } else {\n          // We don't have an innerSub yet, that means the error was synchronous\n          // because the subscribe call hasn't returned yet.\n          syncUnsub = true;\n        }\n      })\n    );\n\n    if (syncUnsub) {\n      // We have a synchronous error, we need to make sure to\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\n      // at the right time, and that finalization occurs at the expected\n      // time between the source error and the subscription to the\n      // next observable.\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult!.subscribe(subscriber);\n    }\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A basic scan operation. This is used for `scan` and `reduce`.\n * @param accumulator The accumulator to use\n * @param seed The seed value for the state to accumulate\n * @param hasSeed Whether or not a seed was provided\n * @param emitOnNext Whether or not to emit the state on next\n * @param emitBeforeComplete Whether or not to emit the before completion\n */\n\nexport function scanInternals<V, A, S>(\n  accumulator: (acc: V | A | S, value: V, index: number) => A,\n  seed: S,\n  hasSeed: boolean,\n  emitOnNext: boolean,\n  emitBeforeComplete?: undefined | true\n) {\n  return (source: Observable<V>, subscriber: Subscriber<any>) => {\n    // Whether or not we have state yet. This will only be\n    // false before the first value arrives if we didn't get\n    // a seed value.\n    let hasState = hasSeed;\n    // The state that we're tracking, starting with the seed,\n    // if there is one, and then updated by the return value\n    // from the accumulator on each emission.\n    let state: any = seed;\n    // An index to pass to the accumulator function.\n    let index = 0;\n\n    // Subscribe to our source. All errors and completions are passed through.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Always increment the index.\n          const i = index++;\n          // Set the state\n          state = hasState\n            ? // We already have state, so we can get the new state from the accumulator\n              accumulator(state, value, i)\n            : // We didn't have state yet, a seed value was not provided, so\n\n              // we set the state to the first value, and mark that we have state now\n              ((hasState = true), value);\n\n          // Maybe send it to the consumer.\n          emitOnNext && subscriber.next(state);\n        },\n        // If an onComplete was given, call it, otherwise\n        // just pass through the complete notification to the consumer.\n        emitBeforeComplete &&\n          (() => {\n            hasState && subscriber.next(state);\n            subscriber.complete();\n          })\n      )\n    );\n  };\n}\n","import { scanInternals } from './scanInternals';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\nexport function reduce<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\nexport function reduce<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\nexport function reduce<V, A, S = A>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\n\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * ![](reduce.png)\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * ## Example\n *\n * Count the number of click events that happened in 5 seconds\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, map, reduce } from 'rxjs';\n *\n * const clicksInFiveSeconds = fromEvent(document, 'click')\n *   .pipe(takeUntil(interval(5000)));\n *\n * const ones = clicksInFiveSeconds.pipe(map(() => 1));\n * const seed = 0;\n * const count = ones.pipe(reduce((acc, one) => acc + one, seed));\n *\n * count.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: A, value: V, index: number): A} accumulator The accumulator function\n * called on each source value.\n * @param {A} [seed] The initial accumulation value.\n * @return A function that returns an Observable that emits a single value that\n * is the result of accumulating the values emitted by the source Observable.\n */\nexport function reduce<V, A>(accumulator: (acc: V | A, value: V, index: number) => A, seed?: any): OperatorFunction<V, V | A> {\n  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));\n}\n","import { reduce } from './reduce';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\nconst arrReducer = (arr: any[], value: any) => (arr.push(value), arr);\n\n/**\n * Collects all source emissions and emits them as an array when the source completes.\n *\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\n *\n * ![](toArray.png)\n *\n * `toArray` will wait until the source Observable completes before emitting\n * the array containing all emissions. When the source Observable errors no\n * array will be emitted.\n *\n * ## Example\n *\n * ```ts\n * import { interval, take, toArray } from 'rxjs';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(10),\n *   toArray()\n * );\n *\n * example.subscribe(value => console.log(value));\n *\n * // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n * ```\n *\n * @return A function that returns an Observable that emits an array of items\n * emitted by the source Observable when source completes.\n */\nexport function toArray<T>(): OperatorFunction<T, T[]> {\n  // Because arrays are mutable, and we're mutating the array in this\n  // reducer process, we have to encapsulate the creation of the initial\n  // array within this `operate` function.\n  return operate((source, subscriber) => {\n    reduce(arrReducer, [] as T[])(source).subscribe(subscriber);\n  });\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { mergeMap } from './mergeMap';\nimport { toArray } from './toArray';\n\n/**\n * Collects all of the inner sources from source observable. Then, once the\n * source completes, joins the values using the given static.\n *\n * This is used for {@link combineLatestAll} and {@link zipAll} which both have the\n * same behavior of collecting all inner observables, then operating on them.\n *\n * @param joinFn The type of static join to apply to the sources collected\n * @param project The projection function to apply to the values, if any\n */\nexport function joinAllInternals<T, R>(joinFn: (sources: ObservableInput<T>[]) => Observable<T>, project?: (...args: any[]) => R) {\n  return pipe(\n    // Collect all inner sources into an array, and emit them when the\n    // source completes.\n    toArray() as OperatorFunction<ObservableInput<T>, ObservableInput<T>[]>,\n    // Run the join function on the collected array of inner sources.\n    mergeMap((sources) => joinFn(sources)),\n    // If a projection function was supplied, apply it to each result.\n    project ? mapOneOrManyArgs(project) : (identity as any)\n  );\n}\n","import { combineLatest } from '../observable/combineLatest';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { joinAllInternals } from './joinAllInternals';\n\nexport function combineLatestAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function combineLatestAll<T>(): OperatorFunction<any, T[]>;\nexport function combineLatestAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function combineLatestAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\n/**\n * Flattens an Observable-of-Observables by applying {@link combineLatest} when the Observable-of-Observables completes.\n *\n * `combineLatestAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes,\n * it subscribes to all collected Observables and combines their values using the {@link combineLatest} strategy, such that:\n *\n * * Every time an inner Observable emits, the output Observable emits\n * * When the returned observable emits, it emits all of the latest values by:\n *    * If a `project` function is provided, it is called with each recent value from each inner Observable in whatever order they\n *      arrived, and the result of the `project` function is what is emitted by the output Observable.\n *    * If there is no `project` function, an array of all the most recent values is emitted by the output Observable.\n *\n * ## Example\n *\n * Map two click events to a finite interval Observable, then apply `combineLatestAll`\n *\n * ```ts\n * import { fromEvent, map, interval, take, combineLatestAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(Math.random() * 2000).pipe(take(3))),\n *   take(2)\n * );\n * const result = higherOrder.pipe(combineLatestAll());\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link combineLatestWith}\n * @see {@link mergeAll}\n *\n * @param project optional function to map the most recent values from each inner Observable into a new result.\n * Takes each of the most recent values from each collected inner Observable as arguments, in order.\n * @return A function that returns an Observable that flattens Observables\n * emitted by the source Observable.\n */\nexport function combineLatestAll<R>(project?: (...values: Array<any>) => R) {\n  return joinAllInternals(combineLatest, project);\n}\n","import { combineLatestAll } from './combineLatestAll';\n\n/**\n * @deprecated Renamed to {@link combineLatestAll}. Will be removed in v8.\n */\nexport const combineAll = combineLatestAll;\n","import { combineLatestInit } from '../observable/combineLatest';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { popResultSelector } from '../util/args';\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  project: (...values: [T, ...A]) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  ...sourcesAndProject: [...ObservableInputTuple<A>, (...values: [T, ...A]) => R]\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/**\n * @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8.\n */\nexport function combineLatest<T, R>(...args: (ObservableInput<any> | ((...values: any[]) => R))[]): OperatorFunction<T, unknown> {\n  const resultSelector = popResultSelector(args);\n  return resultSelector\n    ? pipe(combineLatest(...(args as Array<ObservableInput<any>>)), mapOneOrManyArgs(resultSelector))\n    : operate((source, subscriber) => {\n        combineLatestInit([source, ...argsOrArgArray(args)])(subscriber);\n      });\n}\n","import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { combineLatest } from './combineLatest';\n\n/**\n * Create an observable that combines the latest values from all passed observables and the source\n * into arrays and emits them.\n *\n * Returns an observable, that when subscribed to, will subscribe to the source observable and all\n * sources provided as arguments. Once all sources emit at least one value, all of the latest values\n * will be emitted as an array. After that, every time any source emits a value, all of the latest values\n * will be emitted as an array.\n *\n * This is a useful operator for eagerly calculating values based off of changed inputs.\n *\n * ## Example\n *\n * Simple concatenation of values from two inputs\n *\n * ```ts\n * import { fromEvent, combineLatestWith, map } from 'rxjs';\n *\n * // Setup: Add two inputs to the page\n * const input1 = document.createElement('input');\n * document.body.appendChild(input1);\n * const input2 = document.createElement('input');\n * document.body.appendChild(input2);\n *\n * // Get streams of changes\n * const input1Changes$ = fromEvent(input1, 'change');\n * const input2Changes$ = fromEvent(input2, 'change');\n *\n * // Combine the changes by adding them together\n * input1Changes$.pipe(\n *   combineLatestWith(input2Changes$),\n *   map(([e1, e2]) => (<HTMLInputElement>e1.target).value + ' - ' + (<HTMLInputElement>e2.target).value)\n * )\n * .subscribe(x => console.log(x));\n * ```\n *\n * @param otherSources the other sources to subscribe to.\n * @return A function that returns an Observable that emits the latest\n * emissions from both source and provided Observables.\n */\nexport function combineLatestWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, Cons<T, A>> {\n  return combineLatest(...otherSources);\n}\n","import { mergeMap } from './mergeMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * ![](concatMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMap(ev => interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * values from each projected inner Observable sequentially.\n */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n","import { concatMap } from './concatMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)` */\nexport function concatMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMapTo<O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: undefined\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](concatMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMapTo, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMapTo(interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return A function that returns an Observable of values merged together by\n * joining the passed Observable with itself, one after the other, for each\n * value emitted from the source.\n * @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)`\n */\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? concatMap(() => innerObservable, resultSelector) : concatMap(() => innerObservable);\n}\n","import { ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { concatAll } from './concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * @deprecated Replaced with {@link concatWith}. Will be removed in v8.\n */\nexport function concat<T, R>(...args: any[]): OperatorFunction<T, R> {\n  const scheduler = popScheduler(args);\n  return operate((source, subscriber) => {\n    concatAll()(from([source, ...args], scheduler)).subscribe(subscriber);\n  });\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { concat } from './concat';\n\n/**\n * Emits all of the values from the source observable, then, once it completes, subscribes\n * to each observable source provided, one at a time, emitting all of their values, and not subscribing\n * to the next one until it completes.\n *\n * `concat(a$, b$, c$)` is the same as `a$.pipe(concatWith(b$, c$))`.\n *\n * ## Example\n *\n * Listen for one mouse click, then listen for all mouse moves.\n *\n * ```ts\n * import { fromEvent, map, take, concatWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click');\n * const moves$ = fromEvent(document, 'mousemove');\n *\n * clicks$.pipe(\n *   map(() => 'click'),\n *   take(1),\n *   concatWith(\n *     moves$.pipe(\n *       map(() => 'move')\n *     )\n *   )\n * )\n * .subscribe(x => console.log(x));\n *\n * // 'click'\n * // 'move'\n * // 'move'\n * // 'move'\n * // ...\n * ```\n *\n * @param otherSources Other observable sources to subscribe to, in sequence, after the original source is complete.\n * @return A function that returns an Observable that concatenates\n * subscriptions to the source and provided Observables subscribing to the next\n * only once the current subscription completes.\n */\nexport function concatWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return concat(...otherSources);\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscribable } from '../types';\n\n/**\n * Used to convert a subscribable to an observable.\n *\n * Currently, this is only used within internals.\n *\n * TODO: Discuss ObservableInput supporting \"Subscribable\".\n * https://github.com/ReactiveX/rxjs/issues/5909\n *\n * @param subscribable A subscribable\n */\nexport function fromSubscribable<T>(subscribable: Subscribable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => subscribable.subscribe(subscriber));\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf, SubjectLike } from '../types';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { fromSubscribable } from '../observable/fromSubscribable';\n\n/**\n * An object used to configure {@link connect} operator.\n */\nexport interface ConnectConfig<T> {\n  /**\n   * A factory function used to create the Subject through which the source\n   * is multicast. By default, this creates a {@link Subject}.\n   */\n  connector: () => SubjectLike<T>;\n}\n\n/**\n * The default configuration for `connect`.\n */\nconst DEFAULT_CONFIG: ConnectConfig<unknown> = {\n  connector: () => new Subject<unknown>(),\n};\n\n/**\n * Creates an observable by multicasting the source within a function that\n * allows the developer to define the usage of the multicast prior to connection.\n *\n * This is particularly useful if the observable source you wish to multicast could\n * be synchronous or asynchronous. This sets it apart from {@link share}, which, in the\n * case of totally synchronous sources will fail to share a single subscription with\n * multiple consumers, as by the time the subscription to the result of {@link share}\n * has returned, if the source is synchronous its internal reference count will jump from\n * 0 to 1 back to 0 and reset.\n *\n * To use `connect`, you provide a `selector` function that will give you\n * a multicast observable that is not yet connected. You then use that multicast observable\n * to create a resulting observable that, when subscribed, will set up your multicast. This is\n * generally, but not always, accomplished with {@link merge}.\n *\n * Note that using a {@link takeUntil} inside of `connect`'s `selector` _might_ mean you were looking\n * to use the {@link takeWhile} operator instead.\n *\n * When you subscribe to the result of `connect`, the `selector` function will be called. After\n * the `selector` function returns, the observable it returns will be subscribed to, _then_ the\n * multicast will be connected to the source.\n *\n * ## Example\n *\n * Sharing a totally synchronous observable\n *\n * ```ts\n * import { of, tap, connect, merge, map, filter } from 'rxjs';\n *\n * const source$ = of(1, 2, 3, 4, 5).pipe(\n *   tap({\n *     subscribe: () => console.log('subscription started'),\n *     next: n => console.log(`source emitted ${ n }`)\n *   })\n * );\n *\n * source$.pipe(\n *   // Notice in here we're merging 3 subscriptions to `shared$`.\n *   connect(shared$ => merge(\n *     shared$.pipe(map(n => `all ${ n }`)),\n *     shared$.pipe(filter(n => n % 2 === 0), map(n => `even ${ n }`)),\n *     shared$.pipe(filter(n => n % 2 === 1), map(n => `odd ${ n }`))\n *   ))\n * )\n * .subscribe(console.log);\n *\n * // Expected output: (notice only one subscription)\n * 'subscription started'\n * 'source emitted 1'\n * 'all 1'\n * 'odd 1'\n * 'source emitted 2'\n * 'all 2'\n * 'even 2'\n * 'source emitted 3'\n * 'all 3'\n * 'odd 3'\n * 'source emitted 4'\n * 'all 4'\n * 'even 4'\n * 'source emitted 5'\n * 'all 5'\n * 'odd 5'\n * ```\n *\n * @param selector A function used to set up the multicast. Gives you a multicast observable\n * that is not yet connected. With that, you're expected to create and return\n * and Observable, that when subscribed to, will utilize the multicast observable.\n * After this function is executed -- and its return value subscribed to -- the\n * operator will subscribe to the source, and the connection will be made.\n * @param config The configuration object for `connect`.\n */\nexport function connect<T, O extends ObservableInput<unknown>>(\n  selector: (shared: Observable<T>) => O,\n  config: ConnectConfig<T> = DEFAULT_CONFIG\n): OperatorFunction<T, ObservedValueOf<O>> {\n  const { connector } = config;\n  return operate((source, subscriber) => {\n    const subject = connector();\n    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);\n    subscriber.add(source.subscribe(subject));\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { reduce } from './reduce';\n\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * ![](count.png)\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n *\n * ```ts\n * import { interval, fromEvent, takeUntil, count } from 'rxjs';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n *\n * ```ts\n * import { range, count } from 'rxjs';\n *\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param predicate A function that is used to analyze the value and the index and\n * determine whether or not to increment the count. Return `true` to increment the count,\n * and return `false` to keep the count the same.\n * If the predicate is not provided, every value will be counted.\n * @return A function that returns an Observable that emits one number that\n * represents the count of emissions.\n */\nexport function count<T>(predicate?: (value: T, index: number) => boolean): OperatorFunction<T, number> {\n  return reduce((total, value, i) => (!predicate || predicate(value, i) ? total + 1 : total), 0);\n}\n","import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.svg)\n *\n * `debounce` delays notifications emitted by the source Observable, but drops previous\n * pending delayed emissions if a new notification arrives on the source Observable.\n * This operator keeps track of the most recent notification from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The notification is emitted only when the duration\n * Observable emits a next notification, and if no other notification was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * notification appears before the duration Observable emits, the previous notification will\n * not be emitted and a new duration is scheduled from `durationSelector` is scheduled.\n * If the completing event happens during the scheduled duration the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during the scheduled duration or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, scan, debounce, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   scan(i => ++i, 1),\n *   debounce(i => interval(200 * i))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n */\nexport function debounce<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    // The subscriber/subscription for the current debounce, if there is one.\n    let durationSubscriber: Subscriber<any> | null = null;\n\n    const emit = () => {\n      // Unsubscribe any current debounce subscription we have,\n      // we only cared about the first notification from it, and we\n      // want to clean that subscription up as soon as possible.\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        // We have a value! Free up memory first, then emit the value.\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Cancel any pending debounce duration. We don't\n          // need to null it out here yet tho, because we're just going\n          // to create another one in a few lines.\n          durationSubscriber?.unsubscribe();\n          hasValue = true;\n          lastValue = value;\n          // Capture our duration subscriber, so we can unsubscribe it when we're notified\n          // and we're going to emit the value.\n          durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);\n          // Subscribe to the duration.\n          innerFrom(durationSelector(value)).subscribe(durationSubscriber);\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = durationSubscriber = null;\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent notification from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays notifications emitted by the source Observable, but drops\n * previous pending delayed emissions if a new notification arrives on the source\n * Observable. This operator keeps track of the most recent notification from the\n * source Observable, and emits that only when `dueTime` has passed\n * without any other notification appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous notification will be dropped\n * and will not be emitted and a new `dueTime` is scheduled.\n * If the completing event happens during `dueTime` the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during `dueTime` or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * notification to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, debounceTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified `dueTime`, and may drop some values\n * if they occur too frequently.\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let activeTask: Subscription | null = null;\n    let lastValue: T | null = null;\n    let lastTime: number | null = null;\n\n    const emit = () => {\n      if (activeTask) {\n        // We have a value! Free up memory first, then emit the value.\n        activeTask.unsubscribe();\n        activeTask = null;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\n      // This is called `dueTime` after the first value\n      // but we might have received new values during this window!\n\n      const targetTime = lastTime! + dueTime;\n      const now = scheduler.now();\n      if (now < targetTime) {\n        // On that case, re-schedule to the new target\n        activeTask = this.schedule(undefined, targetTime - now);\n        subscriber.add(activeTask);\n        return;\n      }\n\n      emit();\n    }\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          lastValue = value;\n          lastTime = scheduler.now();\n\n          // Only set up a task if it's not already up\n          if (!activeTask) {\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n            subscriber.add(activeTask);\n          }\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = activeTask = null;\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n *\n * If no clicks happen in 5 seconds, then emit 'no clicks'\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, defaultIfEmpty } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param defaultValue The default value used if the source\n * Observable is empty.\n * @return A function that returns an Observable that emits either the\n * specified `defaultValue` if the source Observable emits no items, or the\n * values emitted by the source Observable.\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => {\n          if (!hasValue) {\n            subscriber.next(defaultValue!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n *\n * Take the first 5 seconds of an infinite 1-second interval Observable\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of `next` values to emit.\n * @return A function that returns an Observable that emits only the first\n * `count` values emitted by the source Observable, or all of the values from\n * the source if the source emits fewer than `count` values.\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? // If we are taking no values, that's empty.\n      () => EMPTY\n    : operate((source, subscriber) => {\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Increment the number of values we have seen,\n            // then check it against the allowed count to see\n            // if we are still letting values through.\n            if (++seen <= count) {\n              subscriber.next(value);\n              // If we have met or passed our allowed count,\n              // we need to complete. We have to do <= here,\n              // because re-entrant code will increment `seen` twice.\n              if (count <= seen) {\n                subscriber.complete();\n              }\n            }\n          })\n        );\n      });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * The `ignoreElements` operator suppresses all items emitted by the source Observable,\n * but allows its termination notification (either `error` or `complete`) to pass through unchanged.\n *\n * If you do not care about the items being emitted by an Observable, but you do want to be notified\n * when it completes or when it terminates with an error, you can apply the `ignoreElements` operator\n * to the Observable, which will ensure that it will never call its observers’ `next` handlers.\n *\n * ## Example\n *\n * Ignore all `next` emissions from the source\n *\n * ```ts\n * import { of, ignoreElements } from 'rxjs';\n *\n * of('you', 'talking', 'to', 'me')\n *   .pipe(ignoreElements())\n *   .subscribe({\n *     next: word => console.log(word),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // result:\n * // 'the end'\n * ```\n *\n * @return A function that returns an empty Observable that only calls\n * `complete` or `error`, based on which one is called by the source\n * Observable.\n */\nexport function ignoreElements(): OperatorFunction<unknown, never> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, noop));\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { map } from './map';\n\n/** @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`. */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R>;\n/**\n * @deprecated Do not specify explicit type parameters. Signatures with type parameters\n * that cannot be inferred will be removed in v8. `mapTo` itself will be removed in v9,\n * use {@link map} instead: `map(() => value)`.\n * */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R>;\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n *\n * Map every click to the string `'Hi'`\n *\n * ```ts\n * import { fromEvent, mapTo } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n *\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param value The value to map each source value to.\n * @return A function that returns an Observable that emits the given `value`\n * every time the source Observable emits.\n * @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`.\n */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R> {\n  return map(() => value);\n}\n","import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { concat } from '../observable/concat';\nimport { take } from './take';\nimport { ignoreElements } from './ignoreElements';\nimport { mapTo } from './mapTo';\nimport { mergeMap } from './mergeMap';\nimport { innerFrom } from '../observable/innerFrom';\n\n/** @deprecated The `subscriptionDelay` parameter will be removed in v8. */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay: Observable<any>\n): MonoTypeOperatorFunction<T>;\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => ObservableInput<any>): MonoTypeOperatorFunction<T>;\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * ![](delayWhen.png)\n *\n * `delayWhen` operator shifts each emitted value from the source Observable by\n * a time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the value emitted from\n * the source Observable as the first argument to the `delayDurationSelector`.\n * The `delayDurationSelector` function should return an {@link ObservableInput},\n * that is internally converted to an Observable that is called the \"duration\"\n * Observable.\n *\n * The source value is emitted on the output Observable only when the \"duration\"\n * Observable emits ({@link guide/glossary-and-semantics#next next}s) any value.\n * Upon that, the \"duration\" Observable gets unsubscribed.\n *\n * Before RxJS V7, the {@link guide/glossary-and-semantics#complete completion}\n * of the \"duration\" Observable would have been triggering the emission of the\n * source value to the output Observable, but with RxJS V7, this is not the case\n * anymore.\n *\n * Only next notifications (from the \"duration\" Observable) trigger values from\n * the source Observable to be passed to the output Observable. If the \"duration\"\n * Observable only emits the complete notification (without next), the value\n * emitted by the source Observable will never get to the output Observable - it\n * will be swallowed. If the \"duration\" Observable errors, the error will be\n * propagated to the output Observable.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * ## Example\n *\n * Delay each click by a random amount of time, between 0 and 5 seconds\n *\n * ```ts\n * import { fromEvent, delayWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(\n *   delayWhen(() => interval(Math.random() * 5000))\n * );\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delay}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param delayDurationSelector A function that returns an `ObservableInput` for\n * each `value` emitted by the source Observable, which is then used to delay the\n * emission of that `value` on the output Observable until the `ObservableInput`\n * returned from this function emits a next value. When called, beside `value`,\n * this function receives a zero-based `index` of the emission order.\n * @param subscriptionDelay An Observable that triggers the subscription to the\n * source Observable once it emits any value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by an amount of time specified by the Observable\n * returned by `delayDurationSelector`.\n */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay?: Observable<any>\n): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n  }\n\n  return mergeMap((value, index) => innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)));\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { delayWhen } from './delayWhen';\nimport { timer } from '../observable/timer';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.svg)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n *\n * Delay each click by one second\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delayWhen}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param {number|Date} due The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the time-shift for each item.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified timeout or Date.\n */\nexport function delay<T>(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  const duration = timer(due, scheduler);\n  return delayWhen(() => duration);\n}\n","import { observeNotification } from '../Notification';\nimport { OperatorFunction, ObservableNotification, ValueFromNotification } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Converts an Observable of {@link ObservableNotification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link ObservableNotification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * ![](dematerialize.png)\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link ObservableNotification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n *\n * Convert an Observable of Notifications to an actual Observable\n *\n * ```ts\n * import { NextNotification, ErrorNotification, of, dematerialize } from 'rxjs';\n *\n * const notifA: NextNotification<string> = { kind: 'N', value: 'A' };\n * const notifB: NextNotification<string> = { kind: 'N', value: 'B' };\n * const notifE: ErrorNotification = { kind: 'E', error: new TypeError('x.toUpperCase is not a function') };\n *\n * const materialized = of(notifA, notifB, notifE);\n *\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe({\n *   next: x => console.log(x),\n *   error: e => console.error(e)\n * });\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link materialize}\n *\n * @return A function that returns an Observable that emits items and\n * notifications embedded in Notification objects emitted by the source\n * Observable.\n */\nexport function dematerialize<N extends ObservableNotification<any>>(): OperatorFunction<N, ValueFromNotification<N>> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, (notification) => observeNotification(notification, subscriber)));\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a `keySelector` function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If the `keySelector` function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n *\n * A simple example with numbers\n *\n * ```ts\n * import { of, distinct } from 'rxjs';\n *\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .pipe(distinct())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * An example using the `keySelector` function\n *\n * ```ts\n * import { of, distinct } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo'},\n *   { age: 7, name: 'Bar'},\n *   { age: 5, name: 'Foo'}\n * )\n * .pipe(distinct(({ name }) => name))\n * .subscribe(x => console.log(x));\n *\n * // Outputs\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param keySelector Optional `function` to select which value you want to check as distinct.\n * @param flushes Optional `ObservableInput` for flushing the internal HashSet of the operator.\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinct<T, K>(keySelector?: (value: T) => K, flushes?: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    const distinctKeys = new Set();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const key = keySelector ? keySelector(value) : value;\n        if (!distinctKeys.has(key)) {\n          distinctKeys.add(key);\n          subscriber.next(value);\n        }\n      })\n    );\n\n    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, () => distinctKeys.clear(), noop));\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(\n  comparator: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a result {@link Observable} that emits all values pushed by the source observable if they\n * are distinct in comparison to the last value the result observable emitted.\n *\n * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),\n * it behaves like this:\n *\n * 1. It will always emit the first value from the source.\n * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values\n *    using the provided `comparator` or an `===` equality check.\n * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and\n *    becomes the new \"previously emitted value\" internally.\n *\n * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior\n * changes:\n *\n * 1. It will always emit the first value from the source.\n * 2. The `keySelector` will be run against all values, including the first value.\n * 3. For all values after the first, the selected key will be compared against the key selected from\n *    the previously emitted value using the `comparator`.\n * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted\n *    and the selected key from that value is saved for future comparisons against other keys.\n *\n * ## Examples\n *\n * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,\n * because it's distinct in comparison to the _previously emitted_ value,\n * not in comparison to _all other emitted values_.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)\n *   .pipe(distinctUntilChanged())\n *   .subscribe(console.log);\n * // Logs: 1, 2, 1, 3\n * ```\n *\n * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say\n * you only want to emit a value when all of its components have\n * changed:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const totallyDifferentBuilds$ = of(\n *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },\n *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },\n *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ).pipe(\n *   distinctUntilChanged((prev, curr) => {\n *     return (\n *       prev.engineVersion === curr.engineVersion ||\n *       prev.transmissionVersion === curr.transmissionVersion\n *     );\n *   })\n * );\n *\n * totallyDifferentBuilds$.subscribe(console.log);\n *\n * // Logs:\n * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }\n * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }\n * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ```\n *\n * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted\n * changes are only in one direction. Let's say you only want to get\n * the next record temperature:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);\n *\n * const recordHighs$ = temps$.pipe(\n *   distinctUntilChanged((prevHigh, temp) => {\n *     // If the current temp is less than\n *     // or the same as the previous record,\n *     // the record hasn't changed.\n *     return temp <= prevHigh;\n *   })\n * );\n *\n * recordHighs$.subscribe(console.log);\n * // Logs: 30, 31, 34, 35\n * ```\n *\n * Selecting update events only when the `updatedBy` field shows\n * the account changed hands.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * // A stream of updates to a given account\n * const accountUpdates$ = of(\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'blesh', data: [] }\n * );\n *\n * // We only want the events where it changed hands\n * const changedHands$ = accountUpdates$.pipe(\n *   distinctUntilChanged(undefined, update => update.updatedBy)\n * );\n *\n * changedHands$.subscribe(console.log);\n * // Logs:\n * // { updatedBy: 'blesh', data: Array[0] }\n * // { updatedBy: 'ncjamieson', data: Array[0] }\n * // { updatedBy: 'blesh', data: Array[0] }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param comparator A function used to compare the previous and current keys for\n * equality. Defaults to a `===` check.\n * @param keySelector Used to select a key value to be passed to the `comparator`.\n *\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinctUntilChanged<T, K>(\n  comparator?: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K = identity as (value: T) => K\n): MonoTypeOperatorFunction<T> {\n  // We've been allowing `null` do be passed as the `compare`, so we can't do\n  // a default value for the parameter, because that will only work\n  // for `undefined`.\n  comparator = comparator ?? defaultCompare;\n\n  return operate((source, subscriber) => {\n    // The previous key, used to compare against keys selected\n    // from new arrivals to determine \"distinctiveness\".\n    let previousKey: K;\n    // Whether or not this is the first value we've gotten.\n    let first = true;\n\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        // We always call the key selector.\n        const currentKey = keySelector(value);\n\n        // If it's the first value, we always emit it.\n        // Otherwise, we compare this key to the previous key, and\n        // if the comparer returns false, we emit.\n        if (first || !comparator!(previousKey, currentKey)) {\n          // Update our state *before* we emit the value\n          // as emission can be the source of re-entrant code\n          // in functional libraries like this. We only really\n          // need to do this if it's the first value, or if the\n          // key we're tracking in previous needs to change.\n          first = false;\n          previousKey = currentKey;\n\n          // Emit the value!\n          subscriber.next(value);\n        }\n      })\n    );\n  });\n}\n\nfunction defaultCompare(a: any, b: any) {\n  return a === b;\n}\n","import { distinctUntilChanged } from './distinctUntilChanged';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Examples\n *\n * An example comparing the name of persons\n *\n * ```ts\n * import { of, distinctUntilKeyChanged } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo' },\n *   { age: 7, name: 'Bar' },\n *   { age: 5, name: 'Foo' },\n *   { age: 6, name: 'Foo' }\n * ).pipe(\n *   distinctUntilKeyChanged('name')\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * An example comparing the first letters of the name\n *\n * ```ts\n * import { of, distinctUntilKeyChanged } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo1' },\n *   { age: 7, name: 'Bar' },\n *   { age: 5, name: 'Foo2' },\n *   { age: 6, name: 'Foo3' }\n * ).pipe(\n *   distinctUntilKeyChanged('name', (x, y) => x.substring(0, 3) === y.substring(0, 3))\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values based on the key specified.\n */\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare?: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T> {\n  return distinctUntilChanged((x: T, y: T) => compare ? compare(x[key], y[key]) : x[key] === y[key]);\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n *\n * Throw an error if the document wasn't clicked within 1 second\n *\n * ```ts\n * import { fromEvent, takeUntil, timer, throwIfEmpty } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(() => new Error('The document was not clicked within 1 second'))\n * )\n * .subscribe({\n *   next() {\n *    console.log('The document was clicked');\n *   },\n *   error(err) {\n *     console.error(err.message);\n *   }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n * @return A function that returns an Observable that throws an error if the\n * source Observable completed without emitting.\n */\nexport function throwIfEmpty<T>(errorFactory: () => any = defaultErrorFactory): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))\n      )\n    );\n  });\n}\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n","import { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { filter } from './filter';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { take } from './take';\n\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * ![](elementAt.png)\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * ## Example\n *\n * Emit only the third click event\n *\n * ```ts\n * import { fromEvent, elementAt } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(elementAt(2));\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n * ```\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOfRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return A function that returns an Observable that emits a single item, if\n * it is found. Otherwise, it will emit the default value if given. If not, it\n * emits an error.\n */\nexport function elementAt<T, D = T>(index: number, defaultValue?: D): OperatorFunction<T, T | D> {\n  if (index < 0) {\n    throw new ArgumentOutOfRangeError();\n  }\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      filter((v, i) => i === index),\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new ArgumentOutOfRangeError())\n    );\n}\n","/** prettier */\nimport { Observable } from '../Observable';\nimport { concat } from '../observable/concat';\nimport { of } from '../observable/of';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ValueFromArray } from '../types';\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function endWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function endWith<T, A extends unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\n\nexport function endWith<T, A extends unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that will emit all values from the source, then synchronously emit\n * the provided value(s) immediately after the source completes.\n *\n * NOTE: Passing a last argument of a Scheduler is _deprecated_, and may result in incorrect\n * types in TypeScript.\n *\n * This is useful for knowing when an observable ends. Particularly when paired with an\n * operator like {@link takeUntil}\n *\n * ![](endWith.png)\n *\n * ## Example\n *\n * Emit values to know when an interval starts and stops. The interval will\n * stop when a user clicks anywhere on the document.\n *\n * ```ts\n * import { interval, map, fromEvent, startWith, takeUntil, endWith } from 'rxjs';\n *\n * const ticker$ = interval(5000).pipe(\n *   map(() => 'tick')\n * );\n *\n * const documentClicks$ = fromEvent(document, 'click');\n *\n * ticker$.pipe(\n *   startWith('interval started'),\n *   takeUntil(documentClicks$),\n *   endWith('interval ended by click')\n * )\n * .subscribe(x => console.log(x));\n *\n * // Result (assuming a user clicks after 15 seconds)\n * // 'interval started'\n * // 'tick'\n * // 'tick'\n * // 'tick'\n * // 'interval ended by click'\n * ```\n *\n * @see {@link startWith}\n * @see {@link concat}\n * @see {@link takeUntil}\n *\n * @param values Items you want the modified Observable to emit last.\n * @return A function that returns an Observable that emits all values from the\n * source, then synchronously emits the provided value(s) immediately after the\n * source completes.\n */\nexport function endWith<T>(...values: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => concat(source, of(...values)) as Observable<T>;\n}\n","import { Observable } from '../Observable';\nimport { Falsy, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function every<T>(predicate: BooleanConstructor): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function every<T>(\n  predicate: BooleanConstructor,\n  thisArg: any\n): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function every<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, boolean>;\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, boolean>;\n\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * <span class=\"informal\">If all values pass predicate before the source completes, emits true before completion,\n * otherwise emit false, then complete.</span>\n *\n * ![](every.png)\n *\n * ## Example\n *\n * A simple example emitting true if all elements are less than 5, false otherwise\n *\n * ```ts\n * import { of, every } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5, 6)\n *   .pipe(every(x => x < 5))\n *   .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return A function that returns an Observable of booleans that determines if\n * all items of the source Observable meet the condition specified.\n */\nexport function every<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          if (!predicate.call(thisArg, value, index++, source)) {\n            subscriber.next(false);\n            subscriber.complete();\n          }\n        },\n        () => {\n          subscriber.next(true);\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function exhaustMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function exhaustMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaustAll}.</span>\n *\n * ![](exhaustMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * ## Example\n *\n * Run a finite timer for each click, only if there is no currently active timer\n *\n * ```ts\n * import { fromEvent, exhaustMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   exhaustMap(() => interval(1000).pipe(take(5)))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable containing projected\n * Observables of each item of the source, ignoring projected Observables that\n * start before their preceding Observable has completed.\n */\nexport function exhaustMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      source.pipe(exhaustMap((a, i) => innerFrom(project(a, i)).pipe(map((b: any, ii: any) => resultSelector(a, b, i, ii)))));\n  }\n  return operate((source, subscriber) => {\n    let index = 0;\n    let innerSub: Subscriber<T> | null = null;\n    let isComplete = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (outerValue) => {\n          if (!innerSub) {\n            innerSub = createOperatorSubscriber(subscriber, undefined, () => {\n              innerSub = null;\n              isComplete && subscriber.complete();\n            });\n            innerFrom(project(outerValue, index++)).subscribe(innerSub);\n          }\n        },\n        () => {\n          isComplete = true;\n          !innerSub && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { exhaustMap } from './exhaustMap';\nimport { identity } from '../util/identity';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * ![](exhaustAll.svg)\n *\n * `exhaustAll` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaustAll` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * ## Example\n *\n * Run a finite timer for each click, only if there is no currently active timer\n *\n * ```ts\n * import { fromEvent, map, interval, take, exhaustAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(5)))\n * );\n * const result = higherOrder.pipe(exhaustAll());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable that takes a source of\n * Observables and propagates the first Observable exclusively until it\n * completes before subscribing to the next.\n */\nexport function exhaustAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return exhaustMap(identity);\n}\n","import { exhaustAll } from './exhaustAll';\n\n/**\n * @deprecated Renamed to {@link exhaustAll}. Will be removed in v8.\n */\nexport const exhaust = exhaustAll;\n","import { OperatorFunction, ObservableInput, ObservedValueOf, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/* tslint:disable:max-line-length */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. If you need to schedule the inner subscription,\n * use `subscribeOn` within the projection function: `expand((value) => fn(value).pipe(subscribeOn(scheduler)))`.\n * Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent: number | undefined,\n  scheduler: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * ![](expand.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * ## Example\n *\n * Start emitting the powers of two on every click, at most 10 of them\n *\n * ```ts\n * import { fromEvent, map, expand, of, delay, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const powersOfTwo = clicks.pipe(\n *   map(() => 1),\n *   expand(x => of(2 * x).pipe(delay(1000))),\n *   take(10)\n * );\n * powersOfTwo.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each projected inner Observable.\n * @return A function that returns an Observable that emits the source values\n * and also result of applying the projection function to each value emitted on\n * the output Observable and merging the results of the Observables obtained\n * from this transformation.\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent = Infinity,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>> {\n  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;\n  return operate((source, subscriber) =>\n    mergeInternals(\n      // General merge params\n      source,\n      subscriber,\n      project,\n      concurrent,\n\n      // onBeforeNext\n      undefined,\n\n      // Expand-specific\n      true, // Use expand path\n      scheduler // Inner subscription scheduler\n    )\n  );\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * The specified function will also be called when the subscriber explicitly unsubscribes.\n *\n * ## Examples\n *\n * Execute callback function when the observable completes\n *\n * ```ts\n * import { interval, take, finalize } from 'rxjs';\n *\n * // emit value in sequence every 1 second\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(5), //take only the first 5 values\n *   finalize(() => console.log('Sequence complete')) // Execute when the observable completes\n * );\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 'Sequence complete'\n * ```\n *\n * Execute callback function when the subscriber explicitly unsubscribes\n *\n * ```ts\n * import { interval, finalize, tap, noop, timer } from 'rxjs';\n *\n * const source = interval(100).pipe(\n *   finalize(() => console.log('[finalize] Called')),\n *   tap({\n *     next: () => console.log('[next] Called'),\n *     error: () => console.log('[error] Not called'),\n *     complete: () => console.log('[tap complete] Not called')\n *   })\n * );\n *\n * const sub = source.subscribe({\n *   next: x => console.log(x),\n *   error: noop,\n *   complete: () => console.log('[complete] Not called')\n * });\n *\n * timer(150).subscribe(() => sub.unsubscribe());\n *\n * // results:\n * // '[next] Called'\n * // 0\n * // '[finalize] Called'\n * ```\n *\n * @param {function} callback Function to be called when source terminates.\n * @return A function that returns an Observable that mirrors the source, but\n * will call the specified function on termination.\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // TODO: This try/finally was only added for `useDeprecatedSynchronousErrorHandling`.\n    // REMOVE THIS WHEN THAT HOT GARBAGE IS REMOVED IN V8.\n    try {\n      source.subscribe(subscriber);\n    } finally {\n      subscriber.add(callback);\n    }\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function find<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function find<T, S extends T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => value is S,\n  thisArg: A\n): OperatorFunction<T, S | undefined>;\nexport function find<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S\n): OperatorFunction<T, S | undefined>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function find<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, T | undefined>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, T | undefined>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * ![](find.png)\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found\n * (emits `undefined` instead).\n *\n * ## Example\n *\n * Find and emit the first click that happens on a DIV element\n *\n * ```ts\n * import { fromEvent, find } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(find(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function find<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, T | undefined> {\n  return operate(createFind(predicate, thisArg, 'value'));\n}\n\nexport function createFind<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: any,\n  emit: 'value' | 'index'\n) {\n  const findIndex = emit === 'index';\n  return (source: Observable<T>, subscriber: Subscriber<any>) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          const i = index++;\n          if (predicate.call(thisArg, value, i, source)) {\n            subscriber.next(findIndex ? i : value);\n            subscriber.complete();\n          }\n        },\n        () => {\n          subscriber.next(findIndex ? -1 : undefined);\n          subscriber.complete();\n        }\n      )\n    );\n  };\n}\n","import { Observable } from '../Observable';\nimport { Falsy, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createFind } from './find';\n\nexport function findIndex<T>(predicate: BooleanConstructor): OperatorFunction<T, T extends Falsy ? -1 : number>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function findIndex<T>(predicate: BooleanConstructor, thisArg: any): OperatorFunction<T, T extends Falsy ? -1 : number>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function findIndex<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, number>;\nexport function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number>;\n\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * ![](findIndex.png)\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * ## Example\n *\n * Emit the index of first click that happens on a DIV element\n *\n * ```ts\n * import { fromEvent, findIndex } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(findIndex(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits the index of the\n * first item that matches the condition.\n */\nexport function findIndex<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, number> {\n  return operate(createFind(predicate, thisArg, 'index'));\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function first<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function first<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function first<T, S extends T, D>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue: D\n): OperatorFunction<T, S | D>;\nexport function first<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. Throws an error if\n * `defaultValue` was not provided and a matching element is not found.\n *\n * ## Examples\n *\n * Emit only the first click that happens on the DOM\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * This is how `first()` is different from {@link take}(1) which completes instead.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {D} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function first<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\n\nexport interface BasicGroupByOptions<K, T> {\n  element?: undefined;\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\n  connector?: () => SubjectLike<T>;\n}\n\nexport interface GroupByOptionsWithElement<K, E, T> {\n  element: (value: T) => E;\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\n  connector?: () => SubjectLike<E>;\n}\n\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\n\nexport function groupBy<T, K, E>(\n  key: (value: T) => K,\n  options: GroupByOptionsWithElement<K, E, T>\n): OperatorFunction<T, GroupedObservable<K, E>>;\n\nexport function groupBy<T, K extends T>(\n  key: (value: T) => value is K\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\n\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K>(\n  key: (value: T) => K,\n  element: void,\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the key function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the `key` field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the element function.\n *\n * ## Examples\n *\n * Group objects by `id` and return as array\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [{ id: 1, name: 'JavaScript' }, { id: 1, name: 'TypeScript'}]\n * // [{ id: 2, name: 'Parcel' }, { id: 2, name: 'webpack'}]\n * // [{ id: 3, name: 'TSLint' }]\n * ```\n *\n * Pivot data on the `id` field\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce, map } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id, { element: p => p.name }),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [`${ group$.key }`]))),\n *   map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param key A function that extracts the key\n * for each item.\n * @param element A function that extracts the\n * return element for each item.\n * @param duration\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @param connector Factory function to create an\n * intermediate Subject through which grouped elements are emitted.\n * @return A function that returns an Observable that emits GroupedObservables,\n * each of which corresponds to a unique key value and each of which emits\n * those items from the source Observable that share that key value.\n *\n * @deprecated Use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  connector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n// Impl\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\n  connector?: () => SubjectLike<any>\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return operate((source, subscriber) => {\n    let element: ((value: any) => any) | void;\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions as ((value: any) => any);\n    } else {\n      ({ duration, element, connector } = elementOrOptions);\n    }\n\n    // A lookup for the groups that we have so far.\n    const groups = new Map<K, SubjectLike<any>>();\n\n    // Used for notifying all groups and the subscriber in the same way.\n    const notify = (cb: (group: Observer<any>) => void) => {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    // Used to handle errors from the source, AND errors that occur during the\n    // next call from the source.\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\n\n    // The number of actively subscribed groups\n    let activeGroups = 0;\n\n    // Whether or not teardown was attempted on this subscription.\n    let teardownAttempted = false;\n\n    // Capturing a reference to this, because we need a handle to it\n    // in `createGroupedObservable` below. This is what we use to\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\n    // in cases where a user unsubscribes from the main resulting subscription, but\n    // still has groups from this subscription subscribed and would expect values from it\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\n    const groupBySourceSubscriber = new OperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Because we have to notify all groups of any errors that occur in here,\n        // we have to add our own try/catch to ensure that those errors are propagated.\n        // OperatorSubscriber will only send the error to the main subscriber.\n        try {\n          const key = keySelector(value);\n\n          let group = groups.get(key);\n          if (!group) {\n            // Create our group subject\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\n\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\n            // because the grouped observable has special semantics around reference counting\n            // to ensure we don't sever our connection to the source prematurely.\n            const grouped = createGroupedObservable(key, group);\n            subscriber.next(grouped);\n\n            if (duration) {\n              const durationSubscriber = createOperatorSubscriber(\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\n                // when the duration subscription is torn down. That is important, because then\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\n                // after the connection to the source has been severed, they will get an\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\n                group as any,\n                () => {\n                  // Our duration notified! We can complete the group.\n                  // The group will be removed from the map in the finalization phase.\n                  group!.complete();\n                  durationSubscriber?.unsubscribe();\n                },\n                // Completions are also sent to the group, but just the group.\n                undefined,\n                // Errors on the duration subscriber are sent to the group\n                // but only the group. They are not sent to the main subscription.\n                undefined,\n                // Finalization: Remove this group from our map.\n                () => groups.delete(key)\n              );\n\n              // Start our duration notifier.\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n            }\n          }\n\n          // Send the value to our group.\n          group.next(element ? element(value) : value);\n        } catch (err) {\n          handleError(err);\n        }\n      },\n      // Source completes.\n      () => notify((consumer) => consumer.complete()),\n      // Error from the source.\n      handleError,\n      // Free up memory.\n      // When the source subscription is _finally_ torn down, release the subjects and keys\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\n      // don't have to.\n      () => groups.clear(),\n      () => {\n        teardownAttempted = true;\n        // We only kill our subscription to the source if we have\n        // no active groups. As stated above, consider this scenario:\n        // source$.pipe(groupBy(fn), take(2)).\n        return activeGroups === 0;\n      }\n    );\n\n    // Subscribe to the source\n    source.subscribe(groupBySourceSubscriber);\n\n    /**\n     * Creates the actual grouped observable returned.\n     * @param key The key of the group\n     * @param groupSubject The subject that fuels the group\n     */\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\n      const result: any = new Observable<T>((groupSubscriber) => {\n        activeGroups++;\n        const innerSub = groupSubject.subscribe(groupSubscriber);\n        return () => {\n          innerSub.unsubscribe();\n          // We can kill the subscription to our source if we now have no more\n          // active groups subscribed, and a finalization was already attempted on\n          // the source.\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\n/**\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\n * contains a `key` property for the grouping.\n */\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  /**\n   * The key value for the grouped notifications.\n   */\n  readonly key: K;\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits `false` if the input Observable emits any values, or emits `true` if the\n * input Observable completes without emitting any values.\n *\n * <span class=\"informal\">Tells whether any values are emitted by an Observable.</span>\n *\n * ![](isEmpty.png)\n *\n * `isEmpty` transforms an Observable that emits values into an Observable that\n * emits a single boolean value representing whether or not any values were\n * emitted by the source Observable. As soon as the source Observable emits a\n * value, `isEmpty` will emit a `false` and complete.  If the source Observable\n * completes having not emitted anything, `isEmpty` will emit a `true` and\n * complete.\n *\n * A similar effect could be achieved with {@link count}, but `isEmpty` can emit\n * a `false` value sooner.\n *\n * ## Examples\n *\n * Emit `false` for a non-empty Observable\n *\n * ```ts\n * import { Subject, isEmpty } from 'rxjs';\n *\n * const source = new Subject<string>();\n * const result = source.pipe(isEmpty());\n *\n * source.subscribe(x => console.log(x));\n * result.subscribe(x => console.log(x));\n *\n * source.next('a');\n * source.next('b');\n * source.next('c');\n * source.complete();\n *\n * // Outputs\n * // 'a'\n * // false\n * // 'b'\n * // 'c'\n * ```\n *\n * Emit `true` for an empty Observable\n *\n * ```ts\n * import { EMPTY, isEmpty } from 'rxjs';\n *\n * const result = EMPTY.pipe(isEmpty());\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // true\n * ```\n *\n * @see {@link count}\n * @see {@link EMPTY}\n *\n * @return A function that returns an Observable that emits boolean value\n * indicating whether the source Observable was empty or not.\n */\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          subscriber.next(false);\n          subscriber.complete();\n        },\n        () => {\n          subscriber.next(true);\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { EMPTY } from '../observable/empty';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Waits for the source to complete, then emits the last N values from the source,\n * as specified by the `count` argument.\n *\n * ![](takeLast.png)\n *\n * `takeLast` results in an observable that will hold values up to `count` values in memory,\n * until the source completes. It then pushes all values in memory to the consumer, in the\n * order they were received from the source, then notifies the consumer that it is\n * complete.\n *\n * If for some reason the source completes before the `count` supplied to `takeLast` is reached,\n * all values received until that point are emitted, and then completion is notified.\n *\n * **Warning**: Using `takeLast` with an observable that never completes will result\n * in an observable that never emits a value.\n *\n * ## Example\n *\n * Take the last 3 values of an Observable with many values\n *\n * ```ts\n * import { range, takeLast } from 'rxjs';\n *\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return A function that returns an Observable that emits at most the last\n * `count` values emitted by the source Observable.\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        // This buffer will hold the values we are going to emit\n        // when the source completes. Since we only want to take the\n        // last N values, we can't emit until we're sure we're not getting\n        // any more values.\n        let buffer: T[] = [];\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              // Add the most recent value onto the end of our buffer.\n              buffer.push(value);\n              // If our buffer is now larger than the number of values we\n              // want to take, we remove the oldest value from the buffer.\n              count < buffer.length && buffer.shift();\n            },\n            () => {\n              // The source completed, we now know what are last values\n              // are, emit them in the order they were received.\n              for (const value of buffer) {\n                subscriber.next(value);\n              }\n              subscriber.complete();\n            },\n            // Errors are passed through to the consumer\n            undefined,\n            () => {\n              // During finalization release the values in our buffer.\n              buffer = null!;\n            }\n          )\n        );\n      });\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function last<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function last<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function last<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function last<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function last<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * ![](last.png)\n *\n * It will throw an error if the source completes without notification or one that matches the predicate. It\n * returns the last value or if a predicate is provided last value that matches the predicate. It returns the\n * given default value if no notification is emitted or matches the predicate.\n *\n * ## Examples\n *\n * Last alphabet from the sequence\n *\n * ```ts\n * import { from, last } from 'rxjs';\n *\n * const source = from(['x', 'y', 'z']);\n * const result = source.pipe(last());\n *\n * result.subscribe(value => console.log(`Last alphabet: ${ value }`));\n *\n * // Outputs\n * // Last alphabet: z\n * ```\n *\n * Default value when the value in the predicate is not matched\n *\n * ```ts\n * import { from, last } from 'rxjs';\n *\n * const source = from(['x', 'y', 'z']);\n * const result = source.pipe(last(char => char === 'a', 'not found'));\n *\n * result.subscribe(value => console.log(`'a' is ${ value }.`));\n *\n * // Outputs\n * // 'a' is not found.\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n * @see {@link skipWhile}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} [predicate] - The condition any source emitted item has to satisfy.\n * @param {any} [defaultValue] - An optional default value to provide if last\n * predicate isn't met or no values were emitted.\n * @return A function that returns an Observable that emits only the last item\n * satisfying the given condition from the source, or a NoSuchElementException\n * if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n */\nexport function last<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      takeLast(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n","import { Notification } from '../Notification';\nimport { OperatorFunction, ObservableNotification } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * ![](materialize.png)\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n *\n * Convert a faulty Observable to an Observable of Notifications\n *\n * ```ts\n * import { of, materialize, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map((x: any) => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n *\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification { kind: 'N', value: 'A', error: undefined, hasValue: true }\n * // - Notification { kind: 'N', value: 'B', error: undefined, hasValue: true }\n * // - Notification { kind: 'E', value: undefined, error: TypeError { message: x.toUpperCase is not a function }, hasValue: false }\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return A function that returns an Observable that emits\n * {@link Notification} objects that wrap the original emissions from the\n * source Observable with metadata.\n */\nexport function materialize<T>(): OperatorFunction<T, Notification<T> & ObservableNotification<T>> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          subscriber.next(Notification.createNext(value));\n        },\n        () => {\n          subscriber.next(Notification.createComplete());\n          subscriber.complete();\n        },\n        (err) => {\n          subscriber.next(Notification.createError(err));\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * ![](max.png)\n *\n * ## Examples\n *\n * Get the maximal value of a series of numbers\n *\n * ```ts\n * import { of, max } from 'rxjs';\n *\n * of(5, 4, 7, 2, 8)\n *   .pipe(max())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 8\n * ```\n *\n * Use a comparer function to get the maximal item\n *\n * ```ts\n * import { of, max } from 'rxjs';\n *\n * of(\n *   { age: 7, name: 'Foo' },\n *   { age: 5, name: 'Bar' },\n *   { age: 9, name: 'Beer' }\n * ).pipe(\n *   max((a, b) => a.age < b.age ? -1 : 1)\n * )\n * .subscribe(x => console.log(x.name));\n *\n * // Outputs\n * // 'Beer'\n * ```\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return A function that returns an Observable that emits item with the\n * largest value.\n */\nexport function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) > 0 ? x : y) : (x, y) => (x > y ? x : y));\n}\n","import { mergeMap } from './mergeMap';\n\n/**\n * @deprecated Renamed to {@link mergeMap}. Will be removed in v8.\n */\nexport const flatMap = mergeMap;\n","import { OperatorFunction, ObservedValueOf, ObservableInput } from '../types';\nimport { mergeMap } from './mergeMap';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)` */\nexport function mergeMapTo<O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  concurrent?: number\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/**\n * @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead.\n * Details: https://rxjs.dev/deprecations/resultSelector\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * ![](mergeMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * ## Example\n *\n * For each click event, start an interval Observable ticking every 1 second\n *\n * ```ts\n * import { fromEvent, mergeMapTo, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(mergeMapTo(interval(1000)));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits items from the\n * given `innerObservable`.\n * @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)`\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    return mergeMap(() => innerObservable, resultSelector, concurrent);\n  }\n  if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return mergeMap(() => innerObservable, concurrent);\n}\n","import { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * The first parameter of the `mergeScan` is an `accumulator` function which is\n * being called every time the source Observable emits a value. `mergeScan` will\n * subscribe to the value returned by the `accumulator` function and will emit\n * values to the subscriber emitted by inner Observable.\n *\n * The `accumulator` function is being called with three parameters passed to it:\n * `acc`, `value` and `index`. The `acc` parameter is used as the state parameter\n * whose value is initially set to the `seed` parameter (the second parameter\n * passed to the `mergeScan` operator).\n *\n * `mergeScan` internally keeps the value of the `acc` parameter: as long as the\n * source Observable emits without inner Observable emitting, the `acc` will be\n * set to `seed`. The next time the inner Observable emits a value, `mergeScan`\n * will internally remember it and it will be passed to the `accumulator`\n * function as `acc` parameter the next time source emits.\n *\n * The `value` parameter of the `accumulator` function is the value emitted by the\n * source Observable, while the `index` is a number which represent the order of the\n * current emission by the source Observable. It starts with 0.\n *\n * The last parameter to the `mergeScan` is the `concurrent` value which defaults\n * to Infinity. It represents the maximum number of inner Observable subscriptions\n * at a time.\n *\n * ## Example\n *\n * Count the number of click events\n *\n * ```ts\n * import { fromEvent, map, mergeScan, of } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(map(() => 1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed)\n * );\n *\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...and so on for each click\n * ```\n *\n * @see {@link scan}\n * @see {@link switchScan}\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Infinity] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return A function that returns an Observable of the accumulated values.\n */\nexport function mergeScan<T, R>(\n  accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n  seed: R,\n  concurrent = Infinity\n): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The accumulated state.\n    let state = seed;\n\n    return mergeInternals(\n      source,\n      subscriber,\n      (value, index) => accumulator(state, value, index),\n      concurrent,\n      (value) => {\n        state = value;\n      },\n      false,\n      undefined,\n      () => (state = null!)\n    );\n  });\n}\n","import { ObservableInput, ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { mergeAll } from './mergeAll';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndConcurrency: [...ObservableInputTuple<A>, number]\n): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\nexport function merge<T>(...args: unknown[]): OperatorFunction<T, unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  args = argsOrArgArray(args);\n\n  return operate((source, subscriber) => {\n    mergeAll(concurrent)(from([source, ...(args as ObservableInput<T>[])], scheduler)).subscribe(subscriber);\n  });\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { merge } from './merge';\n\n/**\n * Merge the values from all observables to a single observable result.\n *\n * Creates an observable, that when subscribed to, subscribes to the source\n * observable, and all other sources provided as arguments. All values from\n * every source are emitted from the resulting subscription.\n *\n * When all sources complete, the resulting observable will complete.\n *\n * When any source errors, the resulting observable will error.\n *\n * ## Example\n *\n * Joining all outputs from multiple user input event streams\n *\n * ```ts\n * import { fromEvent, map, mergeWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click').pipe(map(() => 'click'));\n * const mousemoves$ = fromEvent(document, 'mousemove').pipe(map(() => 'mousemove'));\n * const dblclicks$ = fromEvent(document, 'dblclick').pipe(map(() => 'dblclick'));\n *\n * mousemoves$\n *   .pipe(mergeWith(clicks$, dblclicks$))\n *   .subscribe(x => console.log(x));\n *\n * // result (assuming user interactions)\n * // 'mousemove'\n * // 'mousemove'\n * // 'mousemove'\n * // 'click'\n * // 'click'\n * // 'dblclick'\n * ```\n *\n * @see {@link merge}\n *\n * @param otherSources the sources to combine the current source with.\n * @return A function that returns an Observable that merges the values from\n * all given Observables.\n */\nexport function mergeWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return merge(...otherSources);\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * ![](min.png)\n *\n * ## Examples\n *\n * Get the minimal value of a series of numbers\n *\n * ```ts\n * import { of, min } from 'rxjs';\n *\n * of(5, 4, 7, 2, 8)\n *   .pipe(min())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 2\n * ```\n *\n * Use a comparer function to get the minimal item\n *\n * ```ts\n * import { of, min } from 'rxjs';\n *\n * of(\n *   { age: 7, name: 'Foo' },\n *   { age: 5, name: 'Bar' },\n *   { age: 9, name: 'Beer' }\n * ).pipe(\n *   min((a, b) => a.age < b.age ? -1 : 1)\n * )\n * .subscribe(x => console.log(x.name));\n *\n * // Outputs\n * // 'Bar'\n * ```\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return A function that returns an Observable that emits item with the\n * smallest value.\n */\nexport function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) < 0 ? x : y) : (x, y) => (x < y ? x : y));\n}\n","import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { connect } from './connect';\n\n/**\n * An operator that creates a {@link ConnectableObservable}, that when connected,\n * with the `connect` method, will use the provided subject to multicast the values\n * from the source to all consumers.\n *\n * @param subject The subject to multicast through.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\n * `multicast(subject), refCount()` is equivalent to\n * `share({ connector: () => subject, resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\n * {@link connect} operator.\n *\n * @param subject The subject used to multicast.\n * @param selector A setup function to setup the multicast\n * @return A function that returns an observable that mirrors the observable returned by the selector.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `multicast(subject, selector)` is equivalent to\n * `connect(selector, { connector: () => subject })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, O extends ObservableInput<any>>(\n  subject: Subject<T>,\n  selector: (shared: Observable<T>) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * An operator that creates a {@link ConnectableObservable}, that when connected,\n * with the `connect` method, will use the provided subject to multicast the values\n * from the source to all consumers.\n *\n * @param subjectFactory A factory that will be called to create the subject. Passing a function here\n * will cause the underlying subject to be \"reset\" on error, completion, or refCounted unsubscription of\n * the source.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\n * `multicast(() => new BehaviorSubject('test')), refCount()` is equivalent to\n * `share({ connector: () => new BehaviorSubject('test') })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T>(subjectFactory: () => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\n * {@link connect} operator.\n *\n * @param subjectFactory A factory that creates the subject used to multicast.\n * @param selector A function to setup the multicast and select the output.\n * @return A function that returns an observable that mirrors the observable returned by the selector.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `multicast(subjectFactory, selector)` is equivalent to\n * `connect(selector, { connector: subjectFactory })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, O extends ObservableInput<any>>(\n  subjectFactory: () => Subject<T>,\n  selector: (shared: Observable<T>) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, R>(\n  subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n  selector?: (source: Observable<T>) => Observable<R>\n): OperatorFunction<T, R> {\n  const subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : () => subjectOrSubjectFactory;\n\n  if (isFunction(selector)) {\n    // If a selector function is provided, then we're a \"normal\" operator that isn't\n    // going to return a ConnectableObservable. We can use `connect` to do what we\n    // need to do.\n    return connect(selector, {\n      connector: subjectFactory,\n    });\n  }\n\n  return (source: Observable<T>) => new ConnectableObservable<any>(source, subjectFactory);\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { onErrorResumeNext as oERNCreate } from '../observable/onErrorResumeNext';\n\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  ...sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables, subscribes to next one on error or complete.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\n *\n *\n * ## Example\n *\n * Subscribe to the next Observable after map fails\n *\n * ```ts\n * import { of, onErrorResumeNext, map } from 'rxjs';\n *\n * of(1, 2, 3, 0)\n *   .pipe(\n *     map(x => {\n *       if (x === 0) {\n *         throw Error();\n *       }\n *\n *       return 10 / x;\n *     }),\n *     onErrorResumeNext(of(1, 2, 3))\n *   )\n *   .subscribe({\n *     next: val => console.log(val),\n *     error: err => console.log(err),          // Will never be called.\n *     complete: () => console.log('that\\'s it!')\n *   });\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // 'that's it!'\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} sources Observables passed either directly or as an array.\n * @return A function that returns an Observable that emits values from source\n * Observable, but - if it errors - subscribes to the next passed Observable\n * and so on, until it completes or runs out of Observables.\n */\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  // For some reason, TS 4.1 RC gets the inference wrong here and infers the\n  // result to be `A[number][]` - completely dropping the ObservableInput part\n  // of the type. This makes no sense whatsoever. As a workaround, the type is\n  // asserted explicitly.\n  const nextSources = argsOrArgArray(sources) as unknown as ObservableInputTuple<A>;\n\n  return (source) => oERNCreate(source, ...nextSources);\n}\n\n/**\n * @deprecated Renamed. Use {@link onErrorResumeNextWith} instead. Will be removed in v8.\n */\nexport const onErrorResumeNext = onErrorResumeNextWith;\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n *\n * On every click (starting from the second), emit the relative distance to the previous click\n *\n * ```ts\n * import { fromEvent, pairwise, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(([first, second]) => {\n *     const x0 = first.clientX;\n *     const y0 = first.clientY;\n *     const x1 = second.clientX;\n *     const y1 = second.clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   })\n * );\n *\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return A function that returns an Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return operate((source, subscriber) => {\n    let prev: T;\n    let hasPrev = false;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const p = prev;\n        prev = value;\n        hasPrev && subscriber.next([p, value]);\n        hasPrev = true;\n      })\n    );\n  });\n}\n","import { map } from './map';\nimport { OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  k1: K1,\n  k2: K2,\n  k3: K3\n): OperatorFunction<T, T[K1][K2][K3]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(\n  k1: K1,\n  k2: K2,\n  k3: K3,\n  k4: K4\n): OperatorFunction<T, T[K1][K2][K3][K4]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6, ...rest: string[]): OperatorFunction<T, unknown>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T>(...properties: string[]): OperatorFunction<T, unknown>;\n/* tslint:enable:max-line-length */\n\n/**\n * Maps each source value to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted value.</span>\n *\n * ![](pluck.png)\n *\n * Given a list of strings or numbers describing a path to a property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * ## Example\n *\n * Map every click to the tagName of the clicked target element\n *\n * ```ts\n * import { fromEvent, pluck } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\n *\n * tagNames.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param properties The nested properties to pluck from each source\n * value.\n * @return A function that returns an Observable of property values from the\n * source values.\n * @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8.\n */\nexport function pluck<T, R>(...properties: Array<string | number | symbol>): OperatorFunction<T, R> {\n  const length = properties.length;\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n  return map((x) => {\n    let currentProp: any = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp?.[properties[i]];\n      if (typeof p !== 'undefined') {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { connect } from './connect';\n\n/**\n * Returns a connectable observable that, when connected, will multicast\n * all values through a single underlying {@link Subject} instance.\n *\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * `source.pipe(publish())` is equivalent to\n * `connectable(source, { connector: () => new Subject(), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publish`, use {@link share} operator instead.\n * `source.pipe(publish(), refCount())` is equivalent to\n * `source.pipe(share({ resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Returns an observable, that when subscribed to, creates an underlying {@link Subject},\n * provides an observable view of it to a `selector` function, takes the observable result of\n * that selector function and subscribes to it, sending its values to the consumer, _then_ connects\n * the subject to the original source.\n *\n * @param selector A function used to setup multicasting prior to automatic connection.\n *\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `publish(selector)` is equivalent to `connect(selector)`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T, O extends ObservableInput<any>>(selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <span class=\"informal\">Makes a cold Observable hot</span>\n *\n * ![](publish.png)\n *\n * ## Examples\n *\n * Make `source$` hot by applying `publish` operator, then merge each inner observable into a single one\n * and subscribe\n *\n * ```ts\n * import { zip, interval, of, map, publish, merge, tap } from 'rxjs';\n *\n * const source$ = zip(interval(2000), of(1, 2, 3, 4, 5, 6, 7, 8, 9))\n *   .pipe(map(([, number]) => number));\n *\n * source$\n *   .pipe(\n *     publish(multicasted$ =>\n *       merge(\n *         multicasted$.pipe(tap(x => console.log('Stream 1:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 2:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 3:', x)))\n *       )\n *     )\n *   )\n *   .subscribe();\n *\n * // Results every two seconds\n * // Stream 1: 1\n * // Stream 2: 1\n * // Stream 3: 1\n * // ...\n * // Stream 1: 9\n * // Stream 2: 9\n * // Stream 3: 9\n * ```\n *\n * @see {@link publishLast}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A function that returns a ConnectableObservable that upon connection\n * causes the source Observable to emit items to its Observers.\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T, R>(selector?: OperatorFunction<T, R>): MonoTypeOperatorFunction<T> | OperatorFunction<T, R> {\n  return selector ? (source) => connect(selector)(source) : (source) => multicast(new Subject<T>())(source);\n}\n","import { Observable } from '../Observable';\nimport { BehaviorSubject } from '../BehaviorSubject';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Creates a {@link ConnectableObservable} that utilizes a {@link BehaviorSubject}.\n *\n * @param initialValue The initial value passed to the {@link BehaviorSubject}.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link BehaviorSubject} under the hood, use {@link connectable}.\n * `source.pipe(publishBehavior(initValue))` is equivalent to\n * `connectable(source, { connector: () => new BehaviorSubject(initValue), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishBehavior`, use the {@link share} operator instead.\n * `source.pipe(publishBehavior(initValue), refCount())` is equivalent to\n * `source.pipe(share({ connector: () => new BehaviorSubject(initValue), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false  }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishBehavior<T>(initialValue: T): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  // Note that this has *never* supported the selector function.\n  return (source) => {\n    const subject = new BehaviorSubject<T>(initialValue);\n    return new ConnectableObservable(source, () => subject);\n  };\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Returns a connectable observable sequence that shares a single subscription to the\n * underlying sequence containing only the last notification.\n *\n * ![](publishLast.png)\n *\n * Similar to {@link publish}, but it waits until the source observable completes and stores\n * the last emitted value.\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\n * immediately get that last stored value and complete.\n *\n * ## Example\n *\n * ```ts\n * import { ConnectableObservable, interval, publishLast, tap, take } from 'rxjs';\n *\n * const connectable = <ConnectableObservable<number>>interval(1000)\n *   .pipe(\n *     tap(x => console.log('side effect', x)),\n *     take(3),\n *     publishLast()\n *   );\n *\n * connectable.subscribe({\n *   next: x => console.log('Sub. A', x),\n *   error: err => console.log('Sub. A Error', err),\n *   complete: () => console.log('Sub. A Complete')\n * });\n *\n * connectable.subscribe({\n *   next: x => console.log('Sub. B', x),\n *   error: err => console.log('Sub. B Error', err),\n *   complete: () => console.log('Sub. B Complete')\n * });\n *\n * connectable.connect();\n *\n * // Results:\n * // 'side effect 0'   - after one second\n * // 'side effect 1'   - after two seconds\n * // 'side effect 2'   - after three seconds\n * // 'Sub. A 2'        - immediately after 'side effect 2'\n * // 'Sub. B 2'\n * // 'Sub. A Complete'\n * // 'Sub. B Complete'\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link publish}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @return A function that returns an Observable that emits elements of a\n * sequence produced by multicasting the source sequence.\n * @deprecated Will be removed in v8. To create a connectable observable with an\n * {@link AsyncSubject} under the hood, use {@link connectable}.\n * `source.pipe(publishLast())` is equivalent to\n * `connectable(source, { connector: () => new AsyncSubject(), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishLast`, use the {@link share} operator instead.\n * `source.pipe(publishLast(), refCount())` is equivalent to\n * `source.pipe(share({ connector: () => new AsyncSubject(), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  // Note that this has *never* supported a selector function like `publish` and `publishReplay`.\n  return (source) => {\n    const subject = new AsyncSubject<T>();\n    return new ConnectableObservable(source, () => subject);\n  };\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { MonoTypeOperatorFunction, OperatorFunction, TimestampProvider, ObservableInput, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\n * internally.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link ReplaySubject} under the hood, use {@link connectable}.\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T>(\n  bufferSize?: number,\n  windowTime?: number,\n  timestampProvider?: TimestampProvider\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Creates an observable, that when subscribed to, will create a {@link ReplaySubject},\n * and pass an observable from it (using [asObservable](api/index/class/Subject#asObservable)) to\n * the `selector` function, which then returns an observable that is subscribed to before\n * \"connecting\" the source to the internal `ReplaySubject`.\n *\n * Since this is deprecated, for additional details see the documentation for {@link connect}.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param selector A function used to setup the multicast.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `source.pipe(publishReplay(size, window, selector, scheduler))` is equivalent to\n * `source.pipe(connect(selector, { connector: () => new ReplaySubject(size, window, scheduler) }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, O extends ObservableInput<any>>(\n  bufferSize: number | undefined,\n  windowTime: number | undefined,\n  selector: (shared: Observable<T>) => O,\n  timestampProvider?: TimestampProvider\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\n * internally.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param selector Passing `undefined` here determines that this operator will return a {@link ConnectableObservable}.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link ReplaySubject} under the hood, use {@link connectable}.\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, O extends ObservableInput<any>>(\n  bufferSize: number | undefined,\n  windowTime: number | undefined,\n  selector: undefined,\n  timestampProvider: TimestampProvider\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, R>(\n  bufferSize?: number,\n  windowTime?: number,\n  selectorOrScheduler?: TimestampProvider | OperatorFunction<T, R>,\n  timestampProvider?: TimestampProvider\n) {\n  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {\n    timestampProvider = selectorOrScheduler;\n  }\n  const selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;\n  // Note, we're passing `selector!` here, because at runtime, `undefined` is an acceptable argument\n  // but it makes our TypeScript signature for `multicast` unhappy (as it should, because it's gross).\n  return (source: Observable<T>) => multicast(new ReplaySubject<T>(bufferSize, windowTime, timestampProvider), selector!)(source);\n}\n","import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { raceInit } from '../observable/race';\nimport { operate } from '../util/lift';\nimport { identity } from '../util/identity';\n\n/**\n * Creates an Observable that mirrors the first source Observable to emit a next,\n * error or complete notification from the combination of the Observable to which\n * the operator is applied and supplied Observables.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, raceWith } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * obs1\n *   .pipe(raceWith(obs2, obs3))\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param otherSources Sources used to race for which Observable emits first.\n * @return A function that returns an Observable that mirrors the output of the\n * first Observable to emit an item.\n */\nexport function raceWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return !otherSources.length\n    ? identity\n    : operate((source, subscriber) => {\n        raceInit<T | A[number]>([source, ...otherSources])(subscriber);\n      });\n}\n","import { Subscription } from '../Subscription';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { timer } from '../observable/timer';\n\nexport interface RepeatConfig {\n  /**\n   * The number of times to repeat the source. Defaults to `Infinity`.\n   */\n  count?: number;\n\n  /**\n   * If a `number`, will delay the repeat of the source by that number of milliseconds.\n   * If a function, it will provide the number of times the source has been subscribed to,\n   * and the return value should be a valid observable input that will notify when the source\n   * should be repeated. If the notifier observable is empty, the result will complete.\n   */\n  delay?: number | ((count: number) => ObservableInput<any>);\n}\n\n/**\n * Returns an Observable that will resubscribe to the source stream when the source stream completes.\n *\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\n *\n * ![](repeat.png)\n *\n * Repeat will output values from a source until the source completes, then it will resubscribe to the\n * source a specified number of times, with a specified delay. Repeat can be particularly useful in\n * combination with closing operators like {@link take}, {@link takeUntil}, {@link first}, or {@link takeWhile},\n * as it can be used to restart a source again from scratch.\n *\n * Repeat is very similar to {@link retry}, where {@link retry} will resubscribe to the source in the error case, but\n * `repeat` will resubscribe if the source completes.\n *\n * Note that `repeat` will _not_ catch errors. Use {@link retry} for that.\n *\n * - `repeat(0)` returns an empty observable\n * - `repeat()` will repeat forever\n * - `repeat({ delay: 200 })` will repeat forever, with a delay of 200ms between repetitions.\n * - `repeat({ count: 2, delay: 400 })` will repeat twice, with a delay of 400ms between repetitions.\n * - `repeat({ delay: (count) => timer(count * 1000) })` will repeat forever, but will have a delay that grows by one second for each repetition.\n *\n * ## Example\n *\n * Repeat a message stream\n *\n * ```ts\n * import { of, repeat } from 'rxjs';\n *\n * const source = of('Repeat message');\n * const result = source.pipe(repeat(3));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results\n * // 'Repeat message'\n * // 'Repeat message'\n * // 'Repeat message'\n * ```\n *\n * Repeat 3 values, 2 times\n *\n * ```ts\n * import { interval, take, repeat } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(take(3), repeat(2));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results every second\n * // 0\n * // 1\n * // 2\n * // 0\n * // 1\n * // 2\n * ```\n *\n * Defining two complex repeats with delays on the same source.\n * Note that the second repeat cannot be called until the first\n * repeat as exhausted it's count.\n *\n * ```ts\n * import { defer, of, repeat } from 'rxjs';\n *\n * const source = defer(() => {\n *    return of(`Hello, it is ${new Date()}`)\n * });\n *\n * source.pipe(\n *    // Repeat 3 times with a delay of 1 second between repetitions\n *    repeat({\n *      count: 3,\n *      delay: 1000,\n *    }),\n *\n *    // *Then* repeat forever, but with an exponential step-back\n *    // maxing out at 1 minute.\n *    repeat({\n *      delay: (count) => timer(Math.min(60000, 2 ^ count * 1000))\n *    })\n * )\n * ```\n *\n * @see {@link repeatWhen}\n * @see {@link retry}\n *\n * @param count The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n */\nexport function repeat<T>(countOrConfig?: number | RepeatConfig): MonoTypeOperatorFunction<T> {\n  let count = Infinity;\n  let delay: RepeatConfig['delay'];\n\n  if (countOrConfig != null) {\n    if (typeof countOrConfig === 'object') {\n      ({ count = Infinity, delay } = countOrConfig);\n    } else {\n      count = countOrConfig;\n    }\n  }\n\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let sourceSub: Subscription | null;\n\n        const resubscribe = () => {\n          sourceSub?.unsubscribe();\n          sourceSub = null;\n          if (delay != null) {\n            const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(soFar));\n            const notifierSubscriber = createOperatorSubscriber(subscriber, () => {\n              notifierSubscriber.unsubscribe();\n              subscribeToSource();\n            });\n            notifier.subscribe(notifierSubscriber);\n          } else {\n            subscribeToSource();\n          }\n        };\n\n        const subscribeToSource = () => {\n          let syncUnsub = false;\n          sourceSub = source.subscribe(\n            createOperatorSubscriber(subscriber, undefined, () => {\n              if (++soFar < count) {\n                if (sourceSub) {\n                  resubscribe();\n                } else {\n                  syncUnsub = true;\n                }\n              } else {\n                subscriber.complete();\n              }\n            })\n          );\n\n          if (syncUnsub) {\n            resubscribe();\n          }\n        };\n\n        subscribeToSource();\n      });\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * ![](repeatWhen.png)\n *\n * ## Example\n *\n * Repeat a message stream on click\n *\n * ```ts\n * import { of, fromEvent, repeatWhen } from 'rxjs';\n *\n * const source = of('Repeat message');\n * const documentClick$ = fromEvent(document, 'click');\n *\n * const result = source.pipe(repeatWhen(() => documentClick$));\n *\n * result.subscribe(data => console.log(data))\n * ```\n *\n * @see {@link repeat}\n * @see {@link retry}\n * @see {@link retryWhen}\n *\n * @param notifier Function that receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return A function that returns an `ObservableInput` that mirrors the source\n * Observable with the exception of a `complete`.\n * @deprecated Will be removed in v9 or v10. Use {@link repeat}'s {@link RepeatConfig#delay delay} option instead.\n * Instead of `repeatWhen(() => notify$)`, use: `repeat({ delay: () => notify$ })`.\n */\nexport function repeatWhen<T>(notifier: (notifications: Observable<void>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null;\n    let syncResub = false;\n    let completions$: Subject<void>;\n    let isNotifierComplete = false;\n    let isMainComplete = false;\n\n    /**\n     * Checks to see if we can complete the result, completes it, and returns `true` if it was completed.\n     */\n    const checkComplete = () => isMainComplete && isNotifierComplete && (subscriber.complete(), true);\n    /**\n     * Gets the subject to send errors through. If it doesn't exist,\n     * we know we need to setup the notifier.\n     */\n    const getCompletionSubject = () => {\n      if (!completions$) {\n        completions$ = new Subject();\n\n        // If the call to `notifier` throws, it will be caught by the OperatorSubscriber\n        // In the main subscription -- in `subscribeForRepeatWhen`.\n        innerFrom(notifier(completions$)).subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            () => {\n              if (innerSub) {\n                subscribeForRepeatWhen();\n              } else {\n                // If we don't have an innerSub yet, that's because the inner subscription\n                // call hasn't even returned yet. We've arrived here synchronously.\n                // So we flag that we want to resub, such that we can ensure finalization\n                // happens before we resubscribe.\n                syncResub = true;\n              }\n            },\n            () => {\n              isNotifierComplete = true;\n              checkComplete();\n            }\n          )\n        );\n      }\n      return completions$;\n    };\n\n    const subscribeForRepeatWhen = () => {\n      isMainComplete = false;\n\n      innerSub = source.subscribe(\n        createOperatorSubscriber(subscriber, undefined, () => {\n          isMainComplete = true;\n          // Check to see if we are complete, and complete if so.\n          // If we are not complete. Get the subject. This calls the `notifier` function.\n          // If that function fails, it will throw and `.next()` will not be reached on this\n          // line. The thrown error is caught by the _complete handler in this\n          // `OperatorSubscriber` and handled appropriately.\n          !checkComplete() && getCompletionSubject().next();\n        })\n      );\n\n      if (syncResub) {\n        // Ensure that the inner subscription is torn down before\n        // moving on to the next subscription in the synchronous case.\n        // If we don't do this here, all inner subscriptions will not be\n        // torn down until the entire observable is done.\n        innerSub.unsubscribe();\n        // It is important to null this out. Not only to free up memory, but\n        // to make sure code above knows we are in a subscribing state to\n        // handle synchronous resubscription.\n        innerSub = null;\n        // We may need to do this multiple times, so reset the flags.\n        syncResub = false;\n        // Resubscribe\n        subscribeForRepeatWhen();\n      }\n    };\n\n    // Start the subscription\n    subscribeForRepeatWhen();\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { Subscription } from '../Subscription';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nimport { timer } from '../observable/timer';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * The {@link retry} operator configuration object. `retry` either accepts a `number`\n * or an object described by this interface.\n */\nexport interface RetryConfig {\n  /**\n   * The maximum number of times to retry. If `count` is omitted, `retry` will try to\n   * resubscribe on errors infinite number of times.\n   */\n  count?: number;\n  /**\n   * The number of milliseconds to delay before retrying, OR a function to\n   * return a notifier for delaying. If a function is given, that function should\n   * return a notifier that, when it emits will retry the source. If the notifier\n   * completes _without_ emitting, the resulting observable will complete without error,\n   * if the notifier errors, the error will be pushed to the result.\n   */\n  delay?: number | ((error: any, retryCount: number) => ObservableInput<any>);\n  /**\n   * Whether or not to reset the retry counter when the retried subscription\n   * emits its first value.\n   */\n  resetOnSuccess?: boolean;\n}\n\nexport function retry<T>(count?: number): MonoTypeOperatorFunction<T>;\nexport function retry<T>(config: RetryConfig): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`.\n *\n * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of\n * `count` resubscriptions rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * The number of retries is determined by the `count` parameter. It can be set either by passing a number to\n * `retry` function or by setting `count` property when `retry` is configured using {@link RetryConfig}. If\n * `count` is omitted, `retry` will try to resubscribe on errors infinite number of times.\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those\n * emitted during failed subscriptions. For example, if an Observable fails at first but emits `[1, 2]` then\n * succeeds the second time and emits: `[1, 2, 3, 4, 5, complete]` then the complete stream of emissions and\n * notifications would be: `[1, 2, 1, 2, 3, 4, 5, complete]`.\n *\n * ## Example\n *\n * ```ts\n * import { interval, mergeMap, throwError, of, retry } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(\n *   mergeMap(val => val > 5 ? throwError(() => 'Error!') : of(val)),\n *   retry(2) // retry 2 times on error\n * );\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(`${ err }: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 'Error!: Retried 2 times then quit!'\n * ```\n *\n * @see {@link retryWhen}\n *\n * @param configOrCount - Either number of retry attempts before failing or a {@link RetryConfig} object.\n * @return A function that returns an Observable that will resubscribe to the\n * source stream when the source stream errors, at most `count` times.\n */\nexport function retry<T>(configOrCount: number | RetryConfig = Infinity): MonoTypeOperatorFunction<T> {\n  let config: RetryConfig;\n  if (configOrCount && typeof configOrCount === 'object') {\n    config = configOrCount;\n  } else {\n    config = {\n      count: configOrCount as number,\n    };\n  }\n  const { count = Infinity, delay, resetOnSuccess: resetOnSuccess = false } = config;\n\n  return count <= 0\n    ? identity\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let innerSub: Subscription | null;\n        const subscribeForRetry = () => {\n          let syncUnsub = false;\n          innerSub = source.subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              (value) => {\n                // If we're resetting on success\n                if (resetOnSuccess) {\n                  soFar = 0;\n                }\n                subscriber.next(value);\n              },\n              // Completions are passed through to consumer.\n              undefined,\n              (err) => {\n                if (soFar++ < count) {\n                  // We are still under our retry count\n                  const resub = () => {\n                    if (innerSub) {\n                      innerSub.unsubscribe();\n                      innerSub = null;\n                      subscribeForRetry();\n                    } else {\n                      syncUnsub = true;\n                    }\n                  };\n\n                  if (delay != null) {\n                    // The user specified a retry delay.\n                    // They gave us a number, use a timer, otherwise, it's a function,\n                    // and we're going to call it to get a notifier.\n                    const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));\n                    const notifierSubscriber = createOperatorSubscriber(\n                      subscriber,\n                      () => {\n                        // After we get the first notification, we\n                        // unsubscribe from the notifier, because we don't want anymore\n                        // and we resubscribe to the source.\n                        notifierSubscriber.unsubscribe();\n                        resub();\n                      },\n                      () => {\n                        // The notifier completed without emitting.\n                        // The author is telling us they want to complete.\n                        subscriber.complete();\n                      }\n                    );\n                    notifier.subscribe(notifierSubscriber);\n                  } else {\n                    // There was no notifier given. Just resub immediately.\n                    resub();\n                  }\n                } else {\n                  // We're past our maximum number of retries.\n                  // Just send along the error.\n                  subscriber.error(err);\n                }\n              }\n            )\n          );\n          if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            subscribeForRetry();\n          }\n        };\n        subscribeForRetry();\n      });\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the `ObservableInput` returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * ![](retryWhen.png)\n *\n * Retry an observable sequence on error based on custom criteria.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, retryWhen, tap, delayWhen, timer } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(\n *   map(value => {\n *     if (value > 5) {\n *       // error will be picked up by retryWhen\n *       throw value;\n *     }\n *     return value;\n *   }),\n *   retryWhen(errors =>\n *     errors.pipe(\n *       // log error message\n *       tap(value => console.log(`Value ${ value } was too high!`)),\n *       // restart in 5 seconds\n *       delayWhen(value => timer(value * 1000))\n *     )\n *   )\n * );\n *\n * result.subscribe(value => console.log(value));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 'Value 6 was too high!'\n * // - Wait 5 seconds then repeat\n * ```\n *\n * @see {@link retry}\n *\n * @param notifier Function that receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return A function that returns an `ObservableInput` that mirrors the source\n * Observable with the exception of an `error`.\n * @deprecated Will be removed in v9 or v10, use {@link retry}'s `delay` option instead.\n * Will be removed in v9 or v10. Use {@link retry}'s {@link RetryConfig#delay delay} option instead.\n * Instead of `retryWhen(() => notify$)`, use: `retry({ delay: () => notify$ })`.\n */\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null;\n    let syncResub = false;\n    let errors$: Subject<any>;\n\n    const subscribeForRetryWhen = () => {\n      innerSub = source.subscribe(\n        createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n          if (!errors$) {\n            errors$ = new Subject();\n            innerFrom(notifier(errors$)).subscribe(\n              createOperatorSubscriber(subscriber, () =>\n                // If we have an innerSub, this was an asynchronous call, kick off the retry.\n                // Otherwise, if we don't have an innerSub yet, that's because the inner subscription\n                // call hasn't even returned yet. We've arrived here synchronously.\n                // So we flag that we want to resub, such that we can ensure finalization\n                // happens before we resubscribe.\n                innerSub ? subscribeForRetryWhen() : (syncResub = true)\n              )\n            );\n          }\n          if (errors$) {\n            // We have set up the notifier without error.\n            errors$.next(err);\n          }\n        })\n      );\n\n      if (syncResub) {\n        // Ensure that the inner subscription is torn down before\n        // moving on to the next subscription in the synchronous case.\n        // If we don't do this here, all inner subscriptions will not be\n        // torn down until the entire observable is done.\n        innerSub.unsubscribe();\n        innerSub = null;\n        // We may need to do this multiple times, so reset the flag.\n        syncResub = false;\n        // Resubscribe\n        subscribeForRetryWhen();\n      }\n    };\n\n    // Start the subscription\n    subscribeForRetryWhen();\n  });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` `ObservableInput` emits something.</span>\n *\n * ![](sample.png)\n *\n * Whenever the `notifier` `ObservableInput` emits a value, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n *\n * On every click, sample the most recent `seconds` timer\n *\n * ```ts\n * import { fromEvent, interval, sample } from 'rxjs';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param notifier The `ObservableInput` to use for sampling the\n * source Observable.\n * @return A function that returns an Observable that emits the results of\n * sampling the values emitted by the source Observable whenever the notifier\n * Observable emits value or completes.\n */\nexport function sample<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        hasValue = true;\n        lastValue = value;\n      })\n    );\n    innerFrom(notifier).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          if (hasValue) {\n            hasValue = false;\n            const value = lastValue!;\n            lastValue = null;\n            subscriber.next(value);\n          }\n        },\n        noop\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { sample } from './sample';\nimport { interval } from '../observable/interval';\n\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * ![](sampleTime.png)\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n *\n * Every second, emit the most recent click at most once\n *\n * ```ts\n * import { fromEvent, sampleTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the sampling.\n * @return A function that returns an Observable that emits the results of\n * sampling the values emitted by the source Observable at the specified time\n * interval.\n */\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return sample(interval(period, scheduler));\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { scanInternals } from './scanInternals';\n\nexport function scan<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\nexport function scan<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\nexport function scan<V, A, S>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\n\n// TODO: link to a \"redux pattern\" section in the guide (location TBD)\n\n/**\n * Useful for encapsulating and managing state. Applies an accumulator (or \"reducer function\")\n * to each value from the source after an initial state is established -- either via\n * a `seed` value (second argument), or from the first value from the source.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation state after each update</span>\n *\n * ![](scan.png)\n *\n * This operator maintains an internal state and emits it after processing each value as follows:\n *\n * 1. First value arrives\n *   - If a `seed` value was supplied (as the second argument to `scan`), let `state = seed` and `value = firstValue`.\n *   - If NO `seed` value was supplied (no second argument), let `state = firstValue` and go to 3.\n * 2. Let `state = accumulator(state, value)`.\n *   - If an error is thrown by `accumulator`, notify the consumer of an error. The process ends.\n * 3. Emit `state`.\n * 4. Next value arrives, let `value = nextValue`, go to 2.\n *\n * ## Examples\n *\n * An average of previous numbers. This example shows how\n * not providing a `seed` can prime the stream with the\n * first value from the source.\n *\n * ```ts\n * import { of, scan, map } from 'rxjs';\n *\n * const numbers$ = of(1, 2, 3);\n *\n * numbers$\n *   .pipe(\n *     // Get the sum of the numbers coming in.\n *     scan((total, n) => total + n),\n *     // Get the average by dividing the sum by the total number\n *     // received so far (which is 1 more than the zero-based index).\n *     map((sum, index) => sum / (index + 1))\n *   )\n *   .subscribe(console.log);\n * ```\n *\n * The Fibonacci sequence. This example shows how you can use\n * a seed to prime accumulation process. Also... you know... Fibonacci.\n * So important to like, computers and stuff that its whiteboarded\n * in job interviews. Now you can show them the Rx version! (Please don't, haha)\n *\n * ```ts\n * import { interval, scan, map, startWith } from 'rxjs';\n *\n * const firstTwoFibs = [0, 1];\n * // An endless stream of Fibonacci numbers.\n * const fibonacci$ = interval(1000).pipe(\n *   // Scan to get the fibonacci numbers (after 0, 1)\n *   scan(([a, b]) => [b, a + b], firstTwoFibs),\n *   // Get the second number in the tuple, it's the one you calculated\n *   map(([, n]) => n),\n *   // Start with our first two digits :)\n *   startWith(...firstTwoFibs)\n * );\n *\n * fibonacci$.subscribe(console.log);\n * ```\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n * @see {@link switchScan}\n *\n * @param accumulator A \"reducer function\". This will be called for each value after an initial state is\n * acquired.\n * @param seed The initial state. If this is not provided, the first value from the source will\n * be used as the initial state, and emitted without going through the accumulator. All subsequent values\n * will be processed by the accumulator function. If this is provided, all values will go through\n * the accumulator function.\n * @return A function that returns an Observable of the accumulated values.\n */\nexport function scan<V, A, S>(accumulator: (acc: V | A | S, value: V, index: number) => A, seed?: S): OperatorFunction<V, V | A> {\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  return operate(scanInternals(accumulator, seed as S, arguments.length >= 2, true));\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Compares all values of two observables in sequence using an optional comparator function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * ![](sequenceEqual.png)\n *\n * `sequenceEqual` subscribes to source observable and `compareTo` `ObservableInput` (that internally\n * gets converted to an observable) and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other completes, the returned observable will never complete.\n *\n * ## Example\n *\n * Figure out if the Konami code matches\n *\n * ```ts\n * import { from, fromEvent, map, bufferCount, mergeMap, sequenceEqual } from 'rxjs';\n *\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent<KeyboardEvent>(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(last11 => from(last11).pipe(sequenceEqual(codes)))\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param compareTo The `ObservableInput` sequence to compare the source sequence to.\n * @param comparator An optional function to compare each value pair.\n *\n * @return A function that returns an Observable that emits a single boolean\n * value representing whether or not the values emitted by the source\n * Observable and provided `ObservableInput` were equal in sequence.\n */\nexport function sequenceEqual<T>(\n  compareTo: ObservableInput<T>,\n  comparator: (a: T, b: T) => boolean = (a, b) => a === b\n): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    // The state for the source observable\n    const aState = createState<T>();\n    // The state for the compareTo observable;\n    const bState = createState<T>();\n\n    /** A utility to emit and complete */\n    const emit = (isEqual: boolean) => {\n      subscriber.next(isEqual);\n      subscriber.complete();\n    };\n\n    /**\n     * Creates a subscriber that subscribes to one of the sources, and compares its collected\n     * state -- `selfState` -- to the other source's collected state -- `otherState`. This\n     * is used for both streams.\n     */\n    const createSubscriber = (selfState: SequenceState<T>, otherState: SequenceState<T>) => {\n      const sequenceEqualSubscriber = createOperatorSubscriber(\n        subscriber,\n        (a: T) => {\n          const { buffer, complete } = otherState;\n          if (buffer.length === 0) {\n            // If there's no values in the other buffer\n            // and the other stream is complete, we know\n            // this isn't a match, because we got one more value.\n            // Otherwise, we push onto our buffer, so when the other\n            // stream emits, it can pull this value off our buffer and check it\n            // at the appropriate time.\n            complete ? emit(false) : selfState.buffer.push(a);\n          } else {\n            // If the other stream *does* have values in its buffer,\n            // pull the oldest one off so we can compare it to what we\n            // just got. If it wasn't a match, emit `false` and complete.\n            !comparator(a, buffer.shift()!) && emit(false);\n          }\n        },\n        () => {\n          // Or observable completed\n          selfState.complete = true;\n          const { complete, buffer } = otherState;\n          // If the other observable is also complete, and there's\n          // still stuff left in their buffer, it doesn't match, if their\n          // buffer is empty, then it does match. This is because we can't\n          // possibly get more values here anymore.\n          complete && emit(buffer.length === 0);\n          // Be sure to clean up our stream as soon as possible if we can.\n          sequenceEqualSubscriber?.unsubscribe();\n        }\n      );\n\n      return sequenceEqualSubscriber;\n    };\n\n    // Subscribe to each source.\n    source.subscribe(createSubscriber(aState, bState));\n    innerFrom(compareTo).subscribe(createSubscriber(bState, aState));\n  });\n}\n\n/**\n * A simple structure for the data used to test each sequence\n */\ninterface SequenceState<T> {\n  /** A temporary store for arrived values before they are checked */\n  buffer: T[];\n  /** Whether or not the sequence source has completed. */\n  complete: boolean;\n}\n\n/**\n * Creates a simple structure that is used to represent\n * data used to test each sequence.\n */\nfunction createState<T>(): SequenceState<T> {\n  return {\n    buffer: [],\n    complete: false,\n  };\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubjectLike, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\n\nexport interface ShareConfig<T> {\n  /**\n   * The factory used to create the subject that will connect the source observable to\n   * multicast consumers.\n   */\n  connector?: () => SubjectLike<T>;\n  /**\n   * If `true`, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"retried\" in the event of an error.\n   * If `false`, when an error comes from the source it will push the error into the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnError?: boolean | ((error: any) => ObservableInput<any>);\n  /**\n   * If `true`, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"repeated\" after it is done.\n   * If `false`, when the source completes, it will push the completion through the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\n   * or resubscriptions will resubscribe to that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnComplete?: boolean | (() => ObservableInput<any>);\n  /**\n   * If `true`, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\n   * again.\n   * If `false`, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnRefCountZero?: boolean | (() => ObservableInput<any>);\n}\n\nexport function share<T>(): MonoTypeOperatorFunction<T>;\n\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\n *\n * ![](share.png)\n *\n * ## Example\n *\n * Generate new multicast Observable from the `source` Observable value\n *\n * ```ts\n * import { interval, tap, map, take, share } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   tap(x => console.log('Processing: ', x)),\n *   map(x => x * x),\n *   take(6),\n *   share()\n * );\n *\n * source.subscribe(x => console.log('subscription 1: ', x));\n * source.subscribe(x => console.log('subscription 2: ', x));\n *\n * // Logs:\n * // Processing: 0\n * // subscription 1: 0\n * // subscription 2: 0\n * // Processing: 1\n * // subscription 1: 1\n * // subscription 2: 1\n * // Processing: 2\n * // subscription 1: 4\n * // subscription 2: 4\n * // Processing: 3\n * // subscription 1: 9\n * // subscription 2: 9\n * // Processing: 4\n * // subscription 1: 16\n * // subscription 2: 16\n * // Processing: 5\n * // subscription 1: 25\n * // subscription 2: 25\n * ```\n *\n * ## Example with notifier factory: Delayed reset\n *\n * ```ts\n * import { interval, take, share, timer } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   take(3),\n *   share({\n *     resetOnRefCountZero: () => timer(1000)\n *   })\n * );\n *\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\n *\n * // Logs:\n * // subscription 1:  0\n * // (subscription 1 unsubscribes here)\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\n * // subscription 2:  1\n * // subscription 2:  2\n * // (subscription 2 unsubscribes here)\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\n * // subscription 3:  0\n * // subscription 3:  1\n * // subscription 3:  2\n * ```\n *\n * @see {@link shareReplay}\n *\n * @return A function that returns an Observable that mirrors the source.\n */\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n  // It's necessary to use a wrapper here, as the _operator_ must be\n  // referentially transparent. Otherwise, it cannot be used in calls to the\n  // static `pipe` function - to create a partial pipeline.\n  //\n  // The _operator function_ - the function returned by the _operator_ - will\n  // not be referentially transparent - as it shares its source - but the\n  // _operator function_ is called when the complete pipeline is composed via a\n  // call to a source observable's `pipe` method - not when the static `pipe`\n  // function is called.\n  return (wrapperSource) => {\n    let connection: SafeSubscriber<T> | undefined;\n    let resetConnection: Subscription | undefined;\n    let subject: SubjectLike<T> | undefined;\n    let refCount = 0;\n    let hasCompleted = false;\n    let hasErrored = false;\n\n    const cancelReset = () => {\n      resetConnection?.unsubscribe();\n      resetConnection = undefined;\n    };\n    // Used to reset the internal state to a \"cold\"\n    // state, as though it had never been subscribed to.\n    const reset = () => {\n      cancelReset();\n      connection = subject = undefined;\n      hasCompleted = hasErrored = false;\n    };\n    const resetAndUnsubscribe = () => {\n      // We need to capture the connection before\n      // we reset (if we need to reset).\n      const conn = connection;\n      reset();\n      conn?.unsubscribe();\n    };\n\n    return operate<T, T>((source, subscriber) => {\n      refCount++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n\n      // Create the subject if we don't have one yet. Grab a local reference to\n      // it as well, which avoids non-null assertions when using it and, if we\n      // connect to it now, then error/complete need a reference after it was\n      // reset.\n      const dest = (subject = subject ?? connector());\n\n      // Add the finalization directly to the subscriber - instead of returning it -\n      // so that the handling of the subscriber's unsubscription will be wired\n      // up _before_ the subscription to the source occurs. This is done so that\n      // the assignment to the source connection's `closed` property will be seen\n      // by synchronous firehose sources.\n      subscriber.add(() => {\n        refCount--;\n\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\n        // configuration.\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n\n      // The following line adds the subscription to the subscriber passed.\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\n      dest.subscribe(subscriber);\n\n      if (\n        !connection &&\n        // Check this shareReplay is still activate - it can be reset to 0\n        // and be \"unsubscribed\" _before_ it actually subscribes.\n        // If we were to subscribe then, it'd leak and get stuck.\n        refCount > 0\n      ) {\n        // We need to create a subscriber here - rather than pass an observer and\n        // assign the returned subscription to connection - because it's possible\n        // for reentrant subscriptions to the shared observable to occur and in\n        // those situations we want connection to be already-assigned so that we\n        // don't create another connection to the source.\n        connection = new SafeSubscriber({\n          next: (value) => dest.next(value),\n          error: (err) => {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: () => {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          },\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\n\nfunction handleReset<T extends unknown[] = never[]>(\n  reset: () => void,\n  on: boolean | ((...args: T) => ObservableInput<any>),\n  ...args: T\n): Subscription | undefined {\n  if (on === true) {\n    reset();\n    return;\n  }\n\n  if (on === false) {\n    return;\n  }\n\n  const onSubscriber = new SafeSubscriber({\n    next: () => {\n      onSubscriber.unsubscribe();\n      reset();\n    },\n  });\n\n  return innerFrom(on(...args)).subscribe(onSubscriber);\n}\n","import { ReplaySubject } from '../ReplaySubject';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { share } from './share';\n\nexport interface ShareReplayConfig {\n  bufferSize?: number;\n  windowTime?: number;\n  refCount: boolean;\n  scheduler?: SchedulerLike;\n}\n\nexport function shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplay`ed observable forever,\n * but an errored source can be retried.\n *\n * ## Why use `shareReplay`?\n *\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ## Reference counting\n *\n * By default `shareReplay` will use `refCount` of false, meaning that it will _not_ unsubscribe the\n * source when the reference counter drops to zero, i.e. the inner `ReplaySubject` will _not_ be unsubscribed\n * (and potentially run for ever).\n * This is the default as it is expected that `shareReplay` is often used to keep around expensive to setup\n * observables which we want to keep running instead of having to do the expensive setup again.\n *\n * As of RXJS version 6.4.0 a new overload signature was added to allow for manual control over what\n * happens when the operators internal reference counter drops to zero.\n * If `refCount` is true, the source will be unsubscribed from once the reference count drops to zero, i.e.\n * the inner `ReplaySubject` will be unsubscribed. All new subscribers will receive value emissions from a\n * new `ReplaySubject` which in turn will cause a new subscription to the source observable.\n *\n * ## Examples\n *\n * Example with a third subscriber coming late to the party\n *\n * ```ts\n * import { interval, take, shareReplay } from 'rxjs';\n *\n * const shared$ = interval(2000).pipe(\n *   take(6),\n *   shareReplay(3)\n * );\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * setTimeout(() => {\n *   shared$.subscribe(y => console.log('sub C: ', y));\n * }, 11000);\n *\n * // Logs:\n * // (after ~2000 ms)\n * // sub A: 0\n * // sub B: 0\n * // (after ~4000 ms)\n * // sub A: 1\n * // sub B: 1\n * // (after ~6000 ms)\n * // sub A: 2\n * // sub B: 2\n * // (after ~8000 ms)\n * // sub A: 3\n * // sub B: 3\n * // (after ~10000 ms)\n * // sub A: 4\n * // sub B: 4\n * // (after ~11000 ms, sub C gets the last 3 values)\n * // sub C: 2\n * // sub C: 3\n * // sub C: 4\n * // (after ~12000 ms)\n * // sub A: 5\n * // sub B: 5\n * // sub C: 5\n * ```\n *\n * Example for `refCount` usage\n *\n * ```ts\n * import { Observable, tap, interval, shareReplay, take } from 'rxjs';\n *\n * const log = <T>(name: string, source: Observable<T>) => source.pipe(\n *   tap({\n *     subscribe: () => console.log(`${ name }: subscribed`),\n *     next: value => console.log(`${ name }: ${ value }`),\n *     complete: () => console.log(`${ name }: completed`),\n *     finalize: () => console.log(`${ name }: unsubscribed`)\n *   })\n * );\n *\n * const obs$ = log('source', interval(1000));\n *\n * const shared$ = log('shared', obs$.pipe(\n *   shareReplay({ bufferSize: 1, refCount: true }),\n *   take(2)\n * ));\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * // PRINTS:\n * // shared: subscribed <-- reference count = 1\n * // source: subscribed\n * // shared: subscribed <-- reference count = 2\n * // source: 0\n * // shared: 0\n * // sub A: 0\n * // shared: 0\n * // sub B: 0\n * // source: 1\n * // shared: 1\n * // sub A: 1\n * // shared: completed <-- take(2) completes the subscription for sub A\n * // shared: unsubscribed <-- reference count = 1\n * // shared: 1\n * // sub B: 1\n * // shared: completed <-- take(2) completes the subscription for sub B\n * // shared: unsubscribed <-- reference count = 0\n * // source: unsubscribed <-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true\n *\n * // In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers\n * // are listening.\n * // source: 2\n * // source: 3\n * // source: 4\n * // ...\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param configOrBufferSize Maximum element count of the replay buffer or {@link ShareReplayConfig configuration}\n * object.\n * @param windowTime Maximum time length of the replay buffer in milliseconds.\n * @param scheduler Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return A function that returns an Observable sequence that contains the\n * elements of a sequence produced by multicasting the source sequence within a\n * selector function.\n */\nexport function shareReplay<T>(\n  configOrBufferSize?: ShareReplayConfig | number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T> {\n  let bufferSize: number;\n  let refCount = false;\n  if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n    ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);\n  } else {\n    bufferSize = (configOrBufferSize ?? Infinity) as number;\n  }\n  return share<T>({\n    connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),\n    resetOnError: true,\n    resetOnComplete: false,\n    resetOnRefCountZero: refCount,\n  });\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\n\nimport { MonoTypeOperatorFunction, OperatorFunction, TruthyTypesOf } from '../types';\nimport { SequenceError } from '../util/SequenceError';\nimport { NotFoundError } from '../util/NotFoundError';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function single<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that asserts that only one value is\n * emitted from the observable that matches the predicate. If no\n * predicate is provided, then it will assert that the observable\n * only emits one value.\n *\n * In the event that the observable is empty, it will throw an\n * {@link EmptyError}.\n *\n * In the event that two values are found that match the predicate,\n * or when there are two values emitted and no predicate, it will\n * throw a {@link SequenceError}\n *\n * In the event that no values match the predicate, if one is provided,\n * it will throw a {@link NotFoundError}\n *\n * ## Example\n *\n * Expect only `name` beginning with `'B'`\n *\n * ```ts\n * import { of, single } from 'rxjs';\n *\n * const source1 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Laney' },\n *  { name: 'Lily' }\n * );\n *\n * source1\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe(x => console.log(x));\n * // Emits 'Ben'\n *\n *\n * const source2 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Bradley' },\n *  { name: 'Lincoln' }\n * );\n *\n * source2\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: SequenceError('Too many values match')\n *\n *\n * const source3 = of(\n *  { name: 'Laney' },\n *  { name: 'Tracy' },\n *  { name: 'Lily' },\n *  { name: 'Lincoln' }\n * );\n *\n * source3\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: NotFoundError('No values match')\n * ```\n *\n * @see {@link first}\n * @see {@link find}\n * @see {@link findIndex}\n * @see {@link elementAt}\n *\n * @throws {NotFoundError} Delivers an NotFoundError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @throws {SequenceError} Delivers a SequenceError if more than one value is emitted that matches the\n * provided predicate. If no predicate is provided, will deliver a SequenceError if more\n * than one value comes from the source\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return A function that returns an Observable that emits the single item\n * emitted by the source Observable that matches the predicate.\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let singleValue: T;\n    let seenValue = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          seenValue = true;\n          if (!predicate || predicate(value, index++, source)) {\n            hasValue && subscriber.error(new SequenceError('Too many matching values'));\n            hasValue = true;\n            singleValue = value;\n          }\n        },\n        () => {\n          if (hasValue) {\n            subscriber.next(singleValue);\n            subscriber.complete();\n          } else {\n            subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());\n          }\n        }\n      )\n    );\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { filter } from './filter';\n\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * ![](skip.png)\n *\n * Skips the values until the sent notifications are equal or less than provided skip count. It raises\n * an error if skip count is equal or more than the actual number of emits and source raises an error.\n *\n * ## Example\n *\n * Skip the values before the emission\n *\n * ```ts\n * import { interval, skip } from 'rxjs';\n *\n * // emit every half second\n * const source = interval(500);\n * // skip the first 10 emitted values\n * const result = source.pipe(skip(10));\n *\n * result.subscribe(value => console.log(value));\n * // output: 10...11...12...13...\n * ```\n *\n * @see {@link last}\n * @see {@link skipWhile}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return A function that returns an Observable that skips the first `count`\n * values emitted by the source Observable.\n */\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\n  return filter((_, index) => count <= index);\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Skip a specified number of values before the completion of an observable.\n *\n * ![](skipLast.png)\n *\n * Returns an observable that will emit values as soon as it can, given a number of\n * skipped values. For example, if you `skipLast(3)` on a source, when the source\n * emits its fourth value, the first value the source emitted will finally be emitted\n * from the returned observable, as it is no longer part of what needs to be skipped.\n *\n * All values emitted by the result of `skipLast(N)` will be delayed by `N` emissions,\n * as each value is held in a buffer until enough values have been emitted that that\n * the buffered value may finally be sent to the consumer.\n *\n * After subscribing, unsubscribing will not result in the emission of the buffered\n * skipped values.\n *\n * ## Example\n *\n * Skip the last 2 values of an observable with many values\n *\n * ```ts\n * import { of, skipLast } from 'rxjs';\n *\n * const numbers = of(1, 2, 3, 4, 5);\n * const skipLastTwo = numbers.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * // (4 and 5 are skipped)\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @param skipCount Number of elements to skip from the end of the source Observable.\n * @return A function that returns an Observable that skips the last `count`\n * values emitted by the source Observable.\n */\nexport function skipLast<T>(skipCount: number): MonoTypeOperatorFunction<T> {\n  return skipCount <= 0\n    ? // For skipCounts less than or equal to zero, we are just mirroring the source.\n      identity\n    : operate((source, subscriber) => {\n        // A ring buffer to hold the values while we wait to see\n        // if we can emit it or it's part of the \"skipped\" last values.\n        // Note that it is the _same size_ as the skip count.\n        let ring: T[] = new Array(skipCount);\n        // The number of values seen so far. This is used to get\n        // the index of the current value when it arrives.\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Get the index of the value we have right now\n            // relative to all other values we've seen, then\n            // increment `seen`. This ensures we've moved to\n            // the next slot in our ring buffer.\n            const valueIndex = seen++;\n            if (valueIndex < skipCount) {\n              // If we haven't seen enough values to fill our buffer yet,\n              // Then we aren't to a number of seen values where we can\n              // emit anything, so let's just start by filling the ring buffer.\n              ring[valueIndex] = value;\n            } else {\n              // We are traversing over the ring array in such\n              // a way that when we get to the end, we loop back\n              // and go to the start.\n              const index = valueIndex % skipCount;\n              // Pull the oldest value out so we can emit it,\n              // and stuff the new value in it's place.\n              const oldValue = ring[index];\n              ring[index] = value;\n              // Emit the old value. It is important that this happens\n              // after we swap the value in the buffer, if it happens\n              // before we swap the value in the buffer, then a synchronous\n              // source can get the buffer out of whack.\n              subscriber.next(oldValue);\n            }\n          })\n        );\n\n        return () => {\n          // Release our values in memory\n          ring = null!;\n        };\n      });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * The `skipUntil` operator causes the observable stream to skip the emission of values until the passed in observable\n * emits the first value. This can be particularly useful in combination with user interactions, responses of HTTP\n * requests or waiting for specific times to pass by.\n *\n * ![](skipUntil.png)\n *\n * Internally, the `skipUntil` operator subscribes to the passed in `notifier` `ObservableInput` (which gets converted\n * to an Observable) in order to recognize the emission of its first value. When `notifier` emits next, the operator\n * unsubscribes from it and starts emitting the values of the *source* observable until it completes or errors. It\n * will never let the *source* observable emit any values if the `notifier` completes or throws an error without\n * emitting a value before.\n *\n * ## Example\n *\n * In the following example, all emitted values of the interval observable are skipped until the user clicks anywhere\n * within the page\n *\n * ```ts\n * import { interval, fromEvent, skipUntil } from 'rxjs';\n *\n * const intervalObservable = interval(1000);\n * const click = fromEvent(document, 'click');\n *\n * const emitAfterClick = intervalObservable.pipe(\n *   skipUntil(click)\n * );\n * // clicked at 4.6s. output: 5...6...7...8........ or\n * // clicked at 7.3s. output: 8...9...10..11.......\n * emitAfterClick.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipWhile}\n * @see {@link skipLast}\n *\n * @param notifier An `ObservableInput` that has to emit an item before the source Observable elements begin to\n * be mirrored by the resulting Observable.\n * @return A function that returns an Observable that skips items from the\n * source Observable until the `notifier` Observable emits an item, then emits the\n * remaining items.\n */\nexport function skipUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n\n    const skipSubscriber = createOperatorSubscriber(\n      subscriber,\n      () => {\n        skipSubscriber?.unsubscribe();\n        taking = true;\n      },\n      noop\n    );\n\n    innerFrom(notifier).subscribe(skipSubscriber);\n\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => taking && subscriber.next(value)));\n  });\n}\n","import { Falsy, MonoTypeOperatorFunction, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function skipWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, Extract<T, Falsy> extends never ? never : T>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => true): OperatorFunction<T, never>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * Skips all the notifications with a truthy predicate. It will not skip the notifications when the predicate is falsy.\n * It can also be skipped using index. Once the predicate is true, it will not be called again.\n *\n * ## Example\n *\n * Skip some super heroes\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from(['Green Arrow', 'SuperMan', 'Flash', 'SuperGirl', 'Black Canary'])\n * // Skip the heroes until SuperGirl\n * const example = source.pipe(skipWhile(hero => hero !== 'SuperGirl'));\n * // output: SuperGirl, Black Canary\n * example.subscribe(femaleHero => console.log(femaleHero));\n * ```\n *\n * Skip values from the array until index 5\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from([1, 2, 3, 4, 5, 6, 7, 9, 10]);\n * const example = source.pipe(skipWhile((_, i) => i !== 5));\n * // output: 6, 7, 9, 10\n * example.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return A function that returns an Observable that begins emitting items\n * emitted by the source Observable when the specified predicate becomes false.\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => (taking || (taking = !predicate(value, index++))) && subscriber.next(value))\n    );\n  });\n}\n","import { concat } from '../observable/concat';\nimport { OperatorFunction, SchedulerLike, ValueFromArray } from '../types';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function startWith<T>(value: null): OperatorFunction<T, T | null>;\nexport function startWith<T>(value: undefined): OperatorFunction<T, T | undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function startWith<T, A extends readonly unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\nexport function startWith<T, A extends readonly unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that, at the moment of subscription, will synchronously emit all\n * values provided to this operator, then subscribe to the source and mirror all of its emissions\n * to subscribers.\n *\n * This is a useful way to know when subscription has occurred on an existing observable.\n *\n * <span class=\"informal\">First emits its arguments in order, and then any\n * emissions from the source.</span>\n *\n * ![](startWith.png)\n *\n * ## Examples\n *\n * Emit a value when a timer starts.\n *\n * ```ts\n * import { timer, map, startWith } from 'rxjs';\n *\n * timer(1000)\n *   .pipe(\n *     map(() => 'timer emit'),\n *     startWith('timer start')\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // results:\n * // 'timer start'\n * // 'timer emit'\n * ```\n *\n * @param values Items you want the modified Observable to emit first.\n * @return A function that returns an Observable that synchronously emits\n * provided values before subscribing to the source Observable.\n *\n * @see {@link endWith}\n * @see {@link finalize}\n * @see {@link concat}\n */\nexport function startWith<T, D>(...values: D[]): OperatorFunction<T, T | D> {\n  const scheduler = popScheduler(values);\n  return operate((source, subscriber) => {\n    // Here we can't pass `undefined` as a scheduler, because if we did, the\n    // code inside of `concat` would be confused by the `undefined`, and treat it\n    // like an invalid observable. So we have to split it two different ways.\n    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n  });\n}\n","import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switchAll}.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n *\n * Generate new Observable according to source Observable values\n *\n * ```ts\n * import { of, switchMap } from 'rxjs';\n *\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // 3\n * // 9\n * // 27\n * ```\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMap, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * only the values from the most recently projected inner Observable.\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return operate((source, subscriber) => {\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\n    let index = 0;\n    // Whether or not the source subscription has completed\n    let isComplete = false;\n\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\n    // This is called both when the source completes and when the inners complete.\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Cancel the previous inner subscription if there was one\n          innerSubscriber?.unsubscribe();\n          let innerIndex = 0;\n          const outerIndex = index++;\n          // Start the next inner subscription\n          innerFrom(project(value, outerIndex)).subscribe(\n            (innerSubscriber = createOperatorSubscriber(\n              subscriber,\n              // When we get a new inner value, next it through. Note that this is\n              // handling the deprecate result selector here. This is because with this architecture\n              // it ends up being smaller than using the map operator.\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\n              () => {\n                // The inner has completed. Null out the inner subscriber to\n                // free up memory and to signal that we have no inner subscription\n                // currently.\n                innerSubscriber = null!;\n                checkComplete();\n              }\n            ))\n          );\n        },\n        () => {\n          isComplete = true;\n          checkComplete();\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\n\n/**\n * Converts a higher-order Observable into a first-order Observable\n * producing values only from the most recent observable sequence\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](switchAll.png)\n *\n * `switchAll` subscribes to a source that is an observable of observables, also known as a\n * \"higher-order observable\" (or `Observable<Observable<T>>`). It subscribes to the most recently\n * provided \"inner observable\" emitted by the source, unsubscribing from any previously subscribed\n * to inner observable, such that only the most recent inner observable may be subscribed to at\n * any point in time. The resulting observable returned by `switchAll` will only complete if the\n * source observable completes, *and* any currently subscribed to inner observable also has completed,\n * if there are any.\n *\n * ## Examples\n *\n * Spawn a new interval observable for each click event, but for every new\n * click, cancel the previous interval and subscribe to the new one\n *\n * ```ts\n * import { fromEvent, tap, map, interval, switchAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));\n * const source = clicks.pipe(map(() => interval(1000)));\n *\n * source\n *   .pipe(switchAll())\n *   .subscribe(x => console.log(x));\n *\n * // Output\n * // click\n * // 0\n * // 1\n * // 2\n * // 3\n * // ...\n * // click\n * // 0\n * // 1\n * // 2\n * // ...\n * // click\n * // ...\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link mergeAll}\n *\n * @return A function that returns an Observable that converts a higher-order\n * Observable into a first-order Observable producing values only from the most\n * recent Observable sequence.\n */\nexport function switchAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return switchMap(identity);\n}\n","import { switchMap } from './switchMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)` */\nexport function switchMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMapTo<O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: undefined\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switchMap} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](switchMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * ## Example\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMapTo, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMapTo(interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return A function that returns an Observable that emits items from the\n * given `innerObservable` (and optionally transformed through the deprecated\n * `resultSelector`) every time a value is emitted on the source Observable,\n * and taking only the values from the most recently projected inner\n * Observable.\n * @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)`\n */\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);\n}\n","import { ObservableInput, ObservedValueOf, OperatorFunction } from '../types';\nimport { switchMap } from './switchMap';\nimport { operate } from '../util/lift';\n\n// TODO: Generate a marble diagram for these docs.\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, emitting values\n * only from the most recently returned Observable.\n *\n * <span class=\"informal\">It's like {@link mergeScan}, but only the most recent\n * Observable returned by the accumulator is merged into the outer Observable.</span>\n *\n * @see {@link scan}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @return A function that returns an observable of the accumulated values.\n */\nexport function switchScan<T, R, O extends ObservableInput<any>>(\n  accumulator: (acc: R, value: T, index: number) => O,\n  seed: R\n): OperatorFunction<T, ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    // The state we will keep up to date to pass into our\n    // accumulator function at each new value from the source.\n    let state = seed;\n\n    // Use `switchMap` on our `source` to do the work of creating\n    // this operator. Note the backwards order here of `switchMap()(source)`\n    // to avoid needing to use `pipe` unnecessarily\n    switchMap(\n      // On each value from the source, call the accumulator with\n      // our previous state, the value and the index.\n      (value: T, index) => accumulator(state, value, index),\n      // Using the deprecated result selector here as a dirty trick\n      // to update our state with the flattened value.\n      (_, innerValue) => ((state = innerValue), innerValue)\n    )(source).subscribe(subscriber);\n\n    return () => {\n      // Release state on finalization\n      state = null!;\n    };\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n *\n * Tick every second until the first click happens\n *\n * ```ts\n * import { interval, fromEvent, takeUntil } from 'rxjs';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return A function that returns an Observable that emits the values from the\n * source Observable until `notifier` emits its first value.\n */\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: true): MonoTypeOperatorFunction<T>;\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: false): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * ![](takeWhile.png)\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * ## Example\n *\n * Emit click events only while the clientX property is greater than 200\n *\n * ```ts\n * import { fromEvent, takeWhile } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @param {boolean} inclusive When set to `true` the value that caused\n * `predicate` to return `false` will also be emitted.\n * @return A function that returns an Observable that emits values from the\n * source Observable so long as each value satisfies the condition defined by\n * the `predicate`, then completes.\n */\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive = false): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const result = predicate(value, index++);\n        (result || inclusive) && subscriber.next(value);\n        !result && subscriber.complete();\n      })\n    );\n  });\n}\n","import { MonoTypeOperatorFunction, Observer } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\n\n/**\n * An extension to the {@link Observer} interface used only by the {@link tap} operator.\n *\n * It provides a useful set of callbacks a user can register to do side-effects in\n * cases other than what the usual {@link Observer} callbacks are\n * ({@link guide/glossary-and-semantics#next next},\n * {@link guide/glossary-and-semantics#error error} and/or\n * {@link guide/glossary-and-semantics#complete complete}).\n *\n * ## Example\n *\n * ```ts\n * import { fromEvent, switchMap, tap, interval, take } from 'rxjs';\n *\n * const source$ = fromEvent(document, 'click');\n * const result$ = source$.pipe(\n *   switchMap((_, i) => i % 2 === 0\n *     ? fromEvent(document, 'mousemove').pipe(\n *         tap({\n *           subscribe: () => console.log('Subscribed to the mouse move events after click #' + i),\n *           unsubscribe: () => console.log('Mouse move events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('Mouse move events #' + i + ' finalized')\n *         })\n *       )\n *     : interval(1_000).pipe(\n *         take(5),\n *         tap({\n *           subscribe: () => console.log('Subscribed to the 1-second interval events after click #' + i),\n *           unsubscribe: () => console.log('1-second interval events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('1-second interval events #' + i + ' finalized')\n *         })\n *       )\n *   )\n * );\n *\n * const subscription = result$.subscribe({\n *   next: console.log\n * });\n *\n * setTimeout(() => {\n *   console.log('Unsubscribe after 60 seconds');\n *   subscription.unsubscribe();\n * }, 60_000);\n * ```\n */\nexport interface TapObserver<T> extends Observer<T> {\n  /**\n   * The callback that `tap` operator invokes at the moment when the source Observable\n   * gets subscribed to.\n   */\n  subscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when an explicit\n   * {@link guide/glossary-and-semantics#unsubscription unsubscribe} happens. It won't get invoked on\n   * `error` or `complete` events.\n   */\n  unsubscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when any kind of\n   * {@link guide/glossary-and-semantics#finalization finalization} happens - either when\n   * the source Observable `error`s or `complete`s or when it gets explicitly unsubscribed\n   * by the user. There is no difference in using this callback or the {@link finalize}\n   * operator, but if you're already using `tap` operator, you can use this callback\n   * instead. You'd get the same result in either case.\n   */\n  finalize: () => void;\n}\nexport function tap<T>(observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void)): MonoTypeOperatorFunction<T>;\n/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\nexport function tap<T>(\n  next?: ((value: T) => void) | null,\n  error?: ((error: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Used to perform side-effects for notifications from the source observable\n *\n * <span class=\"informal\">Used when you want to affect outside state with a notification without altering the notification</span>\n *\n * ![](tap.png)\n *\n * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects\n * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will\n * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to\n * help you remove side-effects from other operations.\n *\n * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function\n * reference, or a partial observer, then pass that notification down the stream.\n *\n * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler\n * provided to `tap` will be emitted as an error from the returned observable.\n *\n * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.\n *\n * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere\n * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous\n * operation.\n *\n * ## Examples\n *\n * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,\n * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number\n * was, so we have added a `tap(console.log)`.\n *\n * ```ts\n * import { of, tap, map } from 'rxjs';\n *\n * of(Math.random()).pipe(\n *   tap(console.log),\n *   map(n => n > 0.5 ? 'big' : 'small')\n * ).subscribe(console.log);\n * ```\n *\n * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only\n * want to emit numbers 3 or less we get from another source. We can force our observable to error\n * using `tap`.\n *\n * ```ts\n * import { of, tap } from 'rxjs';\n *\n * const source = of(1, 2, 3, 4, 5);\n *\n * source.pipe(\n *   tap(n => {\n *     if (n > 3) {\n *       throw new TypeError(`Value ${ n } is greater than 3`);\n *     }\n *   })\n * )\n * .subscribe({ next: console.log, error: err => console.log(err.message) });\n * ```\n *\n * We want to know when an observable completes before moving on to the next observable. The system\n * below will emit a random series of `'X'` characters from 3 different observables in sequence. The\n * only way we know when one observable completes and moves to the next one, in this case, is because\n * we have added a `tap` with the side effect of logging to console.\n *\n * ```ts\n * import { of, concatMap, interval, take, map, tap } from 'rxjs';\n *\n * of(1, 2, 3).pipe(\n *   concatMap(n => interval(1000).pipe(\n *     take(Math.round(Math.random() * 10)),\n *     map(() => 'X'),\n *     tap({ complete: () => console.log(`Done with ${ n }`) })\n *   ))\n * )\n * .subscribe(console.log);\n * ```\n *\n * @see {@link finalize}\n * @see {@link TapObserver}\n *\n * @param observerOrNext A next handler or partial observer\n * @param error An error handler\n * @param complete A completion handler\n * @return A function that returns an Observable identical to the source, but\n * runs the specified Observer or callback(s) for each item.\n */\nexport function tap<T>(\n  observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void) | null,\n  error?: ((e: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T> {\n  // We have to check to see not only if next is a function,\n  // but if error or complete were passed. This is because someone\n  // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.\n  const tapObserver =\n    isFunction(observerOrNext) || error || complete\n      ? // tslint:disable-next-line: no-object-literal-type-assertion\n        ({ next: observerOrNext as Exclude<typeof observerOrNext, Partial<TapObserver<T>>>, error, complete } as Partial<TapObserver<T>>)\n      : observerOrNext;\n\n  return tapObserver\n    ? operate((source, subscriber) => {\n        tapObserver.subscribe?.();\n        let isUnsub = true;\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              tapObserver.next?.(value);\n              subscriber.next(value);\n            },\n            () => {\n              isUnsub = false;\n              tapObserver.complete?.();\n              subscriber.complete();\n            },\n            (err) => {\n              isUnsub = false;\n              tapObserver.error?.(err);\n              subscriber.error(err);\n            },\n            () => {\n              if (isUnsub) {\n                tapObserver.unsubscribe?.();\n              }\n              tapObserver.finalize?.();\n            }\n          )\n        );\n      })\n    : // Tap was called with no valid tap observer or handler\n      // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)\n      // so we're going to just mirror the source.\n      identity;\n}\n","import { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * An object interface used by {@link throttle} or {@link throttleTime} that ensure\n * configuration options of these operators.\n *\n * @see {@link throttle}\n * @see {@link throttleTime}\n */\nexport interface ThrottleConfig {\n  /**\n   * If `true`, the resulting Observable will emit the first value from the source\n   * Observable at the **start** of the \"throttling\" process (when starting an\n   * internal timer that prevents other emissions from the source to pass through).\n   * If `false`, it will not emit the first value from the source Observable at the\n   * start of the \"throttling\" process.\n   *\n   * If not provided, defaults to: `true`.\n   */\n  leading?: boolean;\n  /**\n   * If `true`, the resulting Observable will emit the last value from the source\n   * Observable at the **end** of the \"throttling\" process (when ending an internal\n   * timer that prevents other emissions from the source to pass through).\n   * If `false`, it will not emit the last value from the source Observable at the\n   * end of the \"throttling\" process.\n   *\n   * If not provided, defaults to: `false`.\n   */\n  trailing?: boolean;\n}\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.svg)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, throttle, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(() => interval(1000)));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function that receives a value from the source\n * Observable, for computing the silencing duration for each source value,\n * returned as an `ObservableInput`.\n * @param config A configuration object to define `leading` and `trailing`\n * behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return A function that returns an Observable that performs the throttle\n * operation to limit the rate of emissions from the source.\n */\nexport function throttle<T>(durationSelector: (value: T) => ObservableInput<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    const { leading = true, trailing = false } = config ?? {};\n    let hasValue = false;\n    let sendValue: T | null = null;\n    let throttled: Subscription | null = null;\n    let isComplete = false;\n\n    const endThrottling = () => {\n      throttled?.unsubscribe();\n      throttled = null;\n      if (trailing) {\n        send();\n        isComplete && subscriber.complete();\n      }\n    };\n\n    const cleanupThrottling = () => {\n      throttled = null;\n      isComplete && subscriber.complete();\n    };\n\n    const startThrottle = (value: T) =>\n      (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));\n\n    const send = () => {\n      if (hasValue) {\n        // Ensure we clear out our value and hasValue flag\n        // before we emit, otherwise reentrant code can cause\n        // issues here.\n        hasValue = false;\n        const value = sendValue!;\n        sendValue = null;\n        // Emit the value.\n        subscriber.next(value);\n        !isComplete && startThrottle(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        // Regarding the presence of throttled.closed in the following\n        // conditions, if a synchronous duration selector is specified - weird,\n        // but legal - an already-closed subscription will be assigned to\n        // throttled, so the subscription's closed property needs to be checked,\n        // too.\n        (value) => {\n          hasValue = true;\n          sendValue = value;\n          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));\n        },\n        () => {\n          isComplete = true;\n          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { throttle, ThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { timer } from '../observable/timer';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Examples\n *\n * ### Limit click rate\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, throttleTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param scheduler The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling. Defaults to {@link asyncScheduler}.\n * @param config A configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return A function that returns an Observable that performs the throttle\n * operation to limit the rate of emissions from the source.\n */\nexport function throttleTime<T>(\n  duration: number,\n  scheduler: SchedulerLike = asyncScheduler,\n  config?: ThrottleConfig\n): MonoTypeOperatorFunction<T> {\n  const duration$ = timer(duration, scheduler);\n  return throttle(() => duration$, config);\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits an object containing the current value, and the time that has\n * passed between emitting the current value and the previous value, which is\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\n * the current time at each emission, then calculating the difference. The `scheduler`\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\n * milliseconds.\n *\n * <span class=\"informal\">Convert an Observable that emits items into one that\n * emits indications of the amount of time elapsed between those emissions.</span>\n *\n * ![](timeInterval.png)\n *\n * ## Example\n *\n * Emit interval between current value with the last value\n *\n * ```ts\n * import { interval, timeInterval } from 'rxjs';\n *\n * const seconds = interval(1000);\n *\n * seconds\n *   .pipe(timeInterval())\n *   .subscribe(value => console.log(value));\n *\n * // NOTE: The values will never be this precise,\n * // intervals created with `interval` or `setInterval`\n * // are non-deterministic.\n *\n * // { value: 0, interval: 1000 }\n * // { value: 1, interval: 1000 }\n * // { value: 2, interval: 1000 }\n * ```\n *\n * @param {SchedulerLike} [scheduler] Scheduler used to get the current time.\n * @return A function that returns an Observable that emits information about\n * value and interval.\n */\nexport function timeInterval<T>(scheduler: SchedulerLike = asyncScheduler): OperatorFunction<T, TimeInterval<T>> {\n  return operate((source, subscriber) => {\n    let last = scheduler.now();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const now = scheduler.now();\n        const interval = now - last;\n        last = now;\n        subscriber.next(new TimeInterval(value, interval));\n      })\n    );\n  });\n}\n\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\n// there's no reason users should be manually creating this type.\n\nexport class TimeInterval<T> {\n  /**\n   * @deprecated Internal implementation detail, do not construct directly. Will be made an interface in v8.\n   */\n  constructor(public value: T, public interval: number) {}\n}\n","import { async } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\nimport { timeout } from './timeout';\n\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(someDate, a$, scheduler)`, use the configuration object\n * `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(dueBy: Date, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use the configuration object\n *  `timeout({ each: 100, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(waitFor: number, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n\n/**\n * When the passed timespan elapses before the source emits any given value, it will unsubscribe from the source,\n * and switch the subscription to another observable.\n *\n * <span class=\"informal\">Used to switch to a different observable if your source is being slow.</span>\n *\n * Useful in cases where:\n *\n * - You want to switch to a different source that may be faster.\n * - You want to notify a user that the data stream is slow.\n * - You want to emit a custom error rather than the {@link TimeoutError} emitted\n *   by the default usage of {@link timeout}.\n *\n * If the first parameter is passed as Date and the time of the Date arrives before the first value arrives from the source,\n * it will unsubscribe from the source and switch the subscription to another observable.\n *\n * <span class=\"informal\">Use Date object to switch to a different observable if the first value doesn't arrive by a specific time.</span>\n *\n * Can be used to set a timeout only for the first value, however it's recommended to use the {@link timeout} operator with\n * the `first` configuration to get the same effect.\n *\n * ## Examples\n *\n * Fallback to a faster observable\n *\n * ```ts\n * import { interval, timeoutWith } from 'rxjs';\n *\n * const slow$ = interval(1000);\n * const faster$ = interval(500);\n *\n * slow$\n *   .pipe(timeoutWith(900, faster$))\n *   .subscribe(console.log);\n * ```\n *\n * Emit your own custom timeout error\n *\n * ```ts\n * import { interval, timeoutWith, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(1000);\n *\n * slow$\n *   .pipe(timeoutWith(900, throwError(() => new CustomTimeoutError())))\n *   .subscribe({\n *     error: err => console.error(err.message)\n *   });\n * ```\n *\n * @see {@link timeout}\n *\n * @param due When passed a number, used as the time (in milliseconds) allowed between each value from the source before timeout\n * is triggered. When passed a Date, used as the exact time at which the timeout will be triggered if the first value does not arrive.\n * @param withObservable The observable to switch to when timeout occurs.\n * @param scheduler The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it starts emitting values\n * from the `ObservableInput` passed as a second parameter.\n * @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use {@link timeout} with the configuration\n * object: `timeout({ each: 100, with: () => a$, scheduler })`. Instead of `timeoutWith(someDate, a$, scheduler)`, use {@link timeout}\n * with the configuration object: `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8.\n */\nexport function timeoutWith<T, R>(\n  due: number | Date,\n  withObservable: ObservableInput<R>,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T | R> {\n  let first: number | Date | undefined;\n  let each: number | undefined;\n  let _with: () => ObservableInput<R>;\n  scheduler = scheduler ?? async;\n\n  if (isValidDate(due)) {\n    first = due;\n  } else if (typeof due === 'number') {\n    each = due;\n  }\n\n  if (withObservable) {\n    _with = () => withObservable;\n  } else {\n    throw new TypeError('No observable provided to switch to');\n  }\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return timeout<T, ObservableInput<R>>({\n    first,\n    each,\n    scheduler,\n    with: _with,\n  });\n}\n","import { OperatorFunction, TimestampProvider, Timestamp } from '../types';\nimport { dateTimestampProvider } from '../scheduler/dateTimestampProvider';\nimport { map } from './map';\n\n/**\n * Attaches a timestamp to each item emitted by an observable indicating when it was emitted\n *\n * The `timestamp` operator maps the *source* observable stream to an object of type\n * `{value: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value\n * and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By\n * default, it uses the `asyncScheduler` which simply returns `Date.now()` (milliseconds since 1970/01/01\n * 00:00:00:000) and therefore is of type `number`.\n *\n * ![](timestamp.png)\n *\n * ## Example\n *\n * In this example there is a timestamp attached to the document's click events\n *\n * ```ts\n * import { fromEvent, timestamp } from 'rxjs';\n *\n * const clickWithTimestamp = fromEvent(document, 'click').pipe(\n *   timestamp()\n * );\n *\n * // Emits data of type { value: PointerEvent, timestamp: number }\n * clickWithTimestamp.subscribe(data => {\n *   console.log(data);\n * });\n * ```\n *\n * @param timestampProvider An object with a `now()` method used to get the current timestamp.\n * @return A function that returns an Observable that attaches a timestamp to\n * each item emitted by the source Observable indicating when it was emitted.\n */\nexport function timestamp<T>(timestampProvider: TimestampProvider = dateTimestampProvider): OperatorFunction<T, Timestamp<T>> {\n  return map((value: T) => ({ value, timestamp: timestampProvider.now() }));\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * ![](window.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * `windowBoundaries` emits an item. `windowBoundaries` can be any type that\n * `ObservableInput` accepts. It internally gets converted to an Observable.\n * Because each window is an Observable, the output is a higher-order Observable.\n *\n * ## Example\n *\n * In every window of 1 second each, emit at most 2 click events\n *\n * ```ts\n * import { fromEvent, interval, window, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const sec = interval(1000);\n * const result = clicks.pipe(\n *   window(sec),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param windowBoundaries An `ObservableInput` that completes the\n * previous window and starts a new window.\n * @return A function that returns an Observable of windows, which are\n * Observables emitting values of the source Observable.\n */\nexport function window<T>(windowBoundaries: ObservableInput<any>): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    let windowSubject: Subject<T> = new Subject<T>();\n\n    subscriber.next(windowSubject.asObservable());\n\n    const errorHandler = (err: any) => {\n      windowSubject.error(err);\n      subscriber.error(err);\n    };\n\n    // Subscribe to our source\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => windowSubject?.next(value),\n        () => {\n          windowSubject.complete();\n          subscriber.complete();\n        },\n        errorHandler\n      )\n    );\n\n    // Subscribe to the window boundaries.\n    innerFrom(windowBoundaries).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          windowSubject.complete();\n          subscriber.next((windowSubject = new Subject()));\n        },\n        noop,\n        errorHandler\n      )\n    );\n\n    return () => {\n      // Unsubscribing the subject ensures that anyone who has captured\n      // a reference to this window that tries to use it after it can\n      // no longer get values from the source will get an ObjectUnsubscribedError.\n      windowSubject?.unsubscribe();\n      windowSubject = null!;\n    };\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n *\n * Ignore every 3rd click event, starting from the first one\n *\n * ```ts\n * import { fromEvent, windowCount, map, skip, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3),\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n *\n * ```ts\n * import { fromEvent, windowCount, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll() // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return A function that returns an Observable of windows, which in turn are\n * Observable of values.\n */\nexport function windowCount<T>(windowSize: number, startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  const startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;\n\n  return operate((source, subscriber) => {\n    let windows = [new Subject<T>()];\n    let starts: number[] = [];\n    let count = 0;\n\n    // Open the first window.\n    subscriber.next(windows[0].asObservable());\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Emit the value through all current windows.\n          // We don't need to create a new window yet, we\n          // do that as soon as we close one.\n          for (const window of windows) {\n            window.next(value);\n          }\n          // Here we're using the size of the window array to figure\n          // out if the oldest window has emitted enough values. We can do this\n          // because the size of the window array is a function of the values\n          // seen by the subscription. If it's time to close it, we complete\n          // it and remove it.\n          const c = count - windowSize + 1;\n          if (c >= 0 && c % startEvery === 0) {\n            windows.shift()!.complete();\n          }\n\n          // Look to see if the next count tells us it's time to open a new window.\n          // TODO: We need to figure out if this really makes sense. We're technically\n          // emitting windows *before* we have a value to emit them for. It's probably\n          // more expected that we should be emitting the window when the start\n          // count is reached -- not before.\n          if (++count % startEvery === 0) {\n            const window = new Subject<T>();\n            windows.push(window);\n            subscriber.next(window.asObservable());\n          }\n        },\n        () => {\n          while (windows.length > 0) {\n            windows.shift()!.complete();\n          }\n          subscriber.complete();\n        },\n        (err) => {\n          while (windows.length > 0) {\n            windows.shift()!.error(err);\n          }\n          subscriber.error(err);\n        },\n        () => {\n          starts = null!;\n          windows = null!;\n        }\n      )\n    );\n  });\n}\n","import { Subject } from '../Subject';\nimport { asyncScheduler } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { Observer, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function windowTime<T>(windowTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(\n  windowTimeSpan: number,\n  windowCreationInterval: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(\n  windowTimeSpan: number,\n  windowCreationInterval: number | null | void,\n  maxWindowSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, Observable<T>>;\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n *\n * In every window of 1 second each, emit at most 2 click events\n *\n * ```ts\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n *\n * ```ts\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with `maxWindowCount` instead of `take`\n *\n * ```ts\n * import { fromEvent, windowTime, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // take at most 2 emissions from each window\n *   mergeAll()                 // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param windowTimeSpan The amount of time, in milliseconds, to fill each window.\n * @param windowCreationInterval The interval at which to start new\n * windows.\n * @param maxWindowSize Max number of\n * values each window can emit before completion.\n * @param scheduler The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowTime<T>(windowTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, Observable<T>> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const windowCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxWindowSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active windows, their related subscriptions, and removal functions.\n    let windowRecords: WindowRecord<T>[] | null = [];\n    // If true, it means that every time we close a window, we want to start a new window.\n    // This is only really used for when *just* the time span is passed.\n    let restartOnClose = false;\n\n    const closeWindow = (record: { window: Subject<T>; subs: Subscription }) => {\n      const { window, subs } = record;\n      window.complete();\n      subs.unsubscribe();\n      arrRemove(windowRecords, record);\n      restartOnClose && startWindow();\n    };\n\n    /**\n     * Called every time we start a new window. This also does\n     * the work of scheduling the job to close the window.\n     */\n    const startWindow = () => {\n      if (windowRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const window = new Subject<T>();\n        const record = {\n          window,\n          subs,\n          seen: 0,\n        };\n        windowRecords.push(record);\n        subscriber.next(window.asObservable());\n        executeSchedule(subs, scheduler, () => closeWindow(record), windowTimeSpan);\n      }\n    };\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      // The user passed both a windowTimeSpan (required), and a creation interval\n      // That means we need to start new window on the interval, and those windows need\n      // to wait the required time span before completing.\n      executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);\n    } else {\n      restartOnClose = true;\n    }\n\n    startWindow();\n\n    /**\n     * We need to loop over a copy of the window records several times in this operator.\n     * This is to save bytes over the wire more than anything.\n     * The reason we copy the array is that reentrant code could mutate the array while\n     * we are iterating over it.\n     */\n    const loop = (cb: (record: WindowRecord<T>) => void) => windowRecords!.slice().forEach(cb);\n\n    /**\n     * Used to notify all of the windows and the subscriber in the same way\n     * in the error and complete handlers.\n     */\n    const terminate = (cb: (consumer: Observer<any>) => void) => {\n      loop(({ window }) => cb(window));\n      cb(subscriber);\n      subscriber.unsubscribe();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Notify all windows of the value.\n          loop((record) => {\n            record.window.next(value);\n            // If the window is over the max size, we need to close it.\n            maxWindowSize <= ++record.seen && closeWindow(record);\n          });\n        },\n        // Complete the windows and the downstream subscriber and clean up.\n        () => terminate((consumer) => consumer.complete()),\n        // Notify the windows and the downstream subscriber of the error and clean up.\n        (err) => terminate((consumer) => consumer.error(err))\n      )\n    );\n\n    // Additional finalization. This will be called when the\n    // destination tears down. Other finalizations are registered implicitly\n    // above via subscription.\n    return () => {\n      // Ensure that the buffer is released.\n      windowRecords = null!;\n    };\n  });\n}\n\ninterface WindowRecord<T> {\n  seen: number;\n  window: Subject<T>;\n  subs: Subscription;\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, windowToggle, EMPTY, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),\n *   mergeAll()\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits a next notification, signals that the\n * associated window should complete.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowToggle<T, O>(\n  openings: ObservableInput<O>,\n  closingSelector: (openValue: O) => ObservableInput<any>\n): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    const windows: Subject<T>[] = [];\n\n    const handleError = (err: any) => {\n      while (0 < windows.length) {\n        windows.shift()!.error(err);\n      }\n      subscriber.error(err);\n    };\n\n    innerFrom(openings).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (openValue) => {\n          const window = new Subject<T>();\n          windows.push(window);\n          const closingSubscription = new Subscription();\n          const closeWindow = () => {\n            arrRemove(windows, window);\n            window.complete();\n            closingSubscription.unsubscribe();\n          };\n\n          let closingNotifier: Observable<any>;\n          try {\n            closingNotifier = innerFrom(closingSelector(openValue));\n          } catch (err) {\n            handleError(err);\n            return;\n          }\n\n          subscriber.next(window.asObservable());\n\n          closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));\n        },\n        noop\n      )\n    );\n\n    // Subscribe to the source to get things started.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Copy the windows array before we emit to\n          // make sure we don't have issues with reentrant code.\n          const windowsCopy = windows.slice();\n          for (const window of windowsCopy) {\n            window.next(value);\n          }\n        },\n        () => {\n          // Complete all of our windows before we complete.\n          while (0 < windows.length) {\n            windows.shift()!.complete();\n          }\n          subscriber.complete();\n        },\n        handleError,\n        () => {\n          // Add this finalization so that all window subjects are\n          // disposed of. This way, if a user tries to subscribe\n          // to a window *after* the outer subscription has been unsubscribed,\n          // they will get an error, instead of waiting forever to\n          // see if a value arrives.\n          while (0 < windows.length) {\n            windows.shift()!.unsubscribe();\n          }\n        }\n      )\n    );\n  });\n}\n","import { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n *\n * Emit only the first two clicks events in every window of [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, windowWhen, interval, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    let window: Subject<T> | null;\n    let closingSubscriber: Subscriber<any> | undefined;\n\n    /**\n     * When we get an error, we have to notify both the\n     * destination subscriber and the window.\n     */\n    const handleError = (err: any) => {\n      window!.error(err);\n      subscriber.error(err);\n    };\n\n    /**\n     * Called every time we need to open a window.\n     * Recursive, as it will start the closing notifier, which\n     * inevitably *should* call openWindow -- but may not if\n     * it is a \"never\" observable.\n     */\n    const openWindow = () => {\n      // We need to clean up our closing subscription,\n      // we only cared about the first next or complete notification.\n      closingSubscriber?.unsubscribe();\n\n      // Close our window before starting a new one.\n      window?.complete();\n\n      // Start the new window.\n      window = new Subject<T>();\n      subscriber.next(window.asObservable());\n\n      // Get our closing notifier.\n      let closingNotifier: Observable<any>;\n      try {\n        closingNotifier = innerFrom(closingSelector());\n      } catch (err) {\n        handleError(err);\n        return;\n      }\n\n      // Subscribe to the closing notifier, be sure\n      // to capture the subscriber (aka Subscription)\n      // so we can clean it up when we close the window\n      // and open a new one.\n      closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));\n    };\n\n    // Start the first window.\n    openWindow();\n\n    // Subscribe to the source\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => window!.next(value),\n        () => {\n          // The source completed, close the window and complete.\n          window!.complete();\n          subscriber.complete();\n        },\n        handleError,\n        () => {\n          // Be sure to clean up our closing subscription\n          // when this tears down.\n          closingSubscriber?.unsubscribe();\n          window = null!;\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { identity } from '../util/identity';\nimport { noop } from '../util/noop';\nimport { popResultSelector } from '../util/args';\n\nexport function withLatestFrom<T, O extends unknown[]>(...inputs: [...ObservableInputTuple<O>]): OperatorFunction<T, [T, ...O]>;\n\nexport function withLatestFrom<T, O extends unknown[], R>(\n  ...inputs: [...ObservableInputTuple<O>, (...value: [T, ...O]) => R]\n): OperatorFunction<T, R>;\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * ![](withLatestFrom.png)\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * ## Example\n *\n * On every click event, emit an array with the latest timer event plus the click event\n *\n * ```ts\n * import { fromEvent, interval, withLatestFrom } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const result = clicks.pipe(withLatestFrom(timer));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return A function that returns an Observable of projected values from the\n * most recent values from each input Observable, or an array of the most\n * recent values from each input Observable.\n */\nexport function withLatestFrom<T, R>(...inputs: any[]): OperatorFunction<T, R | any[]> {\n  const project = popResultSelector(inputs) as ((...args: any[]) => R) | undefined;\n\n  return operate((source, subscriber) => {\n    const len = inputs.length;\n    const otherValues = new Array(len);\n    // An array of whether or not the other sources have emitted. Matched with them by index.\n    // TODO: At somepoint, we should investigate the performance implications here, and look\n    // into using a `Set()` and checking the `size` to see if we're ready.\n    let hasValue = inputs.map(() => false);\n    // Flipped true when we have at least one value from all other sources and\n    // we are ready to start emitting values.\n    let ready = false;\n\n    // Other sources. Note that here we are not checking `subscriber.closed`,\n    // this causes all inputs to be subscribed to, even if nothing can be emitted\n    // from them. This is an important distinction because subscription constitutes\n    // a side-effect.\n    for (let i = 0; i < len; i++) {\n      innerFrom(inputs[i]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            otherValues[i] = value;\n            if (!ready && !hasValue[i]) {\n              // If we're not ready yet, flag to show this observable has emitted.\n              hasValue[i] = true;\n              // Intentionally terse code.\n              // If all of our other observables have emitted, set `ready` to `true`,\n              // so we know we can start emitting values, then clean up the `hasValue` array,\n              // because we don't need it anymore.\n              (ready = hasValue.every(identity)) && (hasValue = null!);\n            }\n          },\n          // Completing one of the other sources has\n          // no bearing on the completion of our result.\n          noop\n        )\n      );\n    }\n\n    // Source subscription\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        if (ready) {\n          // We have at least one value from the other sources. Go ahead and emit.\n          const values = [value, ...otherValues];\n          subscriber.next(project ? project(...values) : values);\n        }\n      })\n    );\n  });\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { zip } from '../observable/zip';\nimport { joinAllInternals } from './joinAllInternals';\n\n/**\n * Collects all observable inner sources from the source, once the source completes,\n * it will subscribe to all inner sources, combining their values by index and emitting\n * them.\n *\n * @see {@link zipWith}\n * @see {@link zip}\n */\nexport function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function zipAll<T>(): OperatorFunction<any, T[]>;\nexport function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\nexport function zipAll<T, R>(project?: (...values: T[]) => R) {\n  return joinAllInternals(zip, project);\n}\n","import { zip as zipStatic } from '../observable/zip';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { operate } from '../util/lift';\n\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[]>(otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[], R>(\n  otherInputsAndProject: [...ObservableInputTuple<A>],\n  project: (...values: Cons<T, A>) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[], R>(\n  ...otherInputsAndProject: [...ObservableInputTuple<A>, (...values: Cons<T, A>) => R]\n): OperatorFunction<T, R>;\n\n/**\n * @deprecated Replaced with {@link zipWith}. Will be removed in v8.\n */\nexport function zip<T, R>(...sources: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, any> {\n  return operate((source, subscriber) => {\n    zipStatic(source as ObservableInput<any>, ...(sources as Array<ObservableInput<any>>)).subscribe(subscriber);\n  });\n}\n","import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { zip } from './zip';\n\n/**\n * Subscribes to the source, and the observable inputs provided as arguments, and combines their values, by index, into arrays.\n *\n * What is meant by \"combine by index\": The first value from each will be made into a single array, then emitted,\n * then the second value from each will be combined into a single array and emitted, then the third value\n * from each will be combined into a single array and emitted, and so on.\n *\n * This will continue until it is no longer able to combine values of the same index into an array.\n *\n * After the last value from any one completed source is emitted in an array, the resulting observable will complete,\n * as there is no way to continue \"zipping\" values together by index.\n *\n * Use-cases for this operator are limited. There are memory concerns if one of the streams is emitting\n * values at a much faster rate than the others. Usage should likely be limited to streams that emit\n * at a similar pace, or finite streams of known length.\n *\n * In many cases, authors want `combineLatestWith` and not `zipWith`.\n *\n * @param otherInputs other observable inputs to collate values from.\n * @return A function that returns an Observable that emits items by index\n * combined from the source Observable and provided Observables, in form of an\n * array.\n */\nexport function zipWith<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>> {\n  return zip(...otherInputs);\n}\n","//////////////////////////////////////////////////////////\n// Here we need to reference our other deep imports\n// so VS code will figure out where they are\n// see conversation here:\n// https://github.com/microsoft/TypeScript/issues/43034\n//////////////////////////////////////////////////////////\n\n// tslint:disable: no-reference\n// It's tempting to add references to all of the deep-import locations, but\n// adding references to those that require DOM types breaks Node projects.\n/// <reference path=\"./operators/index.ts\" />\n/// <reference path=\"./testing/index.ts\" />\n// tslint:enable: no-reference\n\n/* Observable */\nexport { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { Operator } from './internal/Operator';\nexport { observable } from './internal/symbol/observable';\nexport { animationFrames } from './internal/observable/dom/animationFrames';\n\n/* Subjects */\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\n\n/* Schedulers */\nexport { asap, asapScheduler } from './internal/scheduler/asap';\nexport { async, asyncScheduler } from './internal/scheduler/async';\nexport { queue, queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame, animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\n\n/* Subscription */\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\n\n/* Notification */\nexport { Notification, NotificationKind } from './internal/Notification';\n\n/* Utils */\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\n\n/* Promise Conversion */\nexport { lastValueFrom } from './internal/lastValueFrom';\nexport { firstValueFrom } from './internal/firstValueFrom';\n\n/* Error types */\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { NotFoundError } from './internal/util/NotFoundError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { SequenceError } from './internal/util/SequenceError';\nexport { TimeoutError } from './internal/operators/timeout';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\n\n/* Static observable creation exports */\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { connectable } from './internal/observable/connectable';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\n\n/* Constants */\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\n\n/* Types */\nexport * from './internal/types';\n\n/* Config */\nexport { config, GlobalConfig } from './internal/config';\n\n/* Operators */\nexport { audit } from './internal/operators/audit';\nexport { auditTime } from './internal/operators/auditTime';\nexport { buffer } from './internal/operators/buffer';\nexport { bufferCount } from './internal/operators/bufferCount';\nexport { bufferTime } from './internal/operators/bufferTime';\nexport { bufferToggle } from './internal/operators/bufferToggle';\nexport { bufferWhen } from './internal/operators/bufferWhen';\nexport { catchError } from './internal/operators/catchError';\nexport { combineAll } from './internal/operators/combineAll';\nexport { combineLatestAll } from './internal/operators/combineLatestAll';\nexport { combineLatestWith } from './internal/operators/combineLatestWith';\nexport { concatAll } from './internal/operators/concatAll';\nexport { concatMap } from './internal/operators/concatMap';\nexport { concatMapTo } from './internal/operators/concatMapTo';\nexport { concatWith } from './internal/operators/concatWith';\nexport { connect, ConnectConfig } from './internal/operators/connect';\nexport { count } from './internal/operators/count';\nexport { debounce } from './internal/operators/debounce';\nexport { debounceTime } from './internal/operators/debounceTime';\nexport { defaultIfEmpty } from './internal/operators/defaultIfEmpty';\nexport { delay } from './internal/operators/delay';\nexport { delayWhen } from './internal/operators/delayWhen';\nexport { dematerialize } from './internal/operators/dematerialize';\nexport { distinct } from './internal/operators/distinct';\nexport { distinctUntilChanged } from './internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from './internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from './internal/operators/elementAt';\nexport { endWith } from './internal/operators/endWith';\nexport { every } from './internal/operators/every';\nexport { exhaust } from './internal/operators/exhaust';\nexport { exhaustAll } from './internal/operators/exhaustAll';\nexport { exhaustMap } from './internal/operators/exhaustMap';\nexport { expand } from './internal/operators/expand';\nexport { filter } from './internal/operators/filter';\nexport { finalize } from './internal/operators/finalize';\nexport { find } from './internal/operators/find';\nexport { findIndex } from './internal/operators/findIndex';\nexport { first } from './internal/operators/first';\nexport { groupBy, BasicGroupByOptions, GroupByOptionsWithElement } from './internal/operators/groupBy';\nexport { ignoreElements } from './internal/operators/ignoreElements';\nexport { isEmpty } from './internal/operators/isEmpty';\nexport { last } from './internal/operators/last';\nexport { map } from './internal/operators/map';\nexport { mapTo } from './internal/operators/mapTo';\nexport { materialize } from './internal/operators/materialize';\nexport { max } from './internal/operators/max';\nexport { mergeAll } from './internal/operators/mergeAll';\nexport { flatMap } from './internal/operators/flatMap';\nexport { mergeMap } from './internal/operators/mergeMap';\nexport { mergeMapTo } from './internal/operators/mergeMapTo';\nexport { mergeScan } from './internal/operators/mergeScan';\nexport { mergeWith } from './internal/operators/mergeWith';\nexport { min } from './internal/operators/min';\nexport { multicast } from './internal/operators/multicast';\nexport { observeOn } from './internal/operators/observeOn';\nexport { onErrorResumeNextWith } from './internal/operators/onErrorResumeNextWith';\nexport { pairwise } from './internal/operators/pairwise';\nexport { pluck } from './internal/operators/pluck';\nexport { publish } from './internal/operators/publish';\nexport { publishBehavior } from './internal/operators/publishBehavior';\nexport { publishLast } from './internal/operators/publishLast';\nexport { publishReplay } from './internal/operators/publishReplay';\nexport { raceWith } from './internal/operators/raceWith';\nexport { reduce } from './internal/operators/reduce';\nexport { repeat, RepeatConfig } from './internal/operators/repeat';\nexport { repeatWhen } from './internal/operators/repeatWhen';\nexport { retry, RetryConfig } from './internal/operators/retry';\nexport { retryWhen } from './internal/operators/retryWhen';\nexport { refCount } from './internal/operators/refCount';\nexport { sample } from './internal/operators/sample';\nexport { sampleTime } from './internal/operators/sampleTime';\nexport { scan } from './internal/operators/scan';\nexport { sequenceEqual } from './internal/operators/sequenceEqual';\nexport { share, ShareConfig } from './internal/operators/share';\nexport { shareReplay, ShareReplayConfig } from './internal/operators/shareReplay';\nexport { single } from './internal/operators/single';\nexport { skip } from './internal/operators/skip';\nexport { skipLast } from './internal/operators/skipLast';\nexport { skipUntil } from './internal/operators/skipUntil';\nexport { skipWhile } from './internal/operators/skipWhile';\nexport { startWith } from './internal/operators/startWith';\nexport { subscribeOn } from './internal/operators/subscribeOn';\nexport { switchAll } from './internal/operators/switchAll';\nexport { switchMap } from './internal/operators/switchMap';\nexport { switchMapTo } from './internal/operators/switchMapTo';\nexport { switchScan } from './internal/operators/switchScan';\nexport { take } from './internal/operators/take';\nexport { takeLast } from './internal/operators/takeLast';\nexport { takeUntil } from './internal/operators/takeUntil';\nexport { takeWhile } from './internal/operators/takeWhile';\nexport { tap, TapObserver } from './internal/operators/tap';\nexport { throttle, ThrottleConfig } from './internal/operators/throttle';\nexport { throttleTime } from './internal/operators/throttleTime';\nexport { throwIfEmpty } from './internal/operators/throwIfEmpty';\nexport { timeInterval } from './internal/operators/timeInterval';\nexport { timeout, TimeoutConfig, TimeoutInfo } from './internal/operators/timeout';\nexport { timeoutWith } from './internal/operators/timeoutWith';\nexport { timestamp } from './internal/operators/timestamp';\nexport { toArray } from './internal/operators/toArray';\nexport { window } from './internal/operators/window';\nexport { windowCount } from './internal/operators/windowCount';\nexport { windowTime } from './internal/operators/windowTime';\nexport { windowToggle } from './internal/operators/windowToggle';\nexport { windowWhen } from './internal/operators/windowWhen';\nexport { withLatestFrom } from './internal/operators/withLatestFrom';\nexport { zipAll } from './internal/operators/zipAll';\nexport { zipWith } from './internal/operators/zipWith';\n","import {\n  setupWalletSelector,\n  VerifiedOwner,\n  VerifyOwnerParams,\n  Wallet,\n} from '@near-wallet-selector/core';\nimport { setupModal } from '@near-wallet-selector/modal-ui';\nimport { map, distinctUntilChanged, Subscription } from 'rxjs';\n\nimport {\n  WALLET_CONNECTION_POLL_INTERVAL,\n  WALLET_CONNECTION_TIMEOUT,\n} from './constants';\n\nimport type {\n  WalletSelector,\n  AccountState,\n  WalletModuleFactory,\n} from '@near-wallet-selector/core';\nimport type { WalletSelectorModal } from '@near-wallet-selector/modal-ui';\n\nimport { mbjs } from '@mintbase-js/sdk';\nimport { setupBitteWallet } from '@bitte-ai/wallet';\n\nimport { setupMeteorWallet } from '@near-wallet-selector/meteor-wallet';\nimport { setupHereWallet } from '@near-wallet-selector/here-wallet';\nimport { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';\n\n\nconst SUPPORT = '- further help available on our telegram channel: https://t.me/mintdev';\n\nexport const ERROR_MESSAGES =  {\n  WALLET_SETUP_NOT_CALLED_ERROR: `Call and await setupWalletSelectorComponents() before registering a subscriber - ${SUPPORT}`,\n  WALLET_CONNECTION_NOT_FOUND:  `Wallet connection not received after ${WALLET_CONNECTION_TIMEOUT}ms - ${SUPPORT}`,\n};\n\nexport const SUPPORTED_NEAR_WALLETS: Array<WalletModuleFactory> =[\n  setupMeteorWallet(),\n  setupMyNearWallet(),\n  setupHereWallet(),\n];\n\nexport type WalletSelectorComponents = {\n  selector: WalletSelector;\n  modal: WalletSelectorModal;\n}\n\n interface ConnectionTimeoutError extends Error {\n  message: string\n}\n\nconst walletUrls = {\n  testnet: 'https://testnet.wallet.bitte.ai/',\n  mainnet: 'https://wallet.bitte.ai',\n};\n\nexport const BitteWalletAuth = {\n  walletSelectorComponents: {\n    selector: null,\n    modal: null,\n  },\n  setupBitteWalletSelector: async (\n    onlyBitteWallet = false,\n    network?,\n    contractAddress?,\n    options?: { additionalWallets?: Array<WalletModuleFactory> },\n    successUrl?: string,\n    walletUrl?: string\n  ): Promise<WalletSelectorComponents> => {\n\n    if (onlyBitteWallet === false) {\n      BitteWalletAuth.walletSelectorComponents.selector = await setupWalletSelector({\n        network: network,\n        modules: [\n          setupBitteWallet({\n            walletUrl: walletUrl || walletUrls[network],\n            successUrl: successUrl || window.location.href,\n            failureUrl: successUrl || window.location.href,\n          }),\n          ...(options?.additionalWallets || []),\n          ...SUPPORTED_NEAR_WALLETS,\n        ],\n      });\n    } else {\n      BitteWalletAuth.walletSelectorComponents.selector = await setupWalletSelector({\n\n        network: network,\n        modules: [\n          setupBitteWallet({\n            walletUrl: walletUrl || walletUrls[network],\n          }),\n          ...(options?.additionalWallets || []),\n        ],\n      });\n    }\n\n    BitteWalletAuth.walletSelectorComponents.modal = setupModal(BitteWalletAuth.walletSelectorComponents.selector, {\n      contractId: contractAddress,\n    });\n\n    return BitteWalletAuth.walletSelectorComponents;\n  },\n  setupWalletSelectorComponents: async (\n    network?,\n    contractAddress?,\n    options?: { additionalWallets?: Array<WalletModuleFactory> },\n  ): Promise<WalletSelectorComponents> => {\n    const selector = await setupWalletSelector({\n      network: network,\n      debug: mbjs.keys.debugMode,\n      modules: [\n        ...SUPPORTED_NEAR_WALLETS,\n        ...(options?.additionalWallets || []),\n      ],\n    });\n\n    const modal = setupModal(selector, {\n      contractId: contractAddress,\n    });\n\n    BitteWalletAuth.walletSelectorComponents = {\n      selector,\n      modal,\n    };\n    return BitteWalletAuth.walletSelectorComponents;\n  },\n  SetupNotCalledError: class extends Error {\n    constructor(message?: string) {\n      super(message);\n      this.name = 'SetupNotCalledError';\n    }\n  },\n  ConnectionTimeoutError: class extends Error {\n    message: string\n  },\n  validateWalletComponentsAreSetup:(): void => {\n    if (!BitteWalletAuth.walletSelectorComponents.selector) {\n      throw new BitteWalletAuth.SetupNotCalledError(ERROR_MESSAGES.WALLET_SETUP_NOT_CALLED_ERROR);\n    }\n  },\n  registerWalletAccountsSubscriber: (\n    callback: (accounts: AccountState[]) => void,\n  ): Subscription => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    return BitteWalletAuth.walletSelectorComponents.selector.store.observable\n      .pipe(\n        map((state:any) => state.accounts),\n        distinctUntilChanged(),\n      )\n      .subscribe(callback);\n  },\n  timerReference: null,\n  pollForWalletConnection: async (): Promise<AccountState[]> => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n    // clear any existing timer\n    clearTimeout(BitteWalletAuth.timerReference);\n\n    const tryToResolveAccountsFromState = (\n      resolve: (value: AccountState[]) => void,\n      reject: (err: ConnectionTimeoutError) => void,\n      elapsed = 0,\n    ): void => {\n      const { accounts } =\n        BitteWalletAuth.walletSelectorComponents.selector.store.getState() || {};\n\n      // accounts present in state\n      if (accounts) {\n        resolve(accounts);\n      }\n\n      // timed out\n      if (elapsed > WALLET_CONNECTION_TIMEOUT) {\n        reject(\n          new ConnectionTimeoutError(ERROR_MESSAGES.WALLET_CONNECTION_NOT_FOUND),\n        );\n      }\n\n      // try again\n      clearTimeout(BitteWalletAuth.timerReference);\n      BitteWalletAuth.timerReference = setTimeout(\n        () =>\n          tryToResolveAccountsFromState(\n            resolve,\n            reject,\n            elapsed + WALLET_CONNECTION_POLL_INTERVAL,\n          ),\n        WALLET_CONNECTION_POLL_INTERVAL,\n      );\n    };\n\n    return new Promise((resolve, reject) =>\n      tryToResolveAccountsFromState(resolve, reject),\n    );\n  },\n  getWallet: async (): Promise<Wallet> => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    return await BitteWalletAuth.walletSelectorComponents.selector.wallet();\n  },\n  connectWalletSelector:(): void => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    BitteWalletAuth.walletSelectorComponents.modal.show();\n  },\n  disconnectFromWalletSelector: async (): Promise<void> => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    const wallet = await BitteWalletAuth.walletSelectorComponents.selector.wallet();\n    wallet.signOut();\n  },\n  getVerifiedOwner: async (\n    params: VerifyOwnerParams,\n  ): Promise<VerifiedOwner | undefined> => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    const { message, callbackUrl, meta } = params;\n\n    const wallet = await BitteWalletAuth.walletSelectorComponents.selector.wallet();\n\n    const owner = (await wallet.verifyOwner({\n      message: message,\n      callbackUrl: callbackUrl,\n      meta: meta,\n    })) as VerifiedOwner;\n\n    return owner;\n  },\n  signMessage: async (\n    params: VerifyOwnerParams,\n  ): Promise<VerifiedOwner> => {\n    const owner = await BitteWalletAuth.getVerifiedOwner(params);\n\n    return owner;\n  },\n};","\nexport const NEAR_LOGIN_CONTRACT_ID = process.env.NEAR_LOGIN_CONTRACT_ID;\n\nexport const WALLET_CONNECTION_POLL_INTERVAL = 1_000;\n// how long to wait for the user to make the connection to the wallet.\nexport const WALLET_CONNECTION_TIMEOUT = 30_000;\n\nexport const MINTBASE_CONNECT_HOST = 'https://connect.mintbase.xyz';\n// export const MINTBASE_CONNECT_HOST = 'http://localhost:8000';\n","import React, {\n  createContext,\n  JSX,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { BitteWalletAuth } from \"./wallet/bitte-wallet\";\nimport type { WalletSelectorComponents } from \"./wallet/bitte-wallet\";\n\nimport type {\n  WalletSelector,\n  AccountState,\n  VerifiedOwner,\n  VerifyOwnerParams,\n  WalletModuleFactory,\n} from \"@near-wallet-selector/core\";\nimport type { WalletSelectorModal } from \"@near-wallet-selector/modal-ui\";\n\nexport type BitteWalletContext = {\n  selector: WalletSelector;\n  modal: WalletSelectorModal | undefined;\n  accounts: AccountState[];\n  activeAccountId: string | null;\n  isConnected: boolean;\n  isWaitingForConnection: boolean;\n  isWalletSelectorSetup: boolean;\n  errorMessage: string | null;\n  connect: () => Promise<void>;\n  disconnect: () => Promise<void>;\n  signMessage: (params: VerifyOwnerParams) => Promise<VerifiedOwner>;\n};\n\ninterface ContextProviderType {\n  children: React.ReactNode;\n  callbackUrl?: string;\n  network?: string;\n  onlyMbWallet?: boolean;\n  contractAddress?: string;\n  additionalWallets?: Array<WalletModuleFactory>;\n  successUrl?: string;\n  failureUrl?: string;\n  onlyBitteWallet?: boolean;\n  walletUrl?:string\n}\n\nexport const BitteWalletContext = createContext<BitteWalletContext | null>(\n  null\n);\n\nexport const BitteWalletContextProvider: React.FC<ContextProviderType> = ({\n  children,\n  network,\n  contractAddress,\n  additionalWallets,\n  onlyBitteWallet,\n  callbackUrl,\n  successUrl,\n  walletUrl,\n}): JSX.Element => {\n  const [errorMessage, setErrorMessage] = useState<string | null>(null);\n  const [components, setComponents] = useState<WalletSelectorComponents | null>(\n    null\n  );\n  const [accounts, setAccounts] = useState<AccountState[]>([]);\n  const [isWaitingForConnection, setIsWaitingForConnection] =\n    useState<boolean>(false);\n  const [isWalletSelectorSetup, setIsWalletSelectorSetup] =\n    useState<boolean>(false);\n\n  const selectedNetwork = network;\n  const selectedContract = contractAddress;\n\n  const {\n    setupBitteWalletSelector,\n    registerWalletAccountsSubscriber,\n    connectWalletSelector,\n    pollForWalletConnection,\n    disconnectFromWalletSelector,\n    signMessage,\n  } = BitteWalletAuth;\n\n  const setupBitteWallet = async (): Promise<WalletSelectorComponents> => {\n    const isOnlyBitteWallet =\n      !!onlyBitteWallet ||\n      !!(additionalWallets && additionalWallets.length > 0);\n\n\n    return await setupBitteWalletSelector(\n      isOnlyBitteWallet,\n      selectedNetwork,\n      selectedContract,\n     {additionalWallets: additionalWallets },\n      successUrl,\n      walletUrl\n    );\n  };\n\n  const setup = useCallback(async () => {\n    const components = await setupBitteWallet();\n\n    setIsWalletSelectorSetup(true);\n    setComponents(components);\n  }, []);\n\n  const onCloseModal = (): void => {\n    setIsWaitingForConnection(false);\n  };\n\n  const setupWallet = async (): Promise<WalletSelectorComponents> => {\n    const components = await setupBitteWallet();\n\n    return components;\n  };\n\n  // call setup on wallet selector\n\n  useEffect(() => {\n    setupWallet();\n\n    setup().catch((err: Error) => {\n      if (err instanceof Error && err.message.length > 0) {\n        setErrorMessage(err.message);\n      }\n    });\n\n    // Add the event listener here\n    const closeButton = document?.getElementsByClassName(\"close-button\")[0];\n    closeButton?.addEventListener(\"click\", onCloseModal);\n\n    // Cleanup the event listener on unmount\n    return (): void => {\n      closeButton?.removeEventListener(\"click\", onCloseModal);\n    };\n  }, [setup]);\n\n  // subscribe to account state changes\n  useEffect(() => {\n    if (!components) {\n      return undefined;\n    }\n\n    const subscription = registerWalletAccountsSubscriber(\n      (accounts: AccountState[]) => {\n        setAccounts(accounts);\n      }\n    );\n\n    return (): void => {\n      subscription.unsubscribe();\n    };\n  }, [components]);\n\n  const { selector, modal } = components || {};\n\n\n\n  const connect = async (): Promise<void> => {\n    setIsWaitingForConnection(true);\n\n    setErrorMessage(null);\n    connectWalletSelector();\n\n    try {\n      const accounts = await pollForWalletConnection();\n      setIsWaitingForConnection(false);\n      setAccounts(accounts);\n    } catch (err: unknown) {\n      if (err) {\n        setErrorMessage((err as Error).message);\n      }\n    }\n  };\n\n  const disconnect = async (): Promise<void> => {\n    await disconnectFromWalletSelector();\n    setIsWaitingForConnection(false);\n  };\n\n  const contextVal = useMemo<BitteWalletContext>(\n    () => ({\n      selector: selector as WalletSelector,\n      modal: modal,\n      accounts: accounts,\n      activeAccountId:\n        accounts.find((account) => account.active)?.accountId || null,\n      isConnected: accounts && accounts.length > 0,\n      isWaitingForConnection: isWaitingForConnection,\n      isWalletSelectorSetup: isWalletSelectorSetup,\n      errorMessage: errorMessage,\n      connect,\n      disconnect,\n      signMessage,\n    }),\n    [selector, modal, accounts]\n  );\n\n  return (\n    <BitteWalletContext.Provider value={contextVal}>\n      {children}\n    </BitteWalletContext.Provider>\n  );\n};\n\nexport const useBitteWallet = (): BitteWalletContext => {\n  const context = useContext(BitteWalletContext);\n  if (!context) {\n    throw new Error(\n      \"useBitteWallet must be used within a BitteWalletContextProvider\"\n    );\n  }\n  return context;\n};\n","import { useEffect, useState } from 'react';\nimport { nearPrice } from '@mintbase-js/data';\n\ntype UseNearPriceReturn = {\n  nearPrice: number;\n  error: string | null;\n}\n\nexport const useNearPrice = (): UseNearPriceReturn => {\n  const [price, setPrice] = useState<number>(0);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const nearPriceData = async (): Promise<void> => {\n      const { data, error } = await nearPrice();\n      if (error) {\n        setError(error);\n        return;\n      }\n      setPrice(Number(data));\n    };\n    nearPriceData();\n  }, []);\n\n  return {\n    nearPrice: price,\n    error,\n  };\n};\n"]}