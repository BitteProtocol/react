{"version":3,"sources":["../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isFunction.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/createErrorClass.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/arrRemove.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/Subscription.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/config.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/reportUnhandledError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/noop.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/NotificationFactories.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/errorContext.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/Subscriber.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/symbol/observable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/identity.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/pipe.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/Observable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/lift.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/OperatorSubscriber.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/refCount.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/ConnectableObservable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/performanceTimestampProvider.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/animationFrameProvider.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/dom/animationFrames.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/Subject.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/BehaviorSubject.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/dateTimestampProvider.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/ReplaySubject.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/AsyncSubject.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/Action.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/intervalProvider.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/Immediate.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/immediateProvider.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AsapAction.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/Scheduler.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/asap.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/async.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/QueueAction.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/queue.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/animationFrame.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/empty.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isScheduler.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/args.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isArrayLike.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isPromise.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isInteropObservable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isAsyncIterable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/throwUnobservableError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/symbol/iterator.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isIterable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isReadableStreamLike.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/innerFrom.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/executeSchedule.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/observeOn.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/subscribeOn.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduled/scheduleObservable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduled/schedulePromise.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduled/scheduleArray.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduled/scheduleIterable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduled/scheduleAsyncIterable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduled/scheduled.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/from.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/of.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/throwError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/Notification.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isObservable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/EmptyError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/lastValueFrom.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/firstValueFrom.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/NotFoundError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/SequenceError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/isDate.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/timeout.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/map.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/mapOneOrManyArgs.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/bindCallbackInternals.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/bindCallback.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/bindNodeCallback.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/argsArgArrayOrObject.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/createObject.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/combineLatest.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/mergeInternals.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/mergeMap.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/mergeAll.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/concatAll.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/concat.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/defer.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/connectable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/forkJoin.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/fromEvent.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/fromEventPattern.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/generate.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/iif.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/timer.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/interval.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/merge.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/never.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/argsOrArgArray.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/onErrorResumeNext.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/pairs.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/not.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/filter.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/partition.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/race.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/range.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/using.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/zip.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/cjs/internal/types.js","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/audit.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/auditTime.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/buffer.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/bufferCount.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/bufferTime.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/bufferToggle.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/bufferWhen.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/catchError.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/scanInternals.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/reduce.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/toArray.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/joinAllInternals.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/combineLatestAll.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/combineAll.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/combineLatest.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/combineLatestWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/concatMap.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/concatMapTo.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/concat.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/concatWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/fromSubscribable.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/connect.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/count.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/debounce.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/debounceTime.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/defaultIfEmpty.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/take.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/ignoreElements.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/mapTo.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/delayWhen.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/delay.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/dematerialize.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/distinct.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/distinctUntilChanged.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/distinctUntilKeyChanged.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/throwIfEmpty.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/elementAt.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/endWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/every.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/exhaustMap.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/exhaustAll.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/exhaust.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/expand.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/finalize.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/find.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/findIndex.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/first.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/groupBy.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/isEmpty.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/takeLast.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/last.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/materialize.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/max.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/flatMap.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/mergeMapTo.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/mergeScan.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/merge.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/mergeWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/min.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/multicast.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/onErrorResumeNextWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/pairwise.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/pluck.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/publish.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/publishBehavior.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/publishLast.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/publishReplay.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/raceWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/repeat.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/repeatWhen.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/retry.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/retryWhen.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/sample.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/sampleTime.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/scan.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/sequenceEqual.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/share.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/shareReplay.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/single.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/skip.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/skipLast.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/skipUntil.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/skipWhile.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/startWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/switchMap.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/switchAll.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/switchMapTo.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/switchScan.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/takeUntil.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/takeWhile.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/tap.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/throttle.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/throttleTime.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/timeInterval.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/timeoutWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/timestamp.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/window.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/windowCount.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/windowTime.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/windowToggle.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/windowWhen.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/withLatestFrom.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/zipAll.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/zip.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/operators/zipWith.ts","../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/src/index.ts","../src/wallet/bitte-wallet.ts","../src/wallet/constants.ts","../src/BitteWalletContext.tsx","../src/hooks/useNearPrice.ts"],"names":["isFunction","value","exports","createErrorClass","createImpl","_super","instance","ctorFunc","createErrorClass_1","errors","err","arrRemove","arr","item","index","isFunction_1","UnsubscriptionError_1","arrRemove_1","Subscription","initialTeardown","_parentage","_parentage_1","__values","_parentage_1_1","parent_1","initialFinalizer","e","_finalizers","_finalizers_1","_finalizers_1_1","finalizer","execFinalizer","__spreadArray","__read","teardown","_a","parent","empty","isSubscription","handler","timeout","args","_i","delegate","handle","config_1","timeoutProvider_1","reportUnhandledError","onUnhandledError","noop","createNotification","errorNotification","error","nextNotification","kind","context","errorContext","cb","isRoot","errorThrown","captureError","Subscription_1","reportUnhandledError_1","noop_1","NotificationFactories_1","errorContext_1","Subscriber","__extends","destination","_this","next","complete","SafeSubscriber","handleStoppedNotification","_bind","bind","fn","thisArg","ConsumerObserver","partialObserver","handleUnhandledError","observerOrNext","context_1","defaultErrorHandler","notification","subscriber","onStoppedNotification","identity","x","identity_1","pipe","fns","pipeFromArray","input","prev","Subscriber_1","observable_1","pipe_1","Observable","subscribe","operator","observable","isSubscriber","source","sink","promiseCtor","getPromiseCtor","resolve","reject","operations","isObserver","hasLift","operate","init","liftedSource","createOperatorSubscriber","onNext","onComplete","onError","onFinalize","OperatorSubscriber","shouldUnsubscribe","closed_1","lift_1","OperatorSubscriber_1","refCount","connection","refCounter","sharedConnection","conn","Observable_1","refCount_1","ConnectableObservable","subjectFactory","subject","_connection","subject_1","callback","request","cancel","timestamp","performanceTimestampProvider_1","animationFrameProvider_1","animationFrames","timestampProvider","animationFramesFactory","DEFAULT_ANIMATION_FRAMES","provider","start","id","run","now","ObjectUnsubscribedError_1","Subject","AnonymousSubject","_b","_c","observer","observers","hasError","isStopped","thrownError","Subject_1","BehaviorSubject","_value","subscription","dateTimestampProvider_1","ReplaySubject","_bufferSize","_windowTime","_timestampProvider","_buffer","_infiniteTimeWindow","copy","i","adjustedBufferSize","last","AsyncSubject","_hasValue","_isComplete","Action","scheduler","work","state","delay","Action_1","intervalProvider_1","AsyncAction","_id","_scheduler","_delay","errored","errorValue","actions","nextHandle","resolved","activeHandles","findAndClearHandle","Immediate_1","setImmediate","clearImmediate","AsyncAction_1","immediateProvider_1","AsapAction","Scheduler","schedulerActionCtor","Scheduler_1","AsyncScheduler","SchedulerAction","action","AsyncScheduler_1","AsapScheduler","flushId","AsapAction_1","AsapScheduler_1","QueueAction","QueueScheduler","QueueAction_1","QueueScheduler_1","AnimationFrameAction","AnimationFrameScheduler","AnimationFrameAction_1","AnimationFrameScheduler_1","VirtualTimeScheduler","maxFrames","VirtualAction","a","b","emptyScheduled","isScheduler","isScheduler_1","popResultSelector","popScheduler","popNumber","defaultValue","isPromise","isInteropObservable","isAsyncIterable","obj","createInvalidObservableTypeError","getSymbolIterator","iterator_1","isIterable","readableStreamLikeToAsyncGenerator","readableStream","reader","__await","done","isReadableStreamLike","isArrayLike_1","isPromise_1","isInteropObservable_1","isAsyncIterable_1","throwUnobservableError_1","isIterable_1","isReadableStreamLike_1","innerFrom","fromInteropObservable","fromArrayLike","fromPromise","fromAsyncIterable","fromIterable","fromReadableStreamLike","obs","array","promise","iterable","iterable_1","iterable_1_1","asyncIterable","process","asyncIterable_1","__asyncValues","asyncIterable_1_1","executeSchedule","parentSubscription","repeat","scheduleSubscription","executeSchedule_1","observeOn","subscribeOn","innerFrom_1","observeOn_1","subscribeOn_1","scheduleObservable","schedulePromise","scheduleArray","scheduleIterable","iterator","scheduleAsyncIterable","result","scheduleAsyncIterable_1","scheduleReadableStreamLike","scheduleObservable_1","schedulePromise_1","scheduleArray_1","scheduleIterable_1","scheduleReadableStreamLike_1","scheduled","scheduled_1","from","args_1","from_1","of","throwError","errorOrErrorFactory","errorFactory","empty_1","of_1","throwError_1","NotificationKind","Notification","observeNotification","nextHandler","errorHandler","completeHandler","nextOrObserver","_d","isObservable","EmptyError_1","lastValueFrom","config","hasConfig","firstValueFrom","message","isValidDate","async_1","isDate_1","info","schedulerArg","first","each","_with","timeoutErrorFactory","meta","originalSourceSubscription","timerSubscription","lastValue","seen","startTimer","map","project","map_1","isArray","callOrApply","mapOneOrManyArgs","mapOneOrManyArgs_1","AsyncSubject_1","bindCallbackInternals","isNodeStyle","callbackFunc","resultSelector","uninitialized","subs","isAsync_1","isComplete_1","results","bindCallbackInternals_1","bindCallback","bindNodeCallback","getPrototypeOf","objectProto","getKeys","argsArgArrayOrObject","first_1","isPOJO","keys","key","createObject","values","argsArgArrayOrObject_1","createObject_1","combineLatest","observables","combineLatestInit","valueTransform","maybeSchedule","length","active","remainingFirstValues","hasFirstValue","execute","mergeInternals","concurrent","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","bufferedValue","mergeInternals_1","mergeMap","ii","mergeMap_1","mergeAll","mergeAll_1","concatAll","concatAll_1","concat","defer","observableFactory","defer_1","DEFAULT_CONFIG","connectable","connector","resetOnDisconnect","forkJoin","sources","remainingCompletions","remainingEmissions","sourceIndex","hasValue","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","options","isEventTarget","methodName","isNodeStyleEventEmitter","toCommonHandlerRegistry","isJQueryStyleEventEmitter","add","remove","subTarget","fromEventPattern","addHandler","removeHandler","retValue","generate","initialStateOrOptions","condition","iterate","resultSelectorOrScheduler","initialState","gen","iif","trueResult","falseResult","timer","dueTime","intervalOrScheduler","intervalDuration","due","n","timer_1","interval","period","merge","never","argsOrArgArray","argsOrArgArray_1","onErrorResumeNext","nextSources","subscribeNext","nextSource","innerSubscriber","pairs","not","pred","filter","predicate","not_1","filter_1","partition","race","raceInit","subscriptions","s","range","count","end","using","resourceFactory","resource","zip","buffers","completed","require_types","__commonJSMin","audit","durationSelector","durationSubscriber","endDuration","cleanupDuration","audit_1","auditTime","duration","closingNotifier","currentBuffer","bufferCount","bufferSize","startBufferEvery","toEmit","buffers_1","buffers_1_1","toEmit_1","toEmit_1_1","buffers_2","buffers_2_1","bufferTime","bufferTimeSpan","otherArgs","bufferCreationInterval","maxBufferSize","bufferRecords","restartOnEmit","emit","record","startBuffer","record_1","bufferTimeSubscriber","recordsCopy","recordsCopy_1","recordsCopy_1_1","bufferToggle","openings","closingSelector","openValue","closingSubscription","emitBuffer","bufferWhen","closingSubscriber","openBuffer","catchError","selector","innerSub","syncUnsub","handledResult","scanInternals","accumulator","seed","hasSeed","emitOnNext","emitBeforeComplete","hasState","scanInternals_1","reduce","reduce_1","arrReducer","toArray","toArray_1","joinAllInternals","joinFn","combineLatest_1","joinAllInternals_1","combineLatestAll","combineLatestAll_1","combineLatestWith","otherSources","concatMap","concatMap_1","concatMapTo","innerObservable","concat_1","concatWith","fromSubscribable","subscribable","fromSubscribable_1","connect","total","debounce","debounceTime","activeTask","lastTime","emitWhenIdle","targetTime","defaultIfEmpty","take","ignoreElements","mapTo","take_1","ignoreElements_1","mapTo_1","delayWhen","delayDurationSelector","subscriptionDelay","delayWhen_1","Notification_1","dematerialize","distinct","keySelector","flushes","distinctKeys","distinctUntilChanged","comparator","defaultCompare","previousKey","currentKey","distinctUntilChanged_1","distinctUntilKeyChanged","compare","y","throwIfEmpty","defaultErrorFactory","ArgumentOutOfRangeError_1","throwIfEmpty_1","defaultIfEmpty_1","elementAt","hasDefaultValue","v","endWith","every","exhaustMap","outerValue","exhaustMap_1","exhaustAll","exhaustAll_1","finalize","find","createFind","findIndex","find_1","groupBy","elementOrOptions","element","groups","notify","handleError","consumer","activeGroups","teardownAttempted","groupBySourceSubscriber","key_1","group_1","grouped","createGroupedObservable","durationSubscriber_1","groupSubject","groupSubscriber","isEmpty","takeLast","buffer_1","buffer_1_1","takeLast_1","materialize","max","comparer","mergeMapTo","mergeScan","merge_1","mergeWith","min","ConnectableObservable_1","connect_1","multicast","subjectOrSubjectFactory","onErrorResumeNext_1","onErrorResumeNextWith","pairwise","hasPrev","p","pluck","properties","currentProp","multicast_1","publish","BehaviorSubject_1","publishBehavior","initialValue","publishLast","ReplaySubject_1","publishReplay","windowTime","selectorOrScheduler","race_1","raceWith","countOrConfig","soFar","sourceSub","resubscribe","notifier","notifierSubscriber_1","subscribeToSource","repeatWhen","syncResub","completions$","isNotifierComplete","isMainComplete","getCompletionSubject","subscribeForRepeatWhen","retry","configOrCount","resetOnSuccess","subscribeForRetry","resub_1","retryWhen","errors$","subscribeForRetryWhen","sample","sample_1","interval_1","sampleTime","scan","sequenceEqual","compareTo","aState","createState","bState","isEqual","createSubscriber","selfState","otherState","sequenceEqualSubscriber","share","resetOnError","resetOnComplete","resetOnRefCountZero","wrapperSource","resetConnection","hasCompleted","hasErrored","cancelReset","reset","resetAndUnsubscribe","dest","handleReset","on","onSubscriber","share_1","shareReplay","configOrBufferSize","SequenceError_1","NotFoundError_1","single","singleValue","seenValue","skip","_","skipLast","skipCount","ring","valueIndex","oldValue","skipUntil","taking","skipSubscriber","skipWhile","startWith","switchMap","innerIndex","outerIndex","switchMap_1","switchAll","switchMapTo","switchScan","takeUntil","takeWhile","inclusive","tap","tapObserver","isUnsub","throttle","leading","trailing","sendValue","throttled","endThrottling","send","cleanupThrottling","startThrottle","throttle_1","throttleTime","duration$","timeInterval","TimeInterval","timeout_1","timeoutWith","withObservable","window","windowBoundaries","windowSubject","windowCount","windowSize","startWindowEvery","startEvery","windows","windows_1","windows_1_1","window_1","c","window_2","windowTimeSpan","windowCreationInterval","maxWindowSize","windowRecords","restartOnClose","closeWindow","startWindow","loop","terminate","windowToggle","windowsCopy","windowsCopy_1","windowsCopy_1_1","windowWhen","openWindow","withLatestFrom","inputs","len","otherValues","ready","zip_1","zipAll","zipWith","otherInputs","animationFrames_1","asap_1","queue_1","animationFrame_1","VirtualTimeScheduler_1","isObservable_1","lastValueFrom_1","firstValueFrom_1","bindCallback_1","bindNodeCallback_1","connectable_1","forkJoin_1","fromEvent_1","fromEventPattern_1","generate_1","iif_1","never_1","pairs_1","partition_1","range_1","using_1","empty_2","never_2","__exportStar","auditTime_1","bufferCount_1","bufferTime_1","bufferToggle_1","bufferWhen_1","catchError_1","combineAll_1","combineLatestWith_1","concatMapTo_1","concatWith_1","count_1","debounce_1","debounceTime_1","delay_1","dematerialize_1","distinct_1","distinctUntilKeyChanged_1","elementAt_1","endWith_1","every_1","exhaust_1","expand_1","finalize_1","findIndex_1","groupBy_1","isEmpty_1","last_1","materialize_1","max_1","flatMap_1","mergeMapTo_1","mergeScan_1","mergeWith_1","min_1","onErrorResumeNextWith_1","pairwise_1","pluck_1","publish_1","publishBehavior_1","publishLast_1","publishReplay_1","raceWith_1","repeat_1","repeatWhen_1","retry_1","retryWhen_1","sampleTime_1","scan_1","sequenceEqual_1","shareReplay_1","single_1","skip_1","skipLast_1","skipUntil_1","skipWhile_1","startWith_1","switchAll_1","switchMapTo_1","switchScan_1","takeUntil_1","takeWhile_1","tap_1","throttleTime_1","timeInterval_1","timeout_2","timeoutWith_1","timestamp_1","windowCount_1","windowTime_1","windowToggle_1","windowWhen_1","withLatestFrom_1","zipAll_1","zipWith_1","import_rxjs","WALLET_CONNECTION_POLL_INTERVAL","WALLET_CONNECTION_TIMEOUT","SUPPORT","ERROR_MESSAGES","SUPPORTED_NEAR_WALLETS","setupMeteorWallet","setupMyNearWallet","setupHereWallet","walletUrls","BitteWalletAuth","onlyBitteWallet","network","contractAddress","walletUrl","setupWalletSelector","setupBitteWallet","setupModal","modal","tryToResolveAccountsFromState","elapsed","accounts","params","callbackUrl","BitteWalletContext","createContext","BitteWalletContextProvider","children","additionalWallets","errorMessage","setErrorMessage","useState","components","setComponents","setAccounts","isWaitingForConnection","setIsWaitingForConnection","isWalletSelectorSetup","setIsWalletSelectorSetup","selectedNetwork","setupBitteWalletSelector","registerWalletAccountsSubscriber","connectWalletSelector","pollForWalletConnection","disconnectFromWalletSelector","signMessage","isOnlyBitteWallet","setup","useCallback","onCloseModal","setupWallet","useEffect","closeButton","disconnect","contextVal","useMemo","account","jsx","useBitteWallet","useContext","useNearPrice","price","setPrice","setError","data","nearPrice","BINANCE_API"],"mappings":"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A,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,GAAAA,EAAAA,CAAAA,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,IAAA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KAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,GAAAA,EAAAA,CAAAA,SAAAA,QAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,QAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,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AAA,CAAAA,CAAAA,EAAAA,IAAAA,CAAAA,OAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,KAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,KAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,GAAAA,EAAAA,CAAAA,SAAAA,QAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,QAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CA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","file":"index.js","sourcesContent":["/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n","/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n */\nexport class Subscription implements SubscriptionLike {\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n","import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param value The `next` value.\n   */\n  next(value: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param err The `error` exception.\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as ((value: T) => void) | undefined,\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent.\n * @param subscriber The stopped subscriber.\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n","/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @param subscribe The function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @param subscribe the subscriber function to be passed to the Observable constructor\n   * @return A new observable.\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @param operator the operator defining the operation to take on the observable\n   * @return A new observable with the Operator applied.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param observerOrNext Either an {@link Observer} with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @param error A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param complete A handler for a terminal event resulting from successful completion.\n   * @return A subscription reference to the registered handlers.\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next A handler for each value emitted by the observable.\n   * @return A promise that either resolves on observable completion or\n   * rejects with the handled error.\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @return This instance of the observable.\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @return The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n","import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n","import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n","import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n","import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n","import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return Observable that this Subject casts to.\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n","import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n","import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param _bufferSize The size of the buffer to replay on subscription\n   * @param _windowTime The amount of time the buffered items will stay buffered\n   * @param _timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param state Some contextual data that the `work` function uses when called by the\n   * Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is implicit\n   * and defined by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n","let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n","import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param work A function representing a task, or some unit of work to be\n   * executed by the Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is\n   * implicit and defined by the Scheduler itself.\n   * @param state Some contextual data that the `work` function uses when called\n   * by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && id === scheduler._scheduled && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    let flushId;\n    if (action) {\n      flushId = action.id;\n    } else {\n      flushId = this._scheduled;\n      this._scheduled = undefined;\n    }\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');","import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n","import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n","import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n","/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n","import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n","import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n","import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n","/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n","import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n","import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n","import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param input A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param scheduler An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return An Observable converted from {@link ObservableInput}.\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n","import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param args A comma separated list of arguments you want to be emitted.\n * @return An Observable that synchronously emits the arguments described\n * above and then immediately completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n","import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param value The `next` value.\n   * @return The \"next\" Notification representing the argument.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param err The `error` error.\n   * @return The \"error\" Notification representing the argument.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return The valueless \"complete\" Notification.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n","/** prettier */\nimport { Observable } from '../Observable';\nimport { isFunction } from './isFunction';\n\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\nexport function isObservable(obj: any): obj is Observable<unknown> {\n  // The !! is to ensure that this publicly exposed function returns\n  // `false` if something like `null` or `0` is passed.\n  return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass(\n  (_super) =>\n    function EmptyErrorImpl(this: any) {\n      _super(this);\n      this.name = 'EmptyError';\n      this.message = 'no elements in sequence';\n    }\n);\n","import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\n\nexport interface LastValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * waiting for it to complete, and resolving the returned promise with the\n * last value from the observed stream.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will complete. If the source\n * observable does not complete, you will end up with a promise that is hung up, and\n * potentially all of the state of an async function hanging out in memory. To avoid\n * this situation, look into adding something like {@link timeout}, {@link take},\n * {@link takeWhile}, or {@link takeUntil} amongst others.\n *\n * ## Example\n *\n * Wait for the last value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, take, lastValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000).pipe(take(10));\n *   const finalNumber = await lastValueFrom(source$);\n *   console.log(`The final number is ${ finalNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The final number is 9'\n * ```\n *\n * @see {@link firstValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    let _hasValue = false;\n    let _value: T;\n    source.subscribe({\n      next: (value) => {\n        _value = value;\n        _hasValue = true;\n      },\n      error: reject,\n      complete: () => {\n        if (_hasValue) {\n          resolve(_value);\n        } else if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n  });\n}\n","import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\n\nexport interface FirstValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * and returning a promise that will resolve as soon as the first value\n * arrives from the observable. The subscription will then be closed.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\n * *OR* complete. If the source observable does not emit one value or complete, you will\n * end up with a promise that is hung up, and potentially all of the state of an\n * async function hanging out in memory. To avoid this situation, look into adding\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\n * amongst others.\n *\n * ## Example\n *\n * Wait for the first value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, firstValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000);\n *   const firstNumber = await firstValueFrom(source$);\n *   console.log(`The first number is ${ firstNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The first number is 0'\n * ```\n *\n * @see {@link lastValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    const subscriber = new SafeSubscriber<T>({\n      next: (value) => {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: () => {\n        if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n    source.subscribe(subscriber);\n  });\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n","/**\n * Checks to see if a value is not only a `Date` object,\n * but a *valid* `Date` object that can be converted to a\n * number. For example, `new Date('blah')` is indeed an\n * `instanceof Date`, however it cannot be converted to a\n * number.\n */\nexport function isValidDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(value as any);\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param project The function to apply to each `value` emitted by the source\n * Observable. The `index` parameter is the number `i` for the i-th emission\n * that has happened since the subscription, starting from the number `0`.\n * @param thisArg An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n","import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}","import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { Observable } from '../Observable';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { observeOn } from '../operators/observeOn';\nimport { AsyncSubject } from '../AsyncSubject';\n\nexport function bindCallbackInternals(\n  isNodeStyle: boolean,\n  callbackFunc: any,\n  resultSelector?: any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<unknown> {\n  if (resultSelector) {\n    if (isScheduler(resultSelector)) {\n      scheduler = resultSelector;\n    } else {\n      // The user provided a result selector.\n      return function (this: any, ...args: any[]) {\n        return (bindCallbackInternals(isNodeStyle, callbackFunc, scheduler) as any)\n          .apply(this, args)\n          .pipe(mapOneOrManyArgs(resultSelector as any));\n      };\n    }\n  }\n\n  // If a scheduler was passed, use our `subscribeOn` and `observeOn` operators\n  // to compose that behavior for the user.\n  if (scheduler) {\n    return function (this: any, ...args: any[]) {\n      return (bindCallbackInternals(isNodeStyle, callbackFunc) as any)\n        .apply(this, args)\n        .pipe(subscribeOn(scheduler!), observeOn(scheduler!));\n    };\n  }\n\n  return function (this: any, ...args: any[]): Observable<any> {\n    // We're using AsyncSubject, because it emits when it completes,\n    // and it will play the value to all late-arriving subscribers.\n    const subject = new AsyncSubject<any>();\n\n    // If this is true, then we haven't called our function yet.\n    let uninitialized = true;\n    return new Observable((subscriber) => {\n      // Add our subscriber to the subject.\n      const subs = subject.subscribe(subscriber);\n\n      if (uninitialized) {\n        uninitialized = false;\n        // We're going to execute the bound function\n        // This bit is to signal that we are hitting the callback asynchronously.\n        // Because we don't have any anti-\"Zalgo\" guarantees with whatever\n        // function we are handed, we use this bit to figure out whether or not\n        // we are getting hit in a callback synchronously during our call.\n        let isAsync = false;\n\n        // This is used to signal that the callback completed synchronously.\n        let isComplete = false;\n\n        // Call our function that has a callback. If at any time during this\n        // call, an error is thrown, it will be caught by the Observable\n        // subscription process and sent to the consumer.\n        callbackFunc.apply(\n          // Pass the appropriate `this` context.\n          this,\n          [\n            // Pass the arguments.\n            ...args,\n            // And our callback handler.\n            (...results: any[]) => {\n              if (isNodeStyle) {\n                // If this is a node callback, shift the first value off of the\n                // results and check it, as it is the error argument. By shifting,\n                // we leave only the argument(s) we want to pass to the consumer.\n                const err = results.shift();\n                if (err != null) {\n                  subject.error(err);\n                  // If we've errored, we can stop processing this function\n                  // as there's nothing else to do. Just return to escape.\n                  return;\n                }\n              }\n              // If we have one argument, notify the consumer\n              // of it as a single value, otherwise, if there's more than one, pass\n              // them as an array. Note that if there are no arguments, `undefined`\n              // will be emitted.\n              subject.next(1 < results.length ? results : results[0]);\n              // Flip this flag, so we know we can complete it in the synchronous\n              // case below.\n              isComplete = true;\n              // If we're not asynchronous, we need to defer the `complete` call\n              // until after the call to the function is over. This is because an\n              // error could be thrown in the function after it calls our callback,\n              // and if that is the case, if we complete here, we are unable to notify\n              // the consumer than an error occurred.\n              if (isAsync) {\n                subject.complete();\n              }\n            },\n          ]\n        );\n        // If we flipped `isComplete` during the call, we resolved synchronously,\n        // notify complete, because we skipped it in the callback to wait\n        // to make sure there were no errors during the call.\n        if (isComplete) {\n          subject.complete();\n        }\n\n        // We're no longer synchronous. If the callback is called at this point\n        // we can notify complete on the spot.\n        isAsync = true;\n      }\n\n      // Return the subscription from adding our subscriber to the subject.\n      return subs;\n    });\n  };\n}\n","/* @prettier */\nimport { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { bindCallbackInternals } from './bindCallbackInternals';\n\nexport function bindCallback(\n  callbackFunc: (...args: any[]) => void,\n  resultSelector: (...args: any[]) => any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any>;\n\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\nexport function bindCallback<A extends readonly unknown[], R extends readonly unknown[]>(\n  callbackFunc: (...args: [...A, (...res: R) => void]) => void,\n  schedulerLike?: SchedulerLike\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\n\n/**\n * Converts a callback API to a function that returns an Observable.\n *\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n * it will return a function `g` that when called as `g(x)` will output an\n * Observable.</span>\n *\n * `bindCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters. The\n * last parameter must be a callback function that `func` calls when it is\n * done.\n *\n * The output of `bindCallback` is a function that takes the same parameters\n * as `func`, except the last one (the callback). When the output function\n * is called with arguments it will return an Observable. If function `func`\n * calls its callback with one argument, the Observable will emit that value.\n * If on the other hand the callback is called with multiple values the resulting\n * Observable will emit an array with said values as arguments.\n *\n * It is **very important** to remember that input function `func` is not called\n * when the output function is, but rather when the Observable returned by the output\n * function is subscribed. This means if `func` makes an AJAX request, that request\n * will be made every time someone subscribes to the resulting Observable, but not before.\n *\n * The last optional parameter - `scheduler` - can be used to control when the call\n * to `func` happens after someone subscribes to Observable, as well as when results\n * passed to callback will be emitted. By default, the subscription to an Observable calls `func`\n * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler\n * and call `subscribe` on the output Observable, all function calls that are currently executing\n * will end before `func` is invoked.\n *\n * By default, results passed to the callback are emitted immediately after `func` invokes the callback.\n * In particular, if the callback is called synchronously, then the subscription of the resulting Observable\n * will call the `next` function synchronously as well.  If you want to defer that call,\n * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n *\n * Note that the Observable created by the output function will always emit a single value\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n * calls will not appear in the stream. If you need to listen for multiple calls,\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n *\n * If `func` depends on some context (`this` property) and is not already bound, the context of `func`\n * will be the context that the output function has at call time. In particular, if `func`\n * is called as a method of some object and if `func` is not already bound, in order to preserve the context\n * it is recommended that the context of the output function is set to that object as well.\n *\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n * provides convenient error handling and probably is a better choice.\n * `bindCallback` will treat such functions the same as any other and error parameters\n * (whether passed or not) will always be interpreted as regular callback argument.\n *\n * ## Examples\n *\n * Convert jQuery's getJSON to an Observable API\n *\n * ```ts\n * import { bindCallback } from 'rxjs';\n * import * as jQuery from 'jquery';\n *\n * // Suppose we have jQuery.getJSON('/my/url', callback)\n * const getJSONAsObservable = bindCallback(jQuery.getJSON);\n * const result = getJSONAsObservable('/my/url');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * Receive an array of arguments passed to a callback\n *\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const someFunction = (n, s, cb) => {\n *   cb(n, s, { someProperty: 'someValue' });\n * };\n *\n * const boundSomeFunction = bindCallback(someFunction);\n * boundSomeFunction(5, 'some string').subscribe((values) => {\n *   console.log(values); // [5, 'some string', {someProperty: 'someValue'}]\n * });\n * ```\n *\n * Compare behaviour with and without `asyncScheduler`\n *\n * ```ts\n * import { bindCallback, asyncScheduler } from 'rxjs';\n *\n * function iCallMyCallbackSynchronously(cb) {\n *   cb();\n * }\n *\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);\n *\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\n * console.log('This happened...');\n *\n * // Logs:\n * // I was sync!\n * // This happened...\n * // I was async!\n * ```\n *\n * Use `bindCallback` on an object method\n *\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const boundMethod = bindCallback(someObject.methodWithCallback);\n * boundMethod\n *   .call(someObject) // make sure methodWithCallback has access to someObject\n *   .subscribe(subscriber);\n * ```\n *\n * @see {@link bindNodeCallback}\n * @see {@link from}\n *\n * @param callbackFunc A function with a callback as the last parameter.\n * @param resultSelector A mapping function used to transform callback events.\n * @param scheduler The scheduler on which to schedule the callbacks.\n * @return A function which returns the Observable that delivers the same\n * values the callback would deliver.\n */\nexport function bindCallback(\n  callbackFunc: (...args: [...any[], (...res: any) => void]) => void,\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<unknown> {\n  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\n}\n","/* @prettier */\nimport { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { bindCallbackInternals } from './bindCallbackInternals';\n\nexport function bindNodeCallback(\n  callbackFunc: (...args: any[]) => void,\n  resultSelector: (...args: any[]) => any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any>;\n\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\nexport function bindNodeCallback<A extends readonly unknown[], R extends readonly unknown[]>(\n  callbackFunc: (...args: [...A, (err: any, ...res: R) => void]) => void,\n  schedulerLike?: SchedulerLike\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\n\n/**\n * Converts a Node.js-style callback API to a function that returns an\n * Observable.\n *\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\n * callback is expected to be of type `callback(error, result)`.</span>\n *\n * `bindNodeCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters, but the\n * last parameter must be a callback function that `func` calls when it is\n * done. The callback function is expected to follow Node.js conventions,\n * where the first argument to the callback is an error object, signaling\n * whether call was successful. If that object is passed to callback, it means\n * something went wrong.\n *\n * The output of `bindNodeCallback` is a function that takes the same\n * parameters as `func`, except the last one (the callback). When the output\n * function is called with arguments, it will return an Observable.\n * If `func` calls its callback with error parameter present, Observable will\n * error with that value as well. If error parameter is not passed, Observable will emit\n * second parameter. If there are more parameters (third and so on),\n * Observable will emit an array with all arguments, except first error argument.\n *\n * Note that `func` will not be called at the same time output function is,\n * but rather whenever resulting Observable is subscribed. By default call to\n * `func` will happen synchronously after subscription, but that can be changed\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\n * can also control when values from callback will be emitted by Observable.\n * To find out more, check out documentation for {@link bindCallback}, where\n * {@link SchedulerLike} works exactly the same.\n *\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n * of returned function, when it is called.\n *\n * After Observable emits value, it will complete immediately. This means\n * even if `func` calls callback again, values from second and consecutive\n * calls will never appear on the stream. If you need to handle functions\n * that call callbacks multiple times, check out {@link fromEvent} or\n * {@link fromEventPattern} instead.\n *\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n * \"Node.js-style\" callbacks are just a convention, so if you write for\n * browsers or any other environment and API you use implements that callback style,\n * `bindNodeCallback` can be safely used on that API functions as well.\n *\n * Remember that Error object passed to callback does not have to be an instance\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n * Error parameter of callback function is interpreted as \"present\", when value\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n * string or boolean `true`. In all of these cases resulting Observable would error\n * with that value. This means usually regular style callbacks will fail very often when\n * `bindNodeCallback` is used. If your Observable errors much more often then you\n * would expect, check if callback really is called in Node.js-style and, if not,\n * switch to {@link bindCallback} instead.\n *\n * Note that even if error parameter is technically present in callback, but its value\n * is falsy, it still won't appear in array emitted by Observable.\n *\n * ## Examples\n *\n *  Read a file from the filesystem and get the data as an Observable\n *\n * ```ts\n * import * as fs from 'fs';\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * Use on function calling callback with multiple arguments\n *\n * ```ts\n * someFunction((err, a, b) => {\n *   console.log(err); // null\n *   console.log(a); // 5\n *   console.log(b); // \"some string\"\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(value => {\n *   console.log(value); // [5, \"some string\"]\n * });\n * ```\n *\n * Use on function calling callback in regular style\n *\n * ```ts\n * someFunction(a => {\n *   console.log(a); // 5\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(\n *   value => {}             // never gets called\n *   err => console.log(err) // 5\n * );\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link from}\n *\n * @param callbackFunc Function with a Node.js-style callback as the last parameter.\n * @param resultSelector A mapping function used to transform callback events.\n * @param scheduler The scheduler on which to schedule the callbacks.\n * @return A function which returns the Observable that delivers the same values the\n * Node.js callback would deliver.\n */\nexport function bindNodeCallback(\n  callbackFunc: (...args: [...any[], (err: any, ...res: any) => void]) => void,\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any> {\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","export function createObject(keys: string[], values: any[]) {\n  return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {} as any);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf, ObservableInputTuple } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { Subscriber } from '../Subscriber';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { Subscription } from '../Subscription';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { AnyCatcher } from '../AnyCatcher';\nimport { executeSchedule } from '../util/executeSchedule';\n\n// combineLatest(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function combineLatest<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// combineLatest([a, b, c])\nexport function combineLatest(sources: []): Observable<never>;\nexport function combineLatest<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R,\n  scheduler: SchedulerLike\n): Observable<R>;\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  sources: readonly [...ObservableInputTuple<A>],\n  scheduler: SchedulerLike\n): Observable<A>;\n\n// combineLatest(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelectorAndScheduler: [...ObservableInputTuple<A>, (...values: A) => R, SchedulerLike]\n): Observable<R>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): Observable<A>;\n\n// combineLatest({a, b, c})\nexport function combineLatest(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function combineLatest<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed in the\n * observables array. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to this operator,\n * the returned Observable will always emit an array of `n` values, in an order\n * corresponding to the order of the passed Observables (the value from the first Observable\n * will be at index 0 of the array and so on).\n *\n * Static version of `combineLatest` accepts an array of Observables. Note that an array of\n * Observables is a good choice, if you don't know beforehand how many Observables\n * you will combine. Passing an empty array will result in an Observable that\n * completes immediately.\n *\n * To ensure the output array always has the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all these values but the last\n * will be lost. On the other hand, if some Observable does not emit a value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will now be impossible to include a value from the\n * completed Observable in the resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, the resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, the result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of a completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * ## Examples\n *\n * Combine two timer Observables\n *\n * ```ts\n * import { timer, combineLatest } from 'rxjs';\n *\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest([firstTimer, secondTimer]);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * Combine a dictionary of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = {\n *   a: of(1).pipe(delay(1000), startWith(0)),\n *   b: of(5).pipe(delay(5000), startWith(0)),\n *   c: of(10).pipe(delay(10000), startWith(0))\n * };\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // { a: 0, b: 0, c: 0 } immediately\n * // { a: 1, b: 0, c: 0 } after 1s\n * // { a: 1, b: 5, c: 0 } after 5s\n * // { a: 1, b: 5, c: 10 } after 10s\n * ```\n *\n * Combine an array of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000), // emit 0 and then emit n after n seconds\n *     startWith(0)\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n * Use map operator to dynamically calculate the Body-Mass Index\n *\n * ```ts\n * import { of, combineLatest, map } from 'rxjs';\n *\n * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest([weight, height]).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param args Any number of `ObservableInput`s provided either as an array or as an object\n * to combine with each other. If the last parameter is the function, it will be used to project the\n * values from the combined latest values into a new value on the output Observable.\n * @return An Observable of projected values from the most recent values from each `ObservableInput`,\n * or an array of the most recent values from each `ObservableInput`.\n */\nexport function combineLatest<O extends ObservableInput<any>, R>(...args: any[]): Observable<R> | Observable<ObservedValueOf<O>[]> {\n  const scheduler = popScheduler(args);\n  const resultSelector = popResultSelector(args);\n\n  const { args: observables, keys } = argsArgArrayOrObject(args);\n\n  if (observables.length === 0) {\n    // If no observables are passed, or someone has passed an empty array\n    // of observables, or even an empty object POJO, we need to just\n    // complete (EMPTY), but we have to honor the scheduler provided if any.\n    return from([], scheduler as any);\n  }\n\n  const result = new Observable<ObservedValueOf<O>[]>(\n    combineLatestInit(\n      observables as ObservableInput<ObservedValueOf<O>>[],\n      scheduler,\n      keys\n        ? // A handler for scrubbing the array of args into a dictionary.\n          (values) => createObject(keys, values)\n        : // A passthrough to just return the array\n          identity\n    )\n  );\n\n  return resultSelector ? (result.pipe(mapOneOrManyArgs(resultSelector)) as Observable<R>) : result;\n}\n\nexport function combineLatestInit(\n  observables: ObservableInput<any>[],\n  scheduler?: SchedulerLike,\n  valueTransform: (values: any[]) => any = identity\n) {\n  return (subscriber: Subscriber<any>) => {\n    // The outer subscription. We're capturing this in a function\n    // because we may have to schedule it.\n    maybeSchedule(\n      scheduler,\n      () => {\n        const { length } = observables;\n        // A store for the values each observable has emitted so far. We match observable to value on index.\n        const values = new Array(length);\n        // The number of currently active subscriptions, as they complete, we decrement this number to see if\n        // we are all done combining values, so we can complete the result.\n        let active = length;\n        // The number of inner sources that still haven't emitted the first value\n        // We need to track this because all sources need to emit one value in order\n        // to start emitting values.\n        let remainingFirstValues = length;\n        // The loop to kick off subscription. We're keying everything on index `i` to relate the observables passed\n        // in to the slot in the output array or the key in the array of keys in the output dictionary.\n        for (let i = 0; i < length; i++) {\n          maybeSchedule(\n            scheduler,\n            () => {\n              const source = from(observables[i], scheduler as any);\n              let hasFirstValue = false;\n              source.subscribe(\n                createOperatorSubscriber(\n                  subscriber,\n                  (value) => {\n                    // When we get a value, record it in our set of values.\n                    values[i] = value;\n                    if (!hasFirstValue) {\n                      // If this is our first value, record that.\n                      hasFirstValue = true;\n                      remainingFirstValues--;\n                    }\n                    if (!remainingFirstValues) {\n                      // We're not waiting for any more\n                      // first values, so we can emit!\n                      subscriber.next(valueTransform(values.slice()));\n                    }\n                  },\n                  () => {\n                    if (!--active) {\n                      // We only complete the result if we have no more active\n                      // inner observables.\n                      subscriber.complete();\n                    }\n                  }\n                )\n              );\n            },\n            subscriber\n          );\n        }\n      },\n      subscriber\n    );\n  };\n}\n\n/**\n * A small utility to handle the couple of locations where we want to schedule if a scheduler was provided,\n * but we don't if there was no scheduler.\n */\nfunction maybeSchedule(scheduler: SchedulerLike | undefined, execute: () => void, subscription: Subscription) {\n  if (scheduler) {\n    executeSchedule(subscription, scheduler, execute);\n  } else {\n    execute();\n  }\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n","import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @param concurrent Maximum number of `ObservableInput`s being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param concurrent Maximum number of inner Observables being subscribed to\n * concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n","import { mergeAll } from './mergeAll';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * ![](concatAll.svg)\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, map, interval, take, concatAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(4)))\n * );\n * const firstOrder = higherOrder.pipe(concatAll());\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaustAll}\n * @see {@link mergeAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable emitting values from all the\n * inner Observables concatenated.\n */\nexport function concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeAll(1);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple, SchedulerLike } from '../types';\nimport { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function concat<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function concat<T extends readonly unknown[]>(\n  ...inputsAndScheduler: [...ObservableInputTuple<T>, SchedulerLike]\n): Observable<T[number]>;\n\n/**\n * Creates an output Observable which sequentially emits all values from the first given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * ![](concat.png)\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * ## Examples\n *\n * Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\n *\n * ```ts\n * import { interval, take, range, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(4));\n * const sequence = range(1, 10);\n * const result = concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n * ```\n *\n * Concatenate 3 Observables\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const result = concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n * ```\n *\n * Concatenate the same Observable to repeat it\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(2));\n *\n * concat(timer, timer) // concatenating the same Observable!\n *   .subscribe({\n *     next: value => console.log(value),\n *     complete: () => console.log('...and it is done!')\n *   });\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // '...and it is done!' also after 4s\n * ```\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link startWith}\n * @see {@link endWith}\n *\n * @param args `ObservableInput`s to concatenate.\n */\nexport function concat(...args: any[]): Observable<unknown> {\n  return concatAll()(from(args, popScheduler(args)));\n}\n","import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInput } from '../types';\nimport { innerFrom } from './innerFrom';\n\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create an Observable only when the Observer\n * subscribes. It waits until an Observer subscribes to it, calls the given\n * factory function to get an Observable -- where a factory function typically\n * generates a new Observable -- and subscribes the Observer to this Observable.\n * In case the factory function returns a falsy value, then EMPTY is used as\n * Observable instead. Last but not least, an exception during the factory\n * function call is transferred to the Observer by calling `error`.\n *\n * ## Example\n *\n * Subscribe to either an Observable of clicks or an Observable of interval, at random\n *\n * ```ts\n * import { defer, fromEvent, interval } from 'rxjs';\n *\n * const clicksOrInterval = defer(() => {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param observableFactory The Observable factory function to invoke for each\n * Observer that subscribes to the output Observable. May also return any\n * `ObservableInput`, which will be converted on the fly to an Observable.\n * @return An Observable whose Observers' subscriptions trigger an invocation of the\n * given Observable factory function.\n */\nexport function defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\n  return new Observable<ObservedValueOf<R>>((subscriber) => {\n    innerFrom(observableFactory()).subscribe(subscriber);\n  });\n}\n","import { Connectable, ObservableInput, SubjectLike } from '../types';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { defer } from './defer';\n\nexport interface ConnectableConfig<T> {\n  /**\n   * A factory function used to create the Subject through which the source\n   * is multicast. By default this creates a {@link Subject}.\n   */\n  connector: () => SubjectLike<T>;\n  /**\n   * If true, the resulting observable will reset internal state upon disconnection\n   * and return to a \"cold\" state. This allows the resulting observable to be\n   * reconnected.\n   * If false, upon disconnection, the connecting subject will remain the\n   * connecting subject, meaning the resulting observable will not go \"cold\" again,\n   * and subsequent repeats or resubscriptions will resubscribe to that same subject.\n   */\n  resetOnDisconnect?: boolean;\n}\n\n/**\n * The default configuration for `connectable`.\n */\nconst DEFAULT_CONFIG: ConnectableConfig<unknown> = {\n  connector: () => new Subject<unknown>(),\n  resetOnDisconnect: true,\n};\n\n/**\n * Creates an observable that multicasts once `connect()` is called on it.\n *\n * @param source The observable source to make connectable.\n * @param config The configuration object for `connectable`.\n * @returns A \"connectable\" observable, that has a `connect()` method, that you must call to\n * connect the source to all consumers through the subject provided as the connector.\n */\nexport function connectable<T>(source: ObservableInput<T>, config: ConnectableConfig<T> = DEFAULT_CONFIG): Connectable<T> {\n  // The subscription representing the connection.\n  let connection: Subscription | null = null;\n  const { connector, resetOnDisconnect = true } = config;\n  let subject = connector();\n\n  const result: any = new Observable<T>((subscriber) => {\n    return subject.subscribe(subscriber);\n  });\n\n  // Define the `connect` function. This is what users must call\n  // in order to \"connect\" the source to the subject that is\n  // multicasting it.\n  result.connect = () => {\n    if (!connection || connection.closed) {\n      connection = defer(() => source).subscribe(subject);\n      if (resetOnDisconnect) {\n        connection.add(() => (subject = connector()));\n      }\n    }\n    return connection;\n  };\n\n  return result;\n}\n","import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInputTuple, ObservableInput } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { innerFrom } from './innerFrom';\nimport { popResultSelector } from '../util/args';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { createObject } from '../util/createObject';\nimport { AnyCatcher } from '../AnyCatcher';\n\n// forkJoin(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function forkJoin<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// forkJoin(null | undefined)\nexport function forkJoin(scheduler: null | undefined): Observable<never>;\n\n// forkJoin([a, b, c])\nexport function forkJoin(sources: readonly []): Observable<never>;\nexport function forkJoin<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\nexport function forkJoin<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n\n// forkJoin(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function forkJoin<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function forkJoin<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n\n// forkJoin({a, b, c})\nexport function forkJoin(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function forkJoin<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\n * or a dictionary of values in the same shape as the passed dictionary.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted;\n * complete immediately if an empty array is passed.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\n * or a dictionary of input observables. If no input observables are provided (e.g. an empty array is passed),\n * then the resulting stream will complete immediately.\n *\n * `forkJoin` will wait for all passed observables to emit and complete and then it will emit an array or an object with last\n * values from corresponding observables.\n *\n * If you pass an array of `n` observables to the operator, then the resulting\n * array will have `n` values, where the first value is the last one emitted by the first observable,\n * second value is the last one emitted by the second observable and so on.\n *\n * If you pass a dictionary of observables to the operator, then the resulting\n * objects will have the same keys as the dictionary passed, with their last values they have emitted\n * located at the corresponding key.\n *\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\n * values not only at the end of the lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for the resulting array to have the same length as the number of input observables, whenever any of\n * the given observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other observables.\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete either,\n * unless at any point some other observable completes without emitting a value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all given observables\n * have to emit something at least once and complete.\n *\n * If any given observable errors at some point, `forkJoin` will error as well and immediately unsubscribe\n * from the other observables.\n *\n * Optionally `forkJoin` accepts a `resultSelector` function, that will be called with values which normally\n * would land in the emitted array. Whatever is returned by the `resultSelector`, will appear in the output\n * observable instead. This means that the default `resultSelector` can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that the `resultSelector` will be called only\n * when `forkJoin` is supposed to emit a result.\n *\n * ## Examples\n *\n * Use `forkJoin` with a dictionary of observable inputs\n *\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin({\n *   foo: of(1, 2, 3, 4),\n *   bar: Promise.resolve(8),\n *   baz: timer(4000)\n * });\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\n * // 'This is how it ends!' immediately after\n * ```\n *\n * Use `forkJoin` with an array of observable inputs\n *\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin([\n *   of(1, 2, 3, 4),\n *   Promise.resolve(8),\n *   timer(4000)\n * ]);\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // [4, 8, 0] after 4 seconds\n * // 'This is how it ends!' immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param args Any number of `ObservableInput`s provided either as an array, as an object\n * or as arguments passed directly to the operator.\n * @return Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin(...args: any[]): Observable<any> {\n  const resultSelector = popResultSelector(args);\n  const { args: sources, keys } = argsArgArrayOrObject(args);\n  const result = new Observable((subscriber) => {\n    const { length } = sources;\n    if (!length) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(length);\n    let remainingCompletions = length;\n    let remainingEmissions = length;\n    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n      let hasValue = false;\n      innerFrom(sources[sourceIndex]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            if (!hasValue) {\n              hasValue = true;\n              remainingEmissions--;\n            }\n            values[sourceIndex] = value;\n          },\n          () => remainingCompletions--,\n          undefined,\n          () => {\n            if (!remainingCompletions || !hasValue) {\n              if (!remainingEmissions) {\n                subscriber.next(keys ? createObject(keys, values) : values);\n              }\n              subscriber.complete();\n            }\n          }\n        )\n      );\n    }\n  });\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * // note optional configuration parameter which will be passed to addEventListener\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\n * const clicksInDiv = fromEvent(div, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param target The DOM EventTarget, Node.js EventEmitter, JQuery-like event target,\n * NodeList or HTMLCollection to attach the event handler to.\n * @param eventName The event name of interest, being emitted by the `target`.\n * @param options Options to pass through to the underlying `addListener`,\n * `addEventListener` or `on` functions.\n * @param resultSelector A mapping function used to transform events. It takes the\n * arguments from the event handler and should return a single value.\n * @return An Observable emitting events registered through `target`'s\n * listener handlers.\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  // Figure out our add and remove methods. In order to do this,\n  // we are going to analyze the target in a preferred order, if\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\n  // method names and apply them to a map to create opposite versions of the\n  // same function. This is because they all operate in duplicate pairs,\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\n  // The call only differs by method name, as to whether or not you're adding or removing.\n  const [add, remove] =\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n    isEventTarget(target)\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\n      : // In all other cases, the call pattern is identical with the exception of the method names.\n      isNodeStyleEventEmitter(target)\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n      : isJQueryStyleEventEmitter(target)\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n      : [];\n\n  // If add is falsy, it's because we didn't match a pattern above.\n  // Check to see if it is an ArrayLike, because if it is, we want to\n  // try to apply fromEvent to all of it's items. We do this check last,\n  // because there are may be some types that are both ArrayLike *and* implement\n  // event registry points, and we'd rather delegate to that when possible.\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\n        innerFrom(target)\n      ) as Observable<T>;\n    }\n  }\n\n  // If add is falsy and we made it here, it's because we didn't\n  // match any valid target objects above.\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    // The handler we are going to register. Forwards the event object, by itself, or\n    // an array of arguments to the event handler, if there is more than one argument,\n    // to the consumer.\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    // Do the work of adding the handler to the target.\n    add(handler);\n    // When we finalize, we want to remove the handler and free up memory.\n    return () => remove!(handler);\n  });\n}\n\n/**\n * Used to create `add` and `remove` functions to register and unregister event handlers\n * from a target in the most common handler pattern, where there are only two arguments.\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\n * @param target The target we're calling methods on\n * @param eventName The event name for the event we're creating register or unregister functions for\n */\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n","import { Observable } from '../Observable';\nimport { isFunction } from '../util/isFunction';\nimport { NodeEventHandler } from './fromEvent';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n/* tslint:disable:max-line-length */\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void\n): Observable<T>;\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n  resultSelector?: (...args: any[]) => T\n): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an Observable from an arbitrary API for registering event handlers.\n *\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\n * was not prepared for.</span>\n *\n * ![](fromEventPattern.png)\n *\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\n * for events. It is similar to {@link fromEvent}, but far\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\n * `fromEventPattern` (although in slightly more verbose way).\n *\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\n * handler parameter. That handler is actually an event handler function that you now can pass\n * to API expecting it. `addHandler` will be called whenever Observable\n * returned by the operator is subscribed, so registering handler in API will not\n * necessarily happen when `fromEventPattern` is called.\n *\n * After registration, every time an event that we listen to happens,\n * Observable returned by `fromEventPattern` will emit value that event handler\n * function was called with. Note that if event handler was called with more\n * than one argument, second and following arguments will not appear in the Observable.\n *\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\n * another function - `removeHandler` - as a second parameter. It will be injected\n * with the same handler function as before, which now you can use to unregister\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\n * unsubscribes from it.\n *\n * In some APIs unregistering is actually handled differently. Method registering an event handler\n * returns some kind of token, which is later used to identify which function should\n * be unregistered or it itself has method that unregisters event handler.\n * If that is the case with your API, make sure token returned\n * by registering method is returned by `addHandler`. Then it will be passed\n * as a second argument to `removeHandler`, where you will be able to use it.\n *\n * If you need access to all event handler parameters (not only the first one),\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\n * third parameter - project function which will accept all arguments passed to\n * event handler when it is called. Whatever is returned from project function will appear on\n * resulting stream instead of usual event handlers first argument. This means\n * that default project can be thought of as function that takes its first parameter\n * and ignores the rest.\n *\n * ## Examples\n *\n * Emits clicks happening on the DOM document\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * function addClickHandler(handler) {\n *   document.addEventListener('click', handler);\n * }\n *\n * function removeClickHandler(handler) {\n *   document.removeEventListener('click', handler);\n * }\n *\n * const clicks = fromEventPattern(\n *   addClickHandler,\n *   removeClickHandler\n * );\n * clicks.subscribe(x => console.log(x));\n *\n * // Whenever you click anywhere in the browser, DOM MouseEvent\n * // object will be logged.\n * ```\n *\n * Use with API that returns cancellation token\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * const token = someAPI.registerEventHandler(function() {});\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\n *                                        // not handler itself, but special token.\n *\n * const someAPIObservable = fromEventPattern(\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\n * );\n * ```\n *\n * Use with project function\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * someAPI.registerEventHandler((eventType, eventMessage) => {\n *   console.log(eventType, eventMessage); // Logs 'EVENT_TYPE' 'EVENT_MESSAGE' to console.\n * });\n *\n * const someAPIObservable = fromEventPattern(\n *   handler => someAPI.registerEventHandler(handler),\n *   handler => someAPI.unregisterEventHandler(handler)\n *   (eventType, eventMessage) => eventType + ' --- ' + eventMessage // without that function only 'EVENT_TYPE'\n * );                                                                // would be emitted by the Observable\n *\n * someAPIObservable.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'EVENT_TYPE --- EVENT_MESSAGE'\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n *\n * @param addHandler A function that takes a `handler` function as argument and attaches it\n * somehow to the actual source of events.\n * @param removeHandler A function that takes a `handler` function as an argument and removes\n * it from the event source. If `addHandler` returns some kind of token, `removeHandler` function\n * will have it as a second parameter.\n * @param resultSelector A function to transform results. It takes the arguments from the event\n * handler and should return a single value.\n * @return Observable which, when an event happens, emits first parameter passed to registered\n * event handler. Alternatively it emits whatever project function returns at that moment.\n */\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n  resultSelector?: (...args: any[]) => T\n): Observable<T | T[]> {\n  if (resultSelector) {\n    return fromEventPattern<T>(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  return new Observable<T | T[]>((subscriber) => {\n    const handler = (...e: T[]) => subscriber.next(e.length === 1 ? e[0] : e);\n    const retValue = addHandler(handler);\n    return isFunction(removeHandler) ? () => removeHandler(handler, retValue) : undefined;\n  });\n}\n","import { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { defer } from './defer';\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\n\ntype ConditionFunc<S> = (state: S) => boolean;\ntype IterateFunc<S> = (state: S) => S;\ntype ResultFunc<S, T> = (state: S) => T;\n\nexport interface GenerateBaseOptions<S> {\n  /**\n   * Initial state.\n   */\n  initialState: S;\n  /**\n   * Condition function that accepts state and returns boolean.\n   * When it returns false, the generator stops.\n   * If not specified, a generator never stops.\n   */\n  condition?: ConditionFunc<S>;\n  /**\n   * Iterate function that accepts state and returns new state.\n   */\n  iterate: IterateFunc<S>;\n  /**\n   * SchedulerLike to use for generation process.\n   * By default, a generator starts immediately.\n   */\n  scheduler?: SchedulerLike;\n}\n\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n  /**\n   * Result selection function that accepts state and returns a value to emit.\n   */\n  resultSelector: ResultFunc<S, T>;\n}\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Produces sequence of numbers\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1, x => x);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * ```\n *\n * Use `asapScheduler`\n *\n * ```ts\n * import { generate, asapScheduler } from 'rxjs';\n *\n * const result = generate(1, x => x < 5, x => x * 2, x => x + 1, asapScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 2\n * // 3\n * // 5\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param initialState Initial state.\n * @param condition Condition to terminate generation (upon returning false).\n * @param iterate Iteration step function.\n * @param resultSelector Selector function for results produced in the sequence.\n * @param scheduler A {@link SchedulerLike} on which to run the generator loop.\n * If not provided, defaults to emit immediately.\n * @returns The generated sequence.\n * @deprecated Instead of passing separate arguments, use the options argument.\n * Signatures taking separate arguments will be removed in v8.\n */\nexport function generate<T, S>(\n  initialState: S,\n  condition: ConditionFunc<S>,\n  iterate: IterateFunc<S>,\n  resultSelector: ResultFunc<S, T>,\n  scheduler?: SchedulerLike\n): Observable<T>;\n\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * ![](generate.png)\n *\n * `generate` allows you to create a stream of values generated with a loop very similar to\n * a traditional for loop. The first argument of `generate` is a beginning value. The second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * then the loop continues, if not, it stops. The third value is a function which takes the\n * previously defined value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in a traditional for loop: the first expression\n * initializes some state (for example, a numeric index), the second tests if the loop can perform the next\n * iteration (for example, if the index is lower than 10) and the third states how the defined value\n * will be modified on every step (for example, the index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First of all, the condition function is ran. If it returns true, then the Observable\n * emits the currently stored value (initial value at the first iteration) and finally updates\n * that value with iterate function. If at some point the condition returns false, then the Observable\n * completes at that moment.\n *\n * Optionally you can pass a fourth parameter to `generate` - a result selector function which allows you\n * to immediately map the value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * a single object to the operator instead where the object has the properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, or in other words the resulting Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of a multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is a `resultSelector`\n * function or not). In case of a single-parameter call, you can provide it as a\n * `scheduler` property on the object passed to the operator. In both cases, a scheduler decides when\n * the next iteration of the loop will happen and therefore when the next value will be emitted\n * by the Observable. For example, to ensure that each value is pushed to the Observer\n * on a separate task in the event loop, you could use the `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * ## Examples\n *\n * Use with condition and iterate functions\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1);\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * Use with condition, iterate and resultSelector functions\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 'Complete!'\n * ```\n *\n * Use with options object\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 'Complete!'\n * ```\n *\n * Use options object without condition function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!') // This will never run\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n * ```\n *\n * @see {@link from}\n *\n * @param initialState Initial state.\n * @param condition Condition to terminate generation (upon returning false).\n * @param iterate Iteration step function.\n * @param scheduler A {@link Scheduler} on which to run the generator loop. If not\n * provided, defaults to emitting immediately.\n * @return The generated sequence.\n * @deprecated Instead of passing separate arguments, use the options argument.\n * Signatures taking separate arguments will be removed in v8.\n */\nexport function generate<S>(\n  initialState: S,\n  condition: ConditionFunc<S>,\n  iterate: IterateFunc<S>,\n  scheduler?: SchedulerLike\n): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Use options object with condition function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition: x => x < 3,\n *   iterate: x => x + 1\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns The generated sequence.\n */\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Use options object with condition and iterate function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition: x => x < 3,\n *   iterate: x => x + 1,\n *   resultSelector: x => x\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns The generated sequence.\n */\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n\nexport function generate<T, S>(\n  initialStateOrOptions: S | GenerateOptions<T, S>,\n  condition?: ConditionFunc<S>,\n  iterate?: IterateFunc<S>,\n  resultSelectorOrScheduler?: ResultFunc<S, T> | SchedulerLike,\n  scheduler?: SchedulerLike\n): Observable<T> {\n  let resultSelector: ResultFunc<S, T>;\n  let initialState: S;\n\n  // TODO: Remove this as we move away from deprecated signatures\n  // and move towards a configuration object argument.\n  if (arguments.length === 1) {\n    // If we only have one argument, we can assume it is a configuration object.\n    // Note that folks not using TypeScript may trip over this.\n    ({\n      initialState,\n      condition,\n      iterate,\n      resultSelector = identity as ResultFunc<S, T>,\n      scheduler,\n    } = initialStateOrOptions as GenerateOptions<T, S>);\n  } else {\n    // Deprecated arguments path. Figure out what the user\n    // passed and set it here.\n    initialState = initialStateOrOptions as S;\n    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\n      resultSelector = identity as ResultFunc<S, T>;\n      scheduler = resultSelectorOrScheduler as SchedulerLike;\n    } else {\n      resultSelector = resultSelectorOrScheduler as ResultFunc<S, T>;\n    }\n  }\n\n  // The actual generator used to \"generate\" values.\n  function* gen() {\n    for (let state = initialState; !condition || condition(state); state = iterate!(state)) {\n      yield resultSelector(state);\n    }\n  }\n\n  // We use `defer` because we want to defer the creation of the iterator from the iterable.\n  return defer(\n    (scheduler\n      ? // If a scheduler was provided, use `scheduleIterable` to ensure that iteration/generation\n        // happens on the scheduler.\n        () => scheduleIterable(gen(), scheduler!)\n      : // Otherwise, if there's no scheduler, we can just use the generator function directly in\n        // `defer` and executing it will return the generator (which is iterable).\n        gen) as () => ObservableInput<T>\n  );\n}\n","import { Observable } from '../Observable';\nimport { defer } from './defer';\nimport { ObservableInput } from '../types';\n\n/**\n * Checks a boolean at subscription time, and chooses between one of two observable sources\n *\n * `iif` expects a function that returns a boolean (the `condition` function), and two sources,\n * the `trueResult` and the `falseResult`, and returns an Observable.\n *\n * At the moment of subscription, the `condition` function is called. If the result is `true`, the\n * subscription will be to the source passed as the `trueResult`, otherwise, the subscription will be\n * to the source passed as the `falseResult`.\n *\n * If you need to check more than two options to choose between more than one observable, have a look at the {@link defer} creation method.\n *\n * ## Examples\n *\n * Change at runtime which Observable will be subscribed\n *\n * ```ts\n * import { iif, of } from 'rxjs';\n *\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second')\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'first'\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'second'\n * ```\n *\n * Control access to an Observable\n *\n * ```ts\n * import { iif, of, EMPTY } from 'rxjs';\n *\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'),\n *   EMPTY\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('The end')\n * });\n *\n * // Logs:\n * // 'It seems you have an access...'\n * // 'The end'\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('The end')\n * });\n *\n * // Logs:\n * // 'The end'\n * ```\n *\n * @see {@link defer}\n *\n * @param condition Condition which Observable should be chosen.\n * @param trueResult An Observable that will be subscribed if condition is true.\n * @param falseResult An Observable that will be subscribed if condition is false.\n * @return An observable that proxies to `trueResult` or `falseResult`, depending on the result of the `condition` function.\n */\nexport function iif<T, F>(condition: () => boolean, trueResult: ObservableInput<T>, falseResult: ObservableInput<F>): Observable<T | F> {\n  return defer(() => (condition() ? trueResult : falseResult));\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\n\n/**\n * Creates an observable that will wait for a specified time period, or exact date, before\n * emitting the number 0.\n *\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\n *\n * This observable is useful for creating delays in code, or racing against other values\n * for ad-hoc timeouts.\n *\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Examples\n *\n * Wait 3 seconds and start another observable\n *\n * You might want to use `timer` to delay subscription to an\n * observable by a set amount of time. Here we use a timer with\n * {@link concatMapTo} or {@link concatMap} in order to wait\n * a few seconds and start a subscription to a source.\n *\n * ```ts\n * import { of, timer, concatMap } from 'rxjs';\n *\n * // This could be any observable\n * const source = of(1, 2, 3);\n *\n * timer(3000)\n *   .pipe(concatMap(() => source))\n *   .subscribe(console.log);\n * ```\n *\n * Take all values until the start of the next minute\n *\n * Using a `Date` as the trigger for the first emission, you can\n * do things like wait until midnight to fire an event, or in this case,\n * wait until a new minute starts (chosen so the example wouldn't take\n * too long to run) in order to stop watching a stream. Leveraging\n * {@link takeUntil}.\n *\n * ```ts\n * import { interval, takeUntil, timer } from 'rxjs';\n *\n * // Build a Date object that marks the\n * // next minute.\n * const currentDate = new Date();\n * const startOfNextMinute = new Date(\n *   currentDate.getFullYear(),\n *   currentDate.getMonth(),\n *   currentDate.getDate(),\n *   currentDate.getHours(),\n *   currentDate.getMinutes() + 1\n * );\n *\n * // This could be any observable stream\n * const source = interval(1000);\n *\n * const result = source.pipe(\n *   takeUntil(timer(startOfNextMinute))\n * );\n *\n * result.subscribe(console.log);\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `dueTime`.\n *\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\n * If a `Date`, the exact time at which to emit.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\n\n/**\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\n * on each interval after words.\n *\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Example\n *\n * ### Start an interval that starts right away\n *\n * Since {@link interval} waits for the passed delay before starting,\n * sometimes that's not ideal. You may want to start an interval immediately.\n * `timer` works well for this. Here we have both side-by-side so you can\n * see them in comparison.\n *\n * Note that this observable will never complete.\n *\n * ```ts\n * import { timer, interval } from 'rxjs';\n *\n * timer(0, 1000).subscribe(n => console.log('timer', n));\n * interval(1000).subscribe(n => console.log('interval', n));\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `startDue`.\n * @param startDue If a `number`, is the time to wait before starting the interval.\n * If a `Date`, is the exact time at which to start the interval.\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\n * negative number here will result in immediate completion after the first value is emitted, as though\n * no `intervalDuration` was passed at all.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\n\n/**\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\n */\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\n\nexport function timer(\n  dueTime: number | Date = 0,\n  intervalOrScheduler?: number | SchedulerLike,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  // Since negative intervalDuration is treated as though no\n  // interval was specified at all, we start with a negative number.\n  let intervalDuration = -1;\n\n  if (intervalOrScheduler != null) {\n    // If we have a second argument, and it's a scheduler,\n    // override the scheduler we had defaulted. Otherwise,\n    // it must be an interval.\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      // Note that this *could* be negative, in which case\n      // it's like not passing an intervalDuration at all.\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n\n  return new Observable((subscriber) => {\n    // If a valid date is passed, calculate how long to wait before\n    // executing the first value... otherwise, if it's a number just schedule\n    // that many milliseconds (or scheduler-specified unit size) in the future.\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\n\n    if (due < 0) {\n      // Ensure we don't schedule in the future.\n      due = 0;\n    }\n\n    // The incrementing value we emit.\n    let n = 0;\n\n    // Start the timer.\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        // Emit the next value and increment.\n        subscriber.next(n++);\n\n        if (0 <= intervalDuration) {\n          // If we have a interval after the initial timer,\n          // reschedule with the period.\n          this.schedule(undefined, intervalDuration);\n        } else {\n          // We didn't have an interval. So just complete.\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}\n","import { Observable } from '../Observable';\nimport { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike } from '../types';\nimport { timer } from './timer';\n\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.</span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n *\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param period The interval size in milliseconds (by default) or the time unit determined\n * by the scheduler's clock.\n * @param scheduler The {@link SchedulerLike} to use for scheduling the emission of values,\n * and providing a notion of \"time\".\n * @return An Observable that emits a sequential number each time interval.\n */\nexport function interval(period = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number> {\n  if (period < 0) {\n    // We cannot schedule an interval in the past.\n    period = 0;\n  }\n\n  return timer(period, period, scheduler);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param args `ObservableInput`s to merge together. If the last parameter\n * is of type number, `merge` will use it to limit number of concurrently\n * subscribed `ObservableInput`s. If the last parameter is {@link SchedulerLike},\n * it will be used for scheduling the emission of values.\n * @return An Observable that emits items that are the result of every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      innerFrom(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(from(sources, scheduler));\n}\n","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n","const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from './innerFrom';\n\nexport function onErrorResumeNext<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function onErrorResumeNext<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\n\n/**\n * When any of the provided Observable emits a complete or an error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the result of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * ## Example\n *\n * Subscribe to the next Observable after map fails\n *\n * ```ts\n * import { onErrorResumeNext, of, map } from 'rxjs';\n *\n * onErrorResumeNext(\n *   of(1, 2, 3, 0).pipe(\n *     map(x => {\n *       if (x === 0) {\n *         throw Error();\n *       }\n *       return 10 / x;\n *     })\n *   ),\n *   of(1, 2, 3)\n * )\n * .subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(err),     // Will never be called.\n *   complete: () => console.log('done')\n * });\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // 'done'\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param sources `ObservableInput`s passed either directly or as an array.\n * @return An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\nexport function onErrorResumeNext<A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): Observable<A[number]> {\n  const nextSources: ObservableInputTuple<A> = argsOrArgArray(sources) as any;\n\n  return new Observable((subscriber) => {\n    let sourceIndex = 0;\n    const subscribeNext = () => {\n      if (sourceIndex < nextSources.length) {\n        let nextSource: Observable<A[number]>;\n        try {\n          nextSource = innerFrom(nextSources[sourceIndex++]);\n        } catch (err) {\n          subscribeNext();\n          return;\n        }\n        const innerSubscriber = new OperatorSubscriber(subscriber, undefined, noop, noop);\n        nextSource.subscribe(innerSubscriber);\n        innerSubscriber.add(subscribeNext);\n      } else {\n        subscriber.complete();\n      }\n    };\n    subscribeNext();\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { from } from './from';\n\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<T>(arr: readonly T[], scheduler?: SchedulerLike): Observable<[string, T]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<O extends Record<string, unknown>>(obj: O, scheduler?: SchedulerLike): Observable<[keyof O, O[keyof O]]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<T>(iterable: Iterable<T>, scheduler?: SchedulerLike): Observable<[string, T]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs(\n  n: number | bigint | boolean | ((...args: any[]) => any) | symbol,\n  scheduler?: SchedulerLike\n): Observable<[never, never]>;\n\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * ![](pairs.png)\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default, these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * ## Example\n *\n * Converts an object to an Observable\n *\n * ```ts\n * import { pairs } from 'rxjs';\n *\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj).subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // ['foo', 42]\n * // ['bar', 56]\n * // ['baz', 78]\n * // 'Complete!'\n * ```\n *\n * ### Object.entries required\n *\n * In IE, you will need to polyfill `Object.entries` in order to use this.\n * [MDN has a polyfill here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n *\n * @param obj The object to inspect and turn into an Observable sequence.\n * @param scheduler An optional IScheduler to schedule when resulting\n * Observable will emit values.\n * @returns An observable sequence of [key, value] pairs from the object.\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs(obj: any, scheduler?: SchedulerLike) {\n  return from(Object.entries(obj), scheduler as any);\n}\n","export function not<T>(pred: (value: T, index: number) => boolean, thisArg: any): (value: T, index: number) => boolean {\n  return (value: T, index: number) => !pred.call(thisArg, value, index); \n}","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n *\n * Emit only click events whose target was a DIV element\n *\n * ```ts\n * import { fromEvent, filter } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param thisArg An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits items from the\n * source Observable that satisfy the specified `predicate`.\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // An index passed to our predicate function on each call.\n    let index = 0;\n\n    // Subscribe to the source, all errors and completions are\n    // forwarded to the consumer.\n    source.subscribe(\n      // Call the predicate with the appropriate `this` context,\n      // if the predicate returns `true`, then send the value\n      // to the consumer.\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\n    );\n  });\n}\n","import { not } from '../util/not';\nimport { filter } from '../operators/filter';\nimport { ObservableInput } from '../types';\nimport { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function partition<T, U extends T, A>(\n  source: ObservableInput<T>,\n  predicate: (this: A, value: T, index: number) => value is U,\n  thisArg: A\n): [Observable<U>, Observable<Exclude<T, U>>];\nexport function partition<T, U extends T>(\n  source: ObservableInput<T>,\n  predicate: (value: T, index: number) => value is U\n): [Observable<U>, Observable<Exclude<T, U>>];\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function partition<T, A>(\n  source: ObservableInput<T>,\n  predicate: (this: A, value: T, index: number) => boolean,\n  thisArg: A\n): [Observable<T>, Observable<T>];\nexport function partition<T>(source: ObservableInput<T>, predicate: (value: T, index: number) => boolean): [Observable<T>, Observable<T>];\n\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n *\n * Partition a set of numbers into odds and evens observables\n *\n * ```ts\n * import { of, partition } from 'rxjs';\n *\n * const observableValues = of(1, 2, 3, 4, 5, 6);\n * const [evens$, odds$] = partition(observableValues, value => value % 2 === 0);\n *\n * odds$.subscribe(x => console.log('odds', x));\n * evens$.subscribe(x => console.log('evens', x));\n *\n * // Logs:\n * // odds 1\n * // odds 3\n * // odds 5\n * // evens 2\n * // evens 4\n * // evens 6\n * ```\n *\n * @see {@link filter}\n *\n * @param source The source `ObservableInput` that will be split into a tuple of\n * two Observable elements.\n * @param predicate A function that evaluates each value emitted by the source\n * Observable. If it returns `true`, the value is emitted on the first Observable\n * in the returned array, if `false` the value is emitted on the second Observable\n * in the array. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number `0`.\n * @param thisArg An optional argument to determine the value of `this` in the\n * `predicate` function.\n * @return An array with two Observables: one with values that passed the\n * predicate, and another with values that did not pass the predicate.\n */\nexport function partition<T>(\n  source: ObservableInput<T>,\n  predicate: (this: any, value: T, index: number) => boolean,\n  thisArg?: any\n): [Observable<T>, Observable<T>] {\n  return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))] as [\n    Observable<T>,\n    Observable<T>\n  ];\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { Subscriber } from '../Subscriber';\n\nexport function race<T extends readonly unknown[]>(inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function race<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\n\n/**\n * Returns an observable that mirrors the first source observable to emit an item.\n *\n * ![](race.png)\n *\n * `race` returns an observable, that when subscribed to, subscribes to all source observables immediately.\n * As soon as one of the source observables emits a value, the result unsubscribes from the other sources.\n * The resulting observable will forward all notifications, including error and completion, from the \"winning\"\n * source observable.\n *\n * If one of the used source observable throws an errors before a first notification\n * the race operator will also throw an error, no matter if another source observable\n * could potentially win the race.\n *\n * `race` can be useful for selecting the response from the fastest network connection for\n * HTTP or WebSockets. `race` can also be useful for switching observable context based on user\n * input.\n *\n * ## Example\n *\n * Subscribes to the observable that was the first to start emitting.\n *\n * ```ts\n * import { interval, map, race } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * race(obs1, obs2, obs3)\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param sources Used to race for which `ObservableInput` emits first.\n * @return An Observable that mirrors the output of the first Observable to emit an item.\n */\nexport function race<T>(...sources: (ObservableInput<T> | ObservableInput<T>[])[]): Observable<any> {\n  sources = argsOrArgArray(sources);\n  // If only one source was passed, just return it. Otherwise return the race.\n  return sources.length === 1 ? innerFrom(sources[0] as ObservableInput<T>) : new Observable<T>(raceInit(sources as ObservableInput<T>[]));\n}\n\n/**\n * An observable initializer function for both the static version and the\n * operator version of race.\n * @param sources The sources to race\n */\nexport function raceInit<T>(sources: ObservableInput<T>[]) {\n  return (subscriber: Subscriber<T>) => {\n    let subscriptions: Subscription[] = [];\n\n    // Subscribe to all of the sources. Note that we are checking `subscriptions` here\n    // Is is an array of all actively \"racing\" subscriptions, and it is `null` after the\n    // race has been won. So, if we have racer that synchronously \"wins\", this loop will\n    // stop before it subscribes to any more.\n    for (let i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {\n      subscriptions.push(\n        innerFrom(sources[i] as ObservableInput<T>).subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            if (subscriptions) {\n              // We're still racing, but we won! So unsubscribe\n              // all other subscriptions that we have, except this one.\n              for (let s = 0; s < subscriptions.length; s++) {\n                s !== i && subscriptions[s].unsubscribe();\n              }\n              subscriptions = null!;\n            }\n            subscriber.next(value);\n          })\n        )\n      );\n    }\n  };\n}\n","import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { EMPTY } from './empty';\n\nexport function range(start: number, count?: number): Observable<number>;\n\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. Use `range(start, count).pipe(observeOn(scheduler))` instead. Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function range(start: number, count: number | undefined, scheduler: SchedulerLike): Observable<number>;\n\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n *\n * Produce a range of numbers\n *\n * ```ts\n * import { range } from 'rxjs';\n *\n * const numbers = range(1, 3);\n *\n * numbers.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 1\n * // 2\n * // 3\n * // 'Complete!'\n * ```\n *\n * @see {@link timer}\n * @see {@link interval}\n *\n * @param start The value of the first integer in the sequence.\n * @param count The number of sequential integers to generate.\n * @param scheduler A {@link SchedulerLike} to use for scheduling the emissions\n * of the notifications.\n * @return An Observable of numbers that emits a finite range of sequential integers.\n */\nexport function range(start: number, count?: number, scheduler?: SchedulerLike): Observable<number> {\n  if (count == null) {\n    // If one argument was passed, it's the count, not the start.\n    count = start;\n    start = 0;\n  }\n\n  if (count <= 0) {\n    // No count? We're going nowhere. Return EMPTY.\n    return EMPTY;\n  }\n\n  // Where the range should stop.\n  const end = count + start;\n\n  return new Observable(\n    scheduler\n      ? // The deprecated scheduled path.\n        (subscriber) => {\n          let n = start;\n          return scheduler.schedule(function () {\n            if (n < end) {\n              subscriber.next(n++);\n              this.schedule();\n            } else {\n              subscriber.complete();\n            }\n          });\n        }\n      : // Standard synchronous range.\n        (subscriber) => {\n          let n = start;\n          while (n < end && !subscriber.closed) {\n            subscriber.next(n++);\n          }\n          subscriber.complete();\n        }\n  );\n}\n","import { Observable } from '../Observable';\nimport { Unsubscribable, ObservableInput, ObservedValueOf } from '../types';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\n\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param resourceFactory A function which creates any resource object that implements `unsubscribe` method.\n * @param observableFactory A function which creates an Observable, that can use injected resource object.\n * @return An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport function using<T extends ObservableInput<any>>(\n  resourceFactory: () => Unsubscribable | void,\n  observableFactory: (resource: Unsubscribable | void) => T | void\n): Observable<ObservedValueOf<T>> {\n  return new Observable<ObservedValueOf<T>>((subscriber) => {\n    const resource = resourceFactory();\n    const result = observableFactory(resource);\n    const source = result ? innerFrom(result) : EMPTY;\n    source.subscribe(subscriber);\n    return () => {\n      // NOTE: Optional chaining did not work here.\n      // Related TS Issue: https://github.com/microsoft/TypeScript/issues/40818\n      if (resource) {\n        resource.unsubscribe();\n      }\n    };\n  });\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple } from '../types';\nimport { innerFrom } from './innerFrom';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { EMPTY } from './empty';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { popResultSelector } from '../util/args';\n\nexport function zip<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A>;\nexport function zip<A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\nexport function zip<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\nexport function zip<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the last parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * ## Example\n *\n * Combine age and name from different sources\n *\n * ```ts\n * import { of, zip, map } from 'rxjs';\n *\n * const age$ = of(27, 25, 29);\n * const name$ = of('Foo', 'Bar', 'Beer');\n * const isDev$ = of(true, true, false);\n *\n * zip(age$, name$, isDev$).pipe(\n *   map(([age, name, isDev]) => ({ age, name, isDev }))\n * )\n * .subscribe(x => console.log(x));\n *\n * // Outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n * ```\n *\n * @param args Any number of `ObservableInput`s provided either as an array or as an object\n * to combine with each other.\n * @return An Observable of array values of the values emitted at the same index from each\n * individual `ObservableInput`.\n */\nexport function zip(...args: unknown[]): Observable<unknown> {\n  const resultSelector = popResultSelector(args);\n\n  const sources = argsOrArgArray(args) as Observable<unknown>[];\n\n  return sources.length\n    ? new Observable<unknown[]>((subscriber) => {\n        // A collection of buffers of values from each source.\n        // Keyed by the same index with which the sources were passed in.\n        let buffers: unknown[][] = sources.map(() => []);\n\n        // An array of flags of whether or not the sources have completed.\n        // This is used to check to see if we should complete the result.\n        // Keyed by the same index with which the sources were passed in.\n        let completed = sources.map(() => false);\n\n        // When everything is done, release the arrays above.\n        subscriber.add(() => {\n          buffers = completed = null!;\n        });\n\n        // Loop over our sources and subscribe to each one. The index `i` is\n        // especially important here, because we use it in closures below to\n        // access the related buffers and completion properties\n        for (let sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n          innerFrom(sources[sourceIndex]).subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              (value) => {\n                buffers[sourceIndex].push(value);\n                // if every buffer has at least one value in it, then we\n                // can shift out the oldest value from each buffer and emit\n                // them as an array.\n                if (buffers.every((buffer) => buffer.length)) {\n                  const result: any = buffers.map((buffer) => buffer.shift()!);\n                  // Emit the array. If theres' a result selector, use that.\n                  subscriber.next(resultSelector ? resultSelector(...result) : result);\n                  // If any one of the sources is both complete and has an empty buffer\n                  // then we complete the result. This is because we cannot possibly have\n                  // any more values to zip together.\n                  if (buffers.some((buffer, i) => !buffer.length && completed[i])) {\n                    subscriber.complete();\n                  }\n                }\n              },\n              () => {\n                // This source completed. Mark it as complete so we can check it later\n                // if we have to.\n                completed[sourceIndex] = true;\n                // But, if this complete source has nothing in its buffer, then we\n                // can complete the result, because we can't possibly have any more\n                // values from this to zip together with the other values.\n                !buffers[sourceIndex].length && subscriber.complete();\n              }\n            )\n          );\n        }\n\n        // When everything is done, release the arrays above.\n        return () => {\n          buffers = completed = null!;\n        };\n      })\n    : EMPTY;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\n\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.svg)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, audit, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function audit<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    let durationSubscriber: Subscriber<any> | null = null;\n    let isComplete = false;\n\n    const endDuration = () => {\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n      isComplete && subscriber.complete();\n    };\n\n    const cleanupDuration = () => {\n      durationSubscriber = null;\n      isComplete && subscriber.complete();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          lastValue = value;\n          if (!durationSubscriber) {\n            innerFrom(durationSelector(value)).subscribe(\n              (durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration))\n            );\n          }\n        },\n        () => {\n          isComplete = true;\n          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source value, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, auditTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param duration Time to wait before emitting the most recent source value,\n * measured in milliseconds or the time unit determined internally by the\n * optional `scheduler`.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\n * that handle the rate-limiting behavior.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function auditTime<T>(duration: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return audit(() => timer(duration, scheduler));\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * ![](buffer.png)\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * `ObservableInput` (that internally gets converted to an Observable)\n * emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```ts\n * import { fromEvent, interval, buffer } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const intervalEvents = interval(1000);\n * const buffered = intervalEvents.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param closingNotifier An `ObservableInput` that signals the\n * buffer to be emitted on the output Observable.\n * @return A function that returns an Observable of buffers, which are arrays\n * of values.\n */\nexport function buffer<T>(closingNotifier: ObservableInput<any>): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    // The current buffered values.\n    let currentBuffer: T[] = [];\n\n    // Subscribe to our source.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => currentBuffer.push(value),\n        () => {\n          subscriber.next(currentBuffer);\n          subscriber.complete();\n        }\n      )\n    );\n\n    // Subscribe to the closing notifier.\n    innerFrom(closingNotifier).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          // Start a new buffer and emit the previous one.\n          const b = currentBuffer;\n          currentBuffer = [];\n          subscriber.next(b);\n        },\n        noop\n      )\n    );\n\n    return () => {\n      // Ensure buffered values are released on finalization.\n      currentBuffer = null!;\n    };\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * ![](bufferCount.png)\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent, bufferCount } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent, bufferCount } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param bufferSize The maximum size of the buffer emitted.\n * @param startBufferEvery Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number | null = null): OperatorFunction<T, T[]> {\n  // If no `startBufferEvery` value was supplied, then we're\n  // opening and closing on the bufferSize itself.\n  startBufferEvery = startBufferEvery ?? bufferSize;\n\n  return operate((source, subscriber) => {\n    let buffers: T[][] = [];\n    let count = 0;\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          let toEmit: T[][] | null = null;\n\n          // Check to see if we need to start a buffer.\n          // This will start one at the first value, and then\n          // a new one every N after that.\n          if (count++ % startBufferEvery! === 0) {\n            buffers.push([]);\n          }\n\n          // Push our value into our active buffers.\n          for (const buffer of buffers) {\n            buffer.push(value);\n            // Check to see if we're over the bufferSize\n            // if we are, record it so we can emit it later.\n            // If we emitted it now and removed it, it would\n            // mutate the `buffers` array while we're looping\n            // over it.\n            if (bufferSize <= buffer.length) {\n              toEmit = toEmit ?? [];\n              toEmit.push(buffer);\n            }\n          }\n\n          if (toEmit) {\n            // We have found some buffers that are over the\n            // `bufferSize`. Emit them, and remove them from our\n            // buffers list.\n            for (const buffer of toEmit) {\n              arrRemove(buffers, buffer);\n              subscriber.next(buffer);\n            }\n          }\n        },\n        () => {\n          // When the source completes, emit all of our\n          // active buffers.\n          for (const buffer of buffers) {\n            subscriber.next(buffer);\n          }\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Clean up our memory when we finalize\n          buffers = null!;\n        }\n      )\n    );\n  });\n}\n","import { Subscription } from '../Subscription';\nimport { OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  maxBufferSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param bufferTimeSpan The amount of time to fill each buffer array.\n * @param otherArgs Other configuration arguments such as:\n * - `bufferCreationInterval` - the interval at which to start new buffers;\n * - `maxBufferSize` - the maximum buffer size;\n * - `scheduler` - the scheduler on which to schedule the intervals that determine buffer boundaries.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active buffers, their related subscriptions, and removal functions.\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\n    // this is only really used for when *just* the buffer time span is passed.\n    let restartOnEmit = false;\n\n    /**\n     * Does the work of emitting the buffer from the record, ensuring that the\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\n     * after the emit.\n     */\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\n      const { buffer, subs } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    /**\n     * Called every time we start a new buffer. This does\n     * the work of scheduling a job at the requested bufferTimeSpan\n     * that will emit the buffer (if it's not unsubscribed before then).\n     */\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer: T[] = [];\n        const record = {\n          buffer,\n          subs,\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      // The user passed both a bufferTimeSpan (required), and a creation interval\n      // That means we need to start new buffers on the interval, and those buffers need\n      // to wait the required time span before emitting.\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n\n    const bufferTimeSubscriber = createOperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Copy the records, so if we need to remove one we\n        // don't mutate the array. It's hard, but not impossible to\n        // set up a buffer time that could mutate the array and\n        // cause issues here.\n        const recordsCopy = bufferRecords!.slice();\n        for (const record of recordsCopy) {\n          // Loop over all buffers and\n          const { buffer } = record;\n          buffer.push(value);\n          // If the buffer is over the max size, we need to emit it.\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      },\n      () => {\n        // The source completed, emit all of the active\n        // buffers we have before we complete.\n        while (bufferRecords?.length) {\n          subscriber.next(bufferRecords.shift()!.buffer);\n        }\n        bufferTimeSubscriber?.unsubscribe();\n        subscriber.complete();\n        subscriber.unsubscribe();\n      },\n      // Pass all errors through to consumer.\n      undefined,\n      // Clean up\n      () => (bufferRecords = null)\n    );\n\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n","import { Subscription } from '../Subscription';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * ![](bufferToggle.png)\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, bufferToggle, EMPTY } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : EMPTY\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferToggle<T, O>(\n  openings: ObservableInput<O>,\n  closingSelector: (value: O) => ObservableInput<any>\n): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    const buffers: T[][] = [];\n\n    // Subscribe to the openings notifier first\n    innerFrom(openings).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (openValue) => {\n          const buffer: T[] = [];\n          buffers.push(buffer);\n          // We use this composite subscription, so that\n          // when the closing notifier emits, we can tear it down.\n          const closingSubscription = new Subscription();\n\n          const emitBuffer = () => {\n            arrRemove(buffers, buffer);\n            subscriber.next(buffer);\n            closingSubscription.unsubscribe();\n          };\n\n          // The line below will add the subscription to the parent subscriber *and* the closing subscription.\n          closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));\n        },\n        noop\n      )\n    );\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Value from our source. Add it to all pending buffers.\n          for (const buffer of buffers) {\n            buffer.push(value);\n          }\n        },\n        () => {\n          // Source complete. Emit all pending buffers.\n          while (buffers.length > 0) {\n            subscriber.next(buffers.shift()!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * ![](bufferWhen.svg)\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, bufferWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(\n *   bufferWhen(() => interval(1000 + Math.random() * 4000))\n * );\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param closingSelector A function that takes no arguments and returns an\n * Observable that signals buffer closure.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    // The buffer we keep and emit.\n    let buffer: T[] | null = null;\n    // A reference to the subscriber used to subscribe to\n    // the closing notifier. We need to hold this so we can\n    // end the subscription after the first notification.\n    let closingSubscriber: Subscriber<T> | null = null;\n\n    // Ends the previous closing notifier subscription, so it\n    // terminates after the first emission, then emits\n    // the current buffer  if there is one, starts a new buffer, and starts a\n    // new closing notifier.\n    const openBuffer = () => {\n      // Make sure to finalize the closing subscription, we only cared\n      // about one notification.\n      closingSubscriber?.unsubscribe();\n      // emit the buffer if we have one, and start a new buffer.\n      const b = buffer;\n      buffer = [];\n      b && subscriber.next(b);\n\n      // Get a new closing notifier and subscribe to it.\n      innerFrom(closingSelector()).subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop)));\n    };\n\n    // Start the first buffer.\n    openBuffer();\n\n    // Subscribe to our source.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        // Add every new value to the current buffer.\n        (value) => buffer?.push(value),\n        // When we complete, emit the buffer if we have one,\n        // then complete the result.\n        () => {\n          buffer && subscriber.next(buffer);\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        // Release memory on finalization\n        () => (buffer = closingSubscriber = null!)\n      )\n    );\n  });\n}\n","import { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { Subscription } from '../Subscription';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\n\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <span class=\"informal\">\n * It only listens to the error channel and ignores notifications.\n * Handles errors from the source observable, and maps them to a new observable.\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\n * </span>\n *\n * ![](catch.png)\n *\n * This operator handles errors, but forwards along all other events to the resulting observable.\n * If the source observable terminates with an error, it will map that error to a new observable,\n * subscribe to it, and forward all of its events to the resulting observable.\n *\n * ## Examples\n *\n * Continue with a different Observable when there's an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\n *\n * ```ts\n * import { of, map, catchError, take } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30)\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throw a new error when the source Observable throws an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     })\n *   )\n *   .subscribe({\n *     next: x => console.log(x),\n *     error: err => console.log(err)\n *   });\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n * @see {@link onErrorResumeNext}\n * @see {@link repeat}\n * @see {@link repeatWhen}\n * @see {@link retry }\n * @see {@link retryWhen}\n *\n * @param selector A function that takes as arguments `err`, which is the error, and `caught`, which\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again.\n * Whatever observable is returned by the `selector` will be used to continue the observable chain.\n * @return A function that returns an Observable that originates from either\n * the source or the Observable returned by the `selector` function.\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null = null;\n    let syncUnsub = false;\n    let handledResult: Observable<ObservedValueOf<O>>;\n\n    innerSub = source.subscribe(\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\n        if (innerSub) {\n          innerSub.unsubscribe();\n          innerSub = null;\n          handledResult.subscribe(subscriber);\n        } else {\n          // We don't have an innerSub yet, that means the error was synchronous\n          // because the subscribe call hasn't returned yet.\n          syncUnsub = true;\n        }\n      })\n    );\n\n    if (syncUnsub) {\n      // We have a synchronous error, we need to make sure to\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\n      // at the right time, and that finalization occurs at the expected\n      // time between the source error and the subscription to the\n      // next observable.\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult!.subscribe(subscriber);\n    }\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A basic scan operation. This is used for `scan` and `reduce`.\n * @param accumulator The accumulator to use\n * @param seed The seed value for the state to accumulate\n * @param hasSeed Whether or not a seed was provided\n * @param emitOnNext Whether or not to emit the state on next\n * @param emitBeforeComplete Whether or not to emit the before completion\n */\n\nexport function scanInternals<V, A, S>(\n  accumulator: (acc: V | A | S, value: V, index: number) => A,\n  seed: S,\n  hasSeed: boolean,\n  emitOnNext: boolean,\n  emitBeforeComplete?: undefined | true\n) {\n  return (source: Observable<V>, subscriber: Subscriber<any>) => {\n    // Whether or not we have state yet. This will only be\n    // false before the first value arrives if we didn't get\n    // a seed value.\n    let hasState = hasSeed;\n    // The state that we're tracking, starting with the seed,\n    // if there is one, and then updated by the return value\n    // from the accumulator on each emission.\n    let state: any = seed;\n    // An index to pass to the accumulator function.\n    let index = 0;\n\n    // Subscribe to our source. All errors and completions are passed through.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Always increment the index.\n          const i = index++;\n          // Set the state\n          state = hasState\n            ? // We already have state, so we can get the new state from the accumulator\n              accumulator(state, value, i)\n            : // We didn't have state yet, a seed value was not provided, so\n\n              // we set the state to the first value, and mark that we have state now\n              ((hasState = true), value);\n\n          // Maybe send it to the consumer.\n          emitOnNext && subscriber.next(state);\n        },\n        // If an onComplete was given, call it, otherwise\n        // just pass through the complete notification to the consumer.\n        emitBeforeComplete &&\n          (() => {\n            hasState && subscriber.next(state);\n            subscriber.complete();\n          })\n      )\n    );\n  };\n}\n","import { scanInternals } from './scanInternals';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\nexport function reduce<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\nexport function reduce<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\nexport function reduce<V, A, S = A>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\n\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * ![](reduce.png)\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * ## Example\n *\n * Count the number of click events that happened in 5 seconds\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, map, reduce } from 'rxjs';\n *\n * const clicksInFiveSeconds = fromEvent(document, 'click')\n *   .pipe(takeUntil(interval(5000)));\n *\n * const ones = clicksInFiveSeconds.pipe(map(() => 1));\n * const seed = 0;\n * const count = ones.pipe(reduce((acc, one) => acc + one, seed));\n *\n * count.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param accumulator The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @return A function that returns an Observable that emits a single value that\n * is the result of accumulating the values emitted by the source Observable.\n */\nexport function reduce<V, A>(accumulator: (acc: V | A, value: V, index: number) => A, seed?: any): OperatorFunction<V, V | A> {\n  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));\n}\n","import { reduce } from './reduce';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\nconst arrReducer = (arr: any[], value: any) => (arr.push(value), arr);\n\n/**\n * Collects all source emissions and emits them as an array when the source completes.\n *\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\n *\n * ![](toArray.png)\n *\n * `toArray` will wait until the source Observable completes before emitting\n * the array containing all emissions. When the source Observable errors no\n * array will be emitted.\n *\n * ## Example\n *\n * ```ts\n * import { interval, take, toArray } from 'rxjs';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(10),\n *   toArray()\n * );\n *\n * example.subscribe(value => console.log(value));\n *\n * // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n * ```\n *\n * @return A function that returns an Observable that emits an array of items\n * emitted by the source Observable when source completes.\n */\nexport function toArray<T>(): OperatorFunction<T, T[]> {\n  // Because arrays are mutable, and we're mutating the array in this\n  // reducer process, we have to encapsulate the creation of the initial\n  // array within this `operate` function.\n  return operate((source, subscriber) => {\n    reduce(arrReducer, [] as T[])(source).subscribe(subscriber);\n  });\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { mergeMap } from './mergeMap';\nimport { toArray } from './toArray';\n\n/**\n * Collects all of the inner sources from source observable. Then, once the\n * source completes, joins the values using the given static.\n *\n * This is used for {@link combineLatestAll} and {@link zipAll} which both have the\n * same behavior of collecting all inner observables, then operating on them.\n *\n * @param joinFn The type of static join to apply to the sources collected\n * @param project The projection function to apply to the values, if any\n */\nexport function joinAllInternals<T, R>(joinFn: (sources: ObservableInput<T>[]) => Observable<T>, project?: (...args: any[]) => R) {\n  return pipe(\n    // Collect all inner sources into an array, and emit them when the\n    // source completes.\n    toArray() as OperatorFunction<ObservableInput<T>, ObservableInput<T>[]>,\n    // Run the join function on the collected array of inner sources.\n    mergeMap((sources) => joinFn(sources)),\n    // If a projection function was supplied, apply it to each result.\n    project ? mapOneOrManyArgs(project) : (identity as any)\n  );\n}\n","import { combineLatest } from '../observable/combineLatest';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { joinAllInternals } from './joinAllInternals';\n\nexport function combineLatestAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function combineLatestAll<T>(): OperatorFunction<any, T[]>;\nexport function combineLatestAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function combineLatestAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\n/**\n * Flattens an Observable-of-Observables by applying {@link combineLatest} when the Observable-of-Observables completes.\n *\n * `combineLatestAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes,\n * it subscribes to all collected Observables and combines their values using the {@link combineLatest} strategy, such that:\n *\n * * Every time an inner Observable emits, the output Observable emits\n * * When the returned observable emits, it emits all of the latest values by:\n *    * If a `project` function is provided, it is called with each recent value from each inner Observable in whatever order they\n *      arrived, and the result of the `project` function is what is emitted by the output Observable.\n *    * If there is no `project` function, an array of all the most recent values is emitted by the output Observable.\n *\n * ## Example\n *\n * Map two click events to a finite interval Observable, then apply `combineLatestAll`\n *\n * ```ts\n * import { fromEvent, map, interval, take, combineLatestAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(Math.random() * 2000).pipe(take(3))),\n *   take(2)\n * );\n * const result = higherOrder.pipe(combineLatestAll());\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link combineLatestWith}\n * @see {@link mergeAll}\n *\n * @param project optional function to map the most recent values from each inner Observable into a new result.\n * Takes each of the most recent values from each collected inner Observable as arguments, in order.\n * @return A function that returns an Observable that flattens Observables\n * emitted by the source Observable.\n */\nexport function combineLatestAll<R>(project?: (...values: Array<any>) => R) {\n  return joinAllInternals(combineLatest, project);\n}\n","import { combineLatestAll } from './combineLatestAll';\n\n/**\n * @deprecated Renamed to {@link combineLatestAll}. Will be removed in v8.\n */\nexport const combineAll = combineLatestAll;\n","import { combineLatestInit } from '../observable/combineLatest';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { popResultSelector } from '../util/args';\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  project: (...values: [T, ...A]) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  ...sourcesAndProject: [...ObservableInputTuple<A>, (...values: [T, ...A]) => R]\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/**\n * @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8.\n */\nexport function combineLatest<T, R>(...args: (ObservableInput<any> | ((...values: any[]) => R))[]): OperatorFunction<T, unknown> {\n  const resultSelector = popResultSelector(args);\n  return resultSelector\n    ? pipe(combineLatest(...(args as Array<ObservableInput<any>>)), mapOneOrManyArgs(resultSelector))\n    : operate((source, subscriber) => {\n        combineLatestInit([source, ...argsOrArgArray(args)])(subscriber);\n      });\n}\n","import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { combineLatest } from './combineLatest';\n\n/**\n * Create an observable that combines the latest values from all passed observables and the source\n * into arrays and emits them.\n *\n * Returns an observable, that when subscribed to, will subscribe to the source observable and all\n * sources provided as arguments. Once all sources emit at least one value, all of the latest values\n * will be emitted as an array. After that, every time any source emits a value, all of the latest values\n * will be emitted as an array.\n *\n * This is a useful operator for eagerly calculating values based off of changed inputs.\n *\n * ## Example\n *\n * Simple concatenation of values from two inputs\n *\n * ```ts\n * import { fromEvent, combineLatestWith, map } from 'rxjs';\n *\n * // Setup: Add two inputs to the page\n * const input1 = document.createElement('input');\n * document.body.appendChild(input1);\n * const input2 = document.createElement('input');\n * document.body.appendChild(input2);\n *\n * // Get streams of changes\n * const input1Changes$ = fromEvent(input1, 'change');\n * const input2Changes$ = fromEvent(input2, 'change');\n *\n * // Combine the changes by adding them together\n * input1Changes$.pipe(\n *   combineLatestWith(input2Changes$),\n *   map(([e1, e2]) => (<HTMLInputElement>e1.target).value + ' - ' + (<HTMLInputElement>e2.target).value)\n * )\n * .subscribe(x => console.log(x));\n * ```\n *\n * @param otherSources the other sources to subscribe to.\n * @return A function that returns an Observable that emits the latest\n * emissions from both source and provided Observables.\n */\nexport function combineLatestWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, Cons<T, A>> {\n  return combineLatest(...otherSources);\n}\n","import { mergeMap } from './mergeMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * ![](concatMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMap(ev => interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * values from each projected inner Observable sequentially.\n */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n","import { concatMap } from './concatMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)` */\nexport function concatMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMapTo<O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: undefined\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](concatMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMapTo, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMapTo(interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param innerObservable An `ObservableInput` to replace each value from the\n * source Observable.\n * @return A function that returns an Observable of values merged together by\n * joining the passed Observable with itself, one after the other, for each\n * value emitted from the source.\n * @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)`\n */\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? concatMap(() => innerObservable, resultSelector) : concatMap(() => innerObservable);\n}\n","import { ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { concatAll } from './concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * @deprecated Replaced with {@link concatWith}. Will be removed in v8.\n */\nexport function concat<T, R>(...args: any[]): OperatorFunction<T, R> {\n  const scheduler = popScheduler(args);\n  return operate((source, subscriber) => {\n    concatAll()(from([source, ...args], scheduler)).subscribe(subscriber);\n  });\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { concat } from './concat';\n\n/**\n * Emits all of the values from the source observable, then, once it completes, subscribes\n * to each observable source provided, one at a time, emitting all of their values, and not subscribing\n * to the next one until it completes.\n *\n * `concat(a$, b$, c$)` is the same as `a$.pipe(concatWith(b$, c$))`.\n *\n * ## Example\n *\n * Listen for one mouse click, then listen for all mouse moves.\n *\n * ```ts\n * import { fromEvent, map, take, concatWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click');\n * const moves$ = fromEvent(document, 'mousemove');\n *\n * clicks$.pipe(\n *   map(() => 'click'),\n *   take(1),\n *   concatWith(\n *     moves$.pipe(\n *       map(() => 'move')\n *     )\n *   )\n * )\n * .subscribe(x => console.log(x));\n *\n * // 'click'\n * // 'move'\n * // 'move'\n * // 'move'\n * // ...\n * ```\n *\n * @param otherSources Other observable sources to subscribe to, in sequence, after the original source is complete.\n * @return A function that returns an Observable that concatenates\n * subscriptions to the source and provided Observables subscribing to the next\n * only once the current subscription completes.\n */\nexport function concatWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return concat(...otherSources);\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscribable } from '../types';\n\n/**\n * Used to convert a subscribable to an observable.\n *\n * Currently, this is only used within internals.\n *\n * TODO: Discuss ObservableInput supporting \"Subscribable\".\n * https://github.com/ReactiveX/rxjs/issues/5909\n *\n * @param subscribable A subscribable\n */\nexport function fromSubscribable<T>(subscribable: Subscribable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => subscribable.subscribe(subscriber));\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf, SubjectLike } from '../types';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { fromSubscribable } from '../observable/fromSubscribable';\n\n/**\n * An object used to configure {@link connect} operator.\n */\nexport interface ConnectConfig<T> {\n  /**\n   * A factory function used to create the Subject through which the source\n   * is multicast. By default, this creates a {@link Subject}.\n   */\n  connector: () => SubjectLike<T>;\n}\n\n/**\n * The default configuration for `connect`.\n */\nconst DEFAULT_CONFIG: ConnectConfig<unknown> = {\n  connector: () => new Subject<unknown>(),\n};\n\n/**\n * Creates an observable by multicasting the source within a function that\n * allows the developer to define the usage of the multicast prior to connection.\n *\n * This is particularly useful if the observable source you wish to multicast could\n * be synchronous or asynchronous. This sets it apart from {@link share}, which, in the\n * case of totally synchronous sources will fail to share a single subscription with\n * multiple consumers, as by the time the subscription to the result of {@link share}\n * has returned, if the source is synchronous its internal reference count will jump from\n * 0 to 1 back to 0 and reset.\n *\n * To use `connect`, you provide a `selector` function that will give you\n * a multicast observable that is not yet connected. You then use that multicast observable\n * to create a resulting observable that, when subscribed, will set up your multicast. This is\n * generally, but not always, accomplished with {@link merge}.\n *\n * Note that using a {@link takeUntil} inside of `connect`'s `selector` _might_ mean you were looking\n * to use the {@link takeWhile} operator instead.\n *\n * When you subscribe to the result of `connect`, the `selector` function will be called. After\n * the `selector` function returns, the observable it returns will be subscribed to, _then_ the\n * multicast will be connected to the source.\n *\n * ## Example\n *\n * Sharing a totally synchronous observable\n *\n * ```ts\n * import { of, tap, connect, merge, map, filter } from 'rxjs';\n *\n * const source$ = of(1, 2, 3, 4, 5).pipe(\n *   tap({\n *     subscribe: () => console.log('subscription started'),\n *     next: n => console.log(`source emitted ${ n }`)\n *   })\n * );\n *\n * source$.pipe(\n *   // Notice in here we're merging 3 subscriptions to `shared$`.\n *   connect(shared$ => merge(\n *     shared$.pipe(map(n => `all ${ n }`)),\n *     shared$.pipe(filter(n => n % 2 === 0), map(n => `even ${ n }`)),\n *     shared$.pipe(filter(n => n % 2 === 1), map(n => `odd ${ n }`))\n *   ))\n * )\n * .subscribe(console.log);\n *\n * // Expected output: (notice only one subscription)\n * 'subscription started'\n * 'source emitted 1'\n * 'all 1'\n * 'odd 1'\n * 'source emitted 2'\n * 'all 2'\n * 'even 2'\n * 'source emitted 3'\n * 'all 3'\n * 'odd 3'\n * 'source emitted 4'\n * 'all 4'\n * 'even 4'\n * 'source emitted 5'\n * 'all 5'\n * 'odd 5'\n * ```\n *\n * @param selector A function used to set up the multicast. Gives you a multicast observable\n * that is not yet connected. With that, you're expected to create and return\n * and Observable, that when subscribed to, will utilize the multicast observable.\n * After this function is executed -- and its return value subscribed to -- the\n * operator will subscribe to the source, and the connection will be made.\n * @param config The configuration object for `connect`.\n */\nexport function connect<T, O extends ObservableInput<unknown>>(\n  selector: (shared: Observable<T>) => O,\n  config: ConnectConfig<T> = DEFAULT_CONFIG\n): OperatorFunction<T, ObservedValueOf<O>> {\n  const { connector } = config;\n  return operate((source, subscriber) => {\n    const subject = connector();\n    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);\n    subscriber.add(source.subscribe(subject));\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { reduce } from './reduce';\n\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * ![](count.png)\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n *\n * ```ts\n * import { interval, fromEvent, takeUntil, count } from 'rxjs';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n *\n * ```ts\n * import { range, count } from 'rxjs';\n *\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param predicate A function that is used to analyze the value and the index and\n * determine whether or not to increment the count. Return `true` to increment the count,\n * and return `false` to keep the count the same.\n * If the predicate is not provided, every value will be counted.\n * @return A function that returns an Observable that emits one number that\n * represents the count of emissions.\n */\nexport function count<T>(predicate?: (value: T, index: number) => boolean): OperatorFunction<T, number> {\n  return reduce((total, value, i) => (!predicate || predicate(value, i) ? total + 1 : total), 0);\n}\n","import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.svg)\n *\n * `debounce` delays notifications emitted by the source Observable, but drops previous\n * pending delayed emissions if a new notification arrives on the source Observable.\n * This operator keeps track of the most recent notification from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The notification is emitted only when the duration\n * Observable emits a next notification, and if no other notification was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * notification appears before the duration Observable emits, the previous notification will\n * not be emitted and a new duration is scheduled from `durationSelector` is scheduled.\n * If the completing event happens during the scheduled duration the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during the scheduled duration or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, scan, debounce, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   scan(i => ++i, 1),\n *   debounce(i => interval(200 * i))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n */\nexport function debounce<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    // The subscriber/subscription for the current debounce, if there is one.\n    let durationSubscriber: Subscriber<any> | null = null;\n\n    const emit = () => {\n      // Unsubscribe any current debounce subscription we have,\n      // we only cared about the first notification from it, and we\n      // want to clean that subscription up as soon as possible.\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        // We have a value! Free up memory first, then emit the value.\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Cancel any pending debounce duration. We don't\n          // need to null it out here yet tho, because we're just going\n          // to create another one in a few lines.\n          durationSubscriber?.unsubscribe();\n          hasValue = true;\n          lastValue = value;\n          // Capture our duration subscriber, so we can unsubscribe it when we're notified\n          // and we're going to emit the value.\n          durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);\n          // Subscribe to the duration.\n          innerFrom(durationSelector(value)).subscribe(durationSubscriber);\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = durationSubscriber = null;\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent notification from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays notifications emitted by the source Observable, but drops\n * previous pending delayed emissions if a new notification arrives on the source\n * Observable. This operator keeps track of the most recent notification from the\n * source Observable, and emits that only when `dueTime` has passed\n * without any other notification appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous notification will be dropped\n * and will not be emitted and a new `dueTime` is scheduled.\n * If the completing event happens during `dueTime` the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during `dueTime` or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * notification to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, debounceTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param dueTime The timeout duration in milliseconds (or the time unit determined\n * internally by the optional `scheduler`) for the window of time required to wait\n * for emission silence before emitting the most recent source value.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers that\n * handle the timeout for each value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified `dueTime`, and may drop some values\n * if they occur too frequently.\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let activeTask: Subscription | null = null;\n    let lastValue: T | null = null;\n    let lastTime: number | null = null;\n\n    const emit = () => {\n      if (activeTask) {\n        // We have a value! Free up memory first, then emit the value.\n        activeTask.unsubscribe();\n        activeTask = null;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\n      // This is called `dueTime` after the first value\n      // but we might have received new values during this window!\n\n      const targetTime = lastTime! + dueTime;\n      const now = scheduler.now();\n      if (now < targetTime) {\n        // On that case, re-schedule to the new target\n        activeTask = this.schedule(undefined, targetTime - now);\n        subscriber.add(activeTask);\n        return;\n      }\n\n      emit();\n    }\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          lastValue = value;\n          lastTime = scheduler.now();\n\n          // Only set up a task if it's not already up\n          if (!activeTask) {\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n            subscriber.add(activeTask);\n          }\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = activeTask = null;\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n *\n * If no clicks happen in 5 seconds, then emit 'no clicks'\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, defaultIfEmpty } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param defaultValue The default value used if the source\n * Observable is empty.\n * @return A function that returns an Observable that emits either the\n * specified `defaultValue` if the source Observable emits no items, or the\n * values emitted by the source Observable.\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => {\n          if (!hasValue) {\n            subscriber.next(defaultValue!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n *\n * Take the first 5 seconds of an infinite 1-second interval Observable\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of `next` values to emit.\n * @return A function that returns an Observable that emits only the first\n * `count` values emitted by the source Observable, or all of the values from\n * the source if the source emits fewer than `count` values.\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? // If we are taking no values, that's empty.\n      () => EMPTY\n    : operate((source, subscriber) => {\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Increment the number of values we have seen,\n            // then check it against the allowed count to see\n            // if we are still letting values through.\n            if (++seen <= count) {\n              subscriber.next(value);\n              // If we have met or passed our allowed count,\n              // we need to complete. We have to do <= here,\n              // because re-entrant code will increment `seen` twice.\n              if (count <= seen) {\n                subscriber.complete();\n              }\n            }\n          })\n        );\n      });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * The `ignoreElements` operator suppresses all items emitted by the source Observable,\n * but allows its termination notification (either `error` or `complete`) to pass through unchanged.\n *\n * If you do not care about the items being emitted by an Observable, but you do want to be notified\n * when it completes or when it terminates with an error, you can apply the `ignoreElements` operator\n * to the Observable, which will ensure that it will never call its observers’ `next` handlers.\n *\n * ## Example\n *\n * Ignore all `next` emissions from the source\n *\n * ```ts\n * import { of, ignoreElements } from 'rxjs';\n *\n * of('you', 'talking', 'to', 'me')\n *   .pipe(ignoreElements())\n *   .subscribe({\n *     next: word => console.log(word),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // result:\n * // 'the end'\n * ```\n *\n * @return A function that returns an empty Observable that only calls\n * `complete` or `error`, based on which one is called by the source\n * Observable.\n */\nexport function ignoreElements(): OperatorFunction<unknown, never> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, noop));\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { map } from './map';\n\n/** @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`. */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R>;\n/**\n * @deprecated Do not specify explicit type parameters. Signatures with type parameters\n * that cannot be inferred will be removed in v8. `mapTo` itself will be removed in v9,\n * use {@link map} instead: `map(() => value)`.\n * */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R>;\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n *\n * Map every click to the string `'Hi'`\n *\n * ```ts\n * import { fromEvent, mapTo } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n *\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param value The value to map each source value to.\n * @return A function that returns an Observable that emits the given `value`\n * every time the source Observable emits.\n * @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`.\n */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R> {\n  return map(() => value);\n}\n","import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { concat } from '../observable/concat';\nimport { take } from './take';\nimport { ignoreElements } from './ignoreElements';\nimport { mapTo } from './mapTo';\nimport { mergeMap } from './mergeMap';\nimport { innerFrom } from '../observable/innerFrom';\n\n/** @deprecated The `subscriptionDelay` parameter will be removed in v8. */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay: Observable<any>\n): MonoTypeOperatorFunction<T>;\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => ObservableInput<any>): MonoTypeOperatorFunction<T>;\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * ![](delayWhen.png)\n *\n * `delayWhen` operator shifts each emitted value from the source Observable by\n * a time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the value emitted from\n * the source Observable as the first argument to the `delayDurationSelector`.\n * The `delayDurationSelector` function should return an {@link ObservableInput},\n * that is internally converted to an Observable that is called the \"duration\"\n * Observable.\n *\n * The source value is emitted on the output Observable only when the \"duration\"\n * Observable emits ({@link guide/glossary-and-semantics#next next}s) any value.\n * Upon that, the \"duration\" Observable gets unsubscribed.\n *\n * Before RxJS V7, the {@link guide/glossary-and-semantics#complete completion}\n * of the \"duration\" Observable would have been triggering the emission of the\n * source value to the output Observable, but with RxJS V7, this is not the case\n * anymore.\n *\n * Only next notifications (from the \"duration\" Observable) trigger values from\n * the source Observable to be passed to the output Observable. If the \"duration\"\n * Observable only emits the complete notification (without next), the value\n * emitted by the source Observable will never get to the output Observable - it\n * will be swallowed. If the \"duration\" Observable errors, the error will be\n * propagated to the output Observable.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * ## Example\n *\n * Delay each click by a random amount of time, between 0 and 5 seconds\n *\n * ```ts\n * import { fromEvent, delayWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(\n *   delayWhen(() => interval(Math.random() * 5000))\n * );\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delay}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param delayDurationSelector A function that returns an `ObservableInput` for\n * each `value` emitted by the source Observable, which is then used to delay the\n * emission of that `value` on the output Observable until the `ObservableInput`\n * returned from this function emits a next value. When called, beside `value`,\n * this function receives a zero-based `index` of the emission order.\n * @param subscriptionDelay An Observable that triggers the subscription to the\n * source Observable once it emits any value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by an amount of time specified by the Observable\n * returned by `delayDurationSelector`.\n */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay?: Observable<any>\n): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n  }\n\n  return mergeMap((value, index) => innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)));\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { delayWhen } from './delayWhen';\nimport { timer } from '../observable/timer';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.svg)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n *\n * Delay each click by one second\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delayWhen}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param due The delay duration in milliseconds (a `number`) or a `Date` until\n * which the emission of the source items is delayed.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\n * that handle the time-shift for each item.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified timeout or Date.\n */\nexport function delay<T>(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  const duration = timer(due, scheduler);\n  return delayWhen(() => duration);\n}\n","import { observeNotification } from '../Notification';\nimport { OperatorFunction, ObservableNotification, ValueFromNotification } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Converts an Observable of {@link ObservableNotification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link ObservableNotification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * ![](dematerialize.png)\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link ObservableNotification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n *\n * Convert an Observable of Notifications to an actual Observable\n *\n * ```ts\n * import { NextNotification, ErrorNotification, of, dematerialize } from 'rxjs';\n *\n * const notifA: NextNotification<string> = { kind: 'N', value: 'A' };\n * const notifB: NextNotification<string> = { kind: 'N', value: 'B' };\n * const notifE: ErrorNotification = { kind: 'E', error: new TypeError('x.toUpperCase is not a function') };\n *\n * const materialized = of(notifA, notifB, notifE);\n *\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe({\n *   next: x => console.log(x),\n *   error: e => console.error(e)\n * });\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link materialize}\n *\n * @return A function that returns an Observable that emits items and\n * notifications embedded in Notification objects emitted by the source\n * Observable.\n */\nexport function dematerialize<N extends ObservableNotification<any>>(): OperatorFunction<N, ValueFromNotification<N>> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, (notification) => observeNotification(notification, subscriber)));\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a `keySelector` function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If the `keySelector` function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n *\n * A simple example with numbers\n *\n * ```ts\n * import { of, distinct } from 'rxjs';\n *\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .pipe(distinct())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * An example using the `keySelector` function\n *\n * ```ts\n * import { of, distinct } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo'},\n *   { age: 7, name: 'Bar'},\n *   { age: 5, name: 'Foo'}\n * )\n * .pipe(distinct(({ name }) => name))\n * .subscribe(x => console.log(x));\n *\n * // Outputs\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param keySelector Optional `function` to select which value you want to check as distinct.\n * @param flushes Optional `ObservableInput` for flushing the internal HashSet of the operator.\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinct<T, K>(keySelector?: (value: T) => K, flushes?: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    const distinctKeys = new Set();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const key = keySelector ? keySelector(value) : value;\n        if (!distinctKeys.has(key)) {\n          distinctKeys.add(key);\n          subscriber.next(value);\n        }\n      })\n    );\n\n    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, () => distinctKeys.clear(), noop));\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(\n  comparator: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a result {@link Observable} that emits all values pushed by the source observable if they\n * are distinct in comparison to the last value the result observable emitted.\n *\n * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),\n * it behaves like this:\n *\n * 1. It will always emit the first value from the source.\n * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values\n *    using the provided `comparator` or an `===` equality check.\n * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and\n *    becomes the new \"previously emitted value\" internally.\n *\n * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior\n * changes:\n *\n * 1. It will always emit the first value from the source.\n * 2. The `keySelector` will be run against all values, including the first value.\n * 3. For all values after the first, the selected key will be compared against the key selected from\n *    the previously emitted value using the `comparator`.\n * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted\n *    and the selected key from that value is saved for future comparisons against other keys.\n *\n * ## Examples\n *\n * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,\n * because it's distinct in comparison to the _previously emitted_ value,\n * not in comparison to _all other emitted values_.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)\n *   .pipe(distinctUntilChanged())\n *   .subscribe(console.log);\n * // Logs: 1, 2, 1, 3\n * ```\n *\n * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say\n * you only want to emit a value when all of its components have\n * changed:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const totallyDifferentBuilds$ = of(\n *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },\n *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },\n *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ).pipe(\n *   distinctUntilChanged((prev, curr) => {\n *     return (\n *       prev.engineVersion === curr.engineVersion ||\n *       prev.transmissionVersion === curr.transmissionVersion\n *     );\n *   })\n * );\n *\n * totallyDifferentBuilds$.subscribe(console.log);\n *\n * // Logs:\n * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }\n * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }\n * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ```\n *\n * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted\n * changes are only in one direction. Let's say you only want to get\n * the next record temperature:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);\n *\n * const recordHighs$ = temps$.pipe(\n *   distinctUntilChanged((prevHigh, temp) => {\n *     // If the current temp is less than\n *     // or the same as the previous record,\n *     // the record hasn't changed.\n *     return temp <= prevHigh;\n *   })\n * );\n *\n * recordHighs$.subscribe(console.log);\n * // Logs: 30, 31, 34, 35\n * ```\n *\n * Selecting update events only when the `updatedBy` field shows\n * the account changed hands.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * // A stream of updates to a given account\n * const accountUpdates$ = of(\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'blesh', data: [] }\n * );\n *\n * // We only want the events where it changed hands\n * const changedHands$ = accountUpdates$.pipe(\n *   distinctUntilChanged(undefined, update => update.updatedBy)\n * );\n *\n * changedHands$.subscribe(console.log);\n * // Logs:\n * // { updatedBy: 'blesh', data: Array[0] }\n * // { updatedBy: 'ncjamieson', data: Array[0] }\n * // { updatedBy: 'blesh', data: Array[0] }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param comparator A function used to compare the previous and current keys for\n * equality. Defaults to a `===` check.\n * @param keySelector Used to select a key value to be passed to the `comparator`.\n *\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinctUntilChanged<T, K>(\n  comparator?: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K = identity as (value: T) => K\n): MonoTypeOperatorFunction<T> {\n  // We've been allowing `null` do be passed as the `compare`, so we can't do\n  // a default value for the parameter, because that will only work\n  // for `undefined`.\n  comparator = comparator ?? defaultCompare;\n\n  return operate((source, subscriber) => {\n    // The previous key, used to compare against keys selected\n    // from new arrivals to determine \"distinctiveness\".\n    let previousKey: K;\n    // Whether or not this is the first value we've gotten.\n    let first = true;\n\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        // We always call the key selector.\n        const currentKey = keySelector(value);\n\n        // If it's the first value, we always emit it.\n        // Otherwise, we compare this key to the previous key, and\n        // if the comparer returns false, we emit.\n        if (first || !comparator!(previousKey, currentKey)) {\n          // Update our state *before* we emit the value\n          // as emission can be the source of re-entrant code\n          // in functional libraries like this. We only really\n          // need to do this if it's the first value, or if the\n          // key we're tracking in previous needs to change.\n          first = false;\n          previousKey = currentKey;\n\n          // Emit the value!\n          subscriber.next(value);\n        }\n      })\n    );\n  });\n}\n\nfunction defaultCompare(a: any, b: any) {\n  return a === b;\n}\n","import { distinctUntilChanged } from './distinctUntilChanged';\nimport { MonoTypeOperatorFunction } from '../types';\n\nexport function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that\n * are distinct by comparison from the previous item, using a property accessed by\n * using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to\n * test for whether that value should be emitted or not.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Examples\n *\n * An example comparing the name of persons\n *\n * ```ts\n * import { of, distinctUntilKeyChanged } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo' },\n *   { age: 7, name: 'Bar' },\n *   { age: 5, name: 'Foo' },\n *   { age: 6, name: 'Foo' }\n * ).pipe(\n *   distinctUntilKeyChanged('name')\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * An example comparing the first letters of the name\n *\n * ```ts\n * import { of, distinctUntilKeyChanged } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo1' },\n *   { age: 7, name: 'Bar' },\n *   { age: 5, name: 'Foo2' },\n *   { age: 6, name: 'Foo3' }\n * ).pipe(\n *   distinctUntilKeyChanged('name', (x, y) => x.substring(0, 3) === y.substring(0, 3))\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param key String key for object property lookup on each item.\n * @param compare Optional comparison function called to test if an item is distinct\n * from the previous item in the source.\n * @return A function that returns an Observable that emits items from the source\n * Observable with distinct values based on the key specified.\n */\nexport function distinctUntilKeyChanged<T, K extends keyof T>(\n  key: K,\n  compare?: (x: T[K], y: T[K]) => boolean\n): MonoTypeOperatorFunction<T> {\n  return distinctUntilChanged((x: T, y: T) => (compare ? compare(x[key], y[key]) : x[key] === y[key]));\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n *\n * Throw an error if the document wasn't clicked within 1 second\n *\n * ```ts\n * import { fromEvent, takeUntil, timer, throwIfEmpty } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(() => new Error('The document was not clicked within 1 second'))\n * )\n * .subscribe({\n *   next() {\n *    console.log('The document was clicked');\n *   },\n *   error(err) {\n *     console.error(err.message);\n *   }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n * @return A function that returns an Observable that throws an error if the\n * source Observable completed without emitting.\n */\nexport function throwIfEmpty<T>(errorFactory: () => any = defaultErrorFactory): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))\n      )\n    );\n  });\n}\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n","import { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { filter } from './filter';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { take } from './take';\n\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * ![](elementAt.png)\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * ## Example\n *\n * Emit only the third click event\n *\n * ```ts\n * import { fromEvent, elementAt } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(elementAt(2));\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n * ```\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * `ArgumentOutOfRangeError` to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param index Is the number `i` for the i-th source emission that has happened\n * since the subscription, starting from the number `0`.\n * @param defaultValue The default value returned for missing indices.\n * @return A function that returns an Observable that emits a single item, if\n * it is found. Otherwise, it will emit the default value if given. If not, it\n * emits an error.\n */\nexport function elementAt<T, D = T>(index: number, defaultValue?: D): OperatorFunction<T, T | D> {\n  if (index < 0) {\n    throw new ArgumentOutOfRangeError();\n  }\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      filter((v, i) => i === index),\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new ArgumentOutOfRangeError())\n    );\n}\n","/** prettier */\nimport { Observable } from '../Observable';\nimport { concat } from '../observable/concat';\nimport { of } from '../observable/of';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ValueFromArray } from '../types';\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function endWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function endWith<T, A extends unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\n\nexport function endWith<T, A extends unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that will emit all values from the source, then synchronously emit\n * the provided value(s) immediately after the source completes.\n *\n * NOTE: Passing a last argument of a Scheduler is _deprecated_, and may result in incorrect\n * types in TypeScript.\n *\n * This is useful for knowing when an observable ends. Particularly when paired with an\n * operator like {@link takeUntil}\n *\n * ![](endWith.png)\n *\n * ## Example\n *\n * Emit values to know when an interval starts and stops. The interval will\n * stop when a user clicks anywhere on the document.\n *\n * ```ts\n * import { interval, map, fromEvent, startWith, takeUntil, endWith } from 'rxjs';\n *\n * const ticker$ = interval(5000).pipe(\n *   map(() => 'tick')\n * );\n *\n * const documentClicks$ = fromEvent(document, 'click');\n *\n * ticker$.pipe(\n *   startWith('interval started'),\n *   takeUntil(documentClicks$),\n *   endWith('interval ended by click')\n * )\n * .subscribe(x => console.log(x));\n *\n * // Result (assuming a user clicks after 15 seconds)\n * // 'interval started'\n * // 'tick'\n * // 'tick'\n * // 'tick'\n * // 'interval ended by click'\n * ```\n *\n * @see {@link startWith}\n * @see {@link concat}\n * @see {@link takeUntil}\n *\n * @param values Items you want the modified Observable to emit last.\n * @return A function that returns an Observable that emits all values from the\n * source, then synchronously emits the provided value(s) immediately after the\n * source completes.\n */\nexport function endWith<T>(...values: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => concat(source, of(...values)) as Observable<T>;\n}\n","import { Observable } from '../Observable';\nimport { Falsy, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function every<T>(predicate: BooleanConstructor): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function every<T>(\n  predicate: BooleanConstructor,\n  thisArg: any\n): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function every<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, boolean>;\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, boolean>;\n\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * <span class=\"informal\">If all values pass predicate before the source completes, emits true before completion,\n * otherwise emit false, then complete.</span>\n *\n * ![](every.png)\n *\n * ## Example\n *\n * A simple example emitting true if all elements are less than 5, false otherwise\n *\n * ```ts\n * import { of, every } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5, 6)\n *   .pipe(every(x => x < 5))\n *   .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param predicate A function for determining if an item meets a specified condition.\n * @param thisArg Optional object to use for `this` in the callback.\n * @return A function that returns an Observable of booleans that determines if\n * all items of the source Observable meet the condition specified.\n */\nexport function every<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          if (!predicate.call(thisArg, value, index++, source)) {\n            subscriber.next(false);\n            subscriber.complete();\n          }\n        },\n        () => {\n          subscriber.next(true);\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function exhaustMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function exhaustMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaustAll}.</span>\n *\n * ![](exhaustMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * ## Example\n *\n * Run a finite timer for each click, only if there is no currently active timer\n *\n * ```ts\n * import { fromEvent, exhaustMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   exhaustMap(() => interval(1000).pipe(take(5)))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @return A function that returns an Observable containing projected\n * Observables of each item of the source, ignoring projected Observables that\n * start before their preceding Observable has completed.\n */\nexport function exhaustMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      source.pipe(exhaustMap((a, i) => innerFrom(project(a, i)).pipe(map((b: any, ii: any) => resultSelector(a, b, i, ii)))));\n  }\n  return operate((source, subscriber) => {\n    let index = 0;\n    let innerSub: Subscriber<T> | null = null;\n    let isComplete = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (outerValue) => {\n          if (!innerSub) {\n            innerSub = createOperatorSubscriber(subscriber, undefined, () => {\n              innerSub = null;\n              isComplete && subscriber.complete();\n            });\n            innerFrom(project(outerValue, index++)).subscribe(innerSub);\n          }\n        },\n        () => {\n          isComplete = true;\n          !innerSub && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { exhaustMap } from './exhaustMap';\nimport { identity } from '../util/identity';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * ![](exhaustAll.svg)\n *\n * `exhaustAll` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaustAll` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * ## Example\n *\n * Run a finite timer for each click, only if there is no currently active timer\n *\n * ```ts\n * import { fromEvent, map, interval, take, exhaustAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(5)))\n * );\n * const result = higherOrder.pipe(exhaustAll());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable that takes a source of\n * Observables and propagates the first Observable exclusively until it\n * completes before subscribing to the next.\n */\nexport function exhaustAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return exhaustMap(identity);\n}\n","import { exhaustAll } from './exhaustAll';\n\n/**\n * @deprecated Renamed to {@link exhaustAll}. Will be removed in v8.\n */\nexport const exhaust = exhaustAll;\n","import { OperatorFunction, ObservableInput, ObservedValueOf, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/* tslint:disable:max-line-length */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. If you need to schedule the inner subscription,\n * use `subscribeOn` within the projection function: `expand((value) => fn(value).pipe(subscribeOn(scheduler)))`.\n * Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent: number | undefined,\n  scheduler: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * ![](expand.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * ## Example\n *\n * Start emitting the powers of two on every click, at most 10 of them\n *\n * ```ts\n * import { fromEvent, map, expand, of, delay, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const powersOfTwo = clicks.pipe(\n *   map(() => 1),\n *   expand(x => of(2 * x).pipe(delay(1000))),\n *   take(10)\n * );\n * powersOfTwo.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param project A function that, when applied to an item emitted by the source\n * or the output Observable, returns an Observable.\n * @param concurrent Maximum number of input Observables being subscribed to\n * concurrently.\n * @param scheduler The {@link SchedulerLike} to use for subscribing to\n * each projected inner Observable.\n * @return A function that returns an Observable that emits the source values\n * and also result of applying the projection function to each value emitted on\n * the output Observable and merging the results of the Observables obtained\n * from this transformation.\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent = Infinity,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>> {\n  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;\n  return operate((source, subscriber) =>\n    mergeInternals(\n      // General merge params\n      source,\n      subscriber,\n      project,\n      concurrent,\n\n      // onBeforeNext\n      undefined,\n\n      // Expand-specific\n      true, // Use expand path\n      scheduler // Inner subscription scheduler\n    )\n  );\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * The specified function will also be called when the subscriber explicitly unsubscribes.\n *\n * ## Examples\n *\n * Execute callback function when the observable completes\n *\n * ```ts\n * import { interval, take, finalize } from 'rxjs';\n *\n * // emit value in sequence every 1 second\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(5), //take only the first 5 values\n *   finalize(() => console.log('Sequence complete')) // Execute when the observable completes\n * );\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 'Sequence complete'\n * ```\n *\n * Execute callback function when the subscriber explicitly unsubscribes\n *\n * ```ts\n * import { interval, finalize, tap, noop, timer } from 'rxjs';\n *\n * const source = interval(100).pipe(\n *   finalize(() => console.log('[finalize] Called')),\n *   tap({\n *     next: () => console.log('[next] Called'),\n *     error: () => console.log('[error] Not called'),\n *     complete: () => console.log('[tap complete] Not called')\n *   })\n * );\n *\n * const sub = source.subscribe({\n *   next: x => console.log(x),\n *   error: noop,\n *   complete: () => console.log('[complete] Not called')\n * });\n *\n * timer(150).subscribe(() => sub.unsubscribe());\n *\n * // results:\n * // '[next] Called'\n * // 0\n * // '[finalize] Called'\n * ```\n *\n * @param callback Function to be called when source terminates.\n * @return A function that returns an Observable that mirrors the source, but\n * will call the specified function on termination.\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // TODO: This try/finally was only added for `useDeprecatedSynchronousErrorHandling`.\n    // REMOVE THIS WHEN THAT HOT GARBAGE IS REMOVED IN V8.\n    try {\n      source.subscribe(subscriber);\n    } finally {\n      subscriber.add(callback);\n    }\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function find<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function find<T, S extends T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => value is S,\n  thisArg: A\n): OperatorFunction<T, S | undefined>;\nexport function find<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S\n): OperatorFunction<T, S | undefined>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function find<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, T | undefined>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, T | undefined>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * ![](find.png)\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found\n * (emits `undefined` instead).\n *\n * ## Example\n *\n * Find and emit the first click that happens on a DIV element\n *\n * ```ts\n * import { fromEvent, find } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(find(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param predicate A function called with each item to test for condition matching.\n * @param thisArg An optional argument to determine the value of `this` in the\n * `predicate` function.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function find<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, T | undefined> {\n  return operate(createFind(predicate, thisArg, 'value'));\n}\n\nexport function createFind<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: any,\n  emit: 'value' | 'index'\n) {\n  const findIndex = emit === 'index';\n  return (source: Observable<T>, subscriber: Subscriber<any>) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          const i = index++;\n          if (predicate.call(thisArg, value, i, source)) {\n            subscriber.next(findIndex ? i : value);\n            subscriber.complete();\n          }\n        },\n        () => {\n          subscriber.next(findIndex ? -1 : undefined);\n          subscriber.complete();\n        }\n      )\n    );\n  };\n}\n","import { Observable } from '../Observable';\nimport { Falsy, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createFind } from './find';\n\nexport function findIndex<T>(predicate: BooleanConstructor): OperatorFunction<T, T extends Falsy ? -1 : number>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function findIndex<T>(predicate: BooleanConstructor, thisArg: any): OperatorFunction<T, T extends Falsy ? -1 : number>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function findIndex<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, number>;\nexport function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number>;\n\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * ![](findIndex.png)\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * ## Example\n *\n * Emit the index of first click that happens on a DIV element\n *\n * ```ts\n * import { fromEvent, findIndex } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(findIndex(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param predicate A function called with each item to test for condition matching.\n * @param thisArg An optional argument to determine the value of `this` in the\n * `predicate` function.\n * @return A function that returns an Observable that emits the index of the\n * first item that matches the condition.\n */\nexport function findIndex<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, number> {\n  return operate(createFind(predicate, thisArg, 'index'));\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function first<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function first<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function first<T, S extends T, D>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue: D\n): OperatorFunction<T, S | D>;\nexport function first<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. Emits an error\n * notification if `defaultValue` was not provided and a matching element is not found.\n *\n * ## Examples\n *\n * Emit only the first click that happens on the DOM\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n * @see {@link last}\n *\n * @throws {EmptyError} Delivers an `EmptyError` to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * This is how `first()` is different from `take(1)` which completes instead.\n *\n * @param predicate An optional function called with each item to test for condition\n * matching.\n * @param defaultValue The default value emitted in case no valid value was found on\n * the source.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function first<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\n\nexport interface BasicGroupByOptions<K, T> {\n  element?: undefined;\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\n  connector?: () => SubjectLike<T>;\n}\n\nexport interface GroupByOptionsWithElement<K, E, T> {\n  element: (value: T) => E;\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\n  connector?: () => SubjectLike<E>;\n}\n\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\n\nexport function groupBy<T, K, E>(\n  key: (value: T) => K,\n  options: GroupByOptionsWithElement<K, E, T>\n): OperatorFunction<T, GroupedObservable<K, E>>;\n\nexport function groupBy<T, K extends T>(\n  key: (value: T) => value is K\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\n\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K>(\n  key: (value: T) => K,\n  element: void,\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the key function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the `key` field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the element function.\n *\n * ## Examples\n *\n * Group objects by `id` and return as array\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [{ id: 1, name: 'JavaScript' }, { id: 1, name: 'TypeScript'}]\n * // [{ id: 2, name: 'Parcel' }, { id: 2, name: 'webpack'}]\n * // [{ id: 3, name: 'TSLint' }]\n * ```\n *\n * Pivot data on the `id` field\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce, map } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id, { element: p => p.name }),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [`${ group$.key }`]))),\n *   map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param key A function that extracts the key\n * for each item.\n * @param element A function that extracts the\n * return element for each item.\n * @param duration\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @param connector Factory function to create an\n * intermediate Subject through which grouped elements are emitted.\n * @return A function that returns an Observable that emits GroupedObservables,\n * each of which corresponds to a unique key value and each of which emits\n * those items from the source Observable that share that key value.\n *\n * @deprecated Use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  connector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n// Impl\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\n  connector?: () => SubjectLike<any>\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return operate((source, subscriber) => {\n    let element: ((value: any) => any) | void;\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions as ((value: any) => any);\n    } else {\n      ({ duration, element, connector } = elementOrOptions);\n    }\n\n    // A lookup for the groups that we have so far.\n    const groups = new Map<K, SubjectLike<any>>();\n\n    // Used for notifying all groups and the subscriber in the same way.\n    const notify = (cb: (group: Observer<any>) => void) => {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    // Used to handle errors from the source, AND errors that occur during the\n    // next call from the source.\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\n\n    // The number of actively subscribed groups\n    let activeGroups = 0;\n\n    // Whether or not teardown was attempted on this subscription.\n    let teardownAttempted = false;\n\n    // Capturing a reference to this, because we need a handle to it\n    // in `createGroupedObservable` below. This is what we use to\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\n    // in cases where a user unsubscribes from the main resulting subscription, but\n    // still has groups from this subscription subscribed and would expect values from it\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\n    const groupBySourceSubscriber = new OperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Because we have to notify all groups of any errors that occur in here,\n        // we have to add our own try/catch to ensure that those errors are propagated.\n        // OperatorSubscriber will only send the error to the main subscriber.\n        try {\n          const key = keySelector(value);\n\n          let group = groups.get(key);\n          if (!group) {\n            // Create our group subject\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\n\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\n            // because the grouped observable has special semantics around reference counting\n            // to ensure we don't sever our connection to the source prematurely.\n            const grouped = createGroupedObservable(key, group);\n            subscriber.next(grouped);\n\n            if (duration) {\n              const durationSubscriber = createOperatorSubscriber(\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\n                // when the duration subscription is torn down. That is important, because then\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\n                // after the connection to the source has been severed, they will get an\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\n                group as any,\n                () => {\n                  // Our duration notified! We can complete the group.\n                  // The group will be removed from the map in the finalization phase.\n                  group!.complete();\n                  durationSubscriber?.unsubscribe();\n                },\n                // Completions are also sent to the group, but just the group.\n                undefined,\n                // Errors on the duration subscriber are sent to the group\n                // but only the group. They are not sent to the main subscription.\n                undefined,\n                // Finalization: Remove this group from our map.\n                () => groups.delete(key)\n              );\n\n              // Start our duration notifier.\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n            }\n          }\n\n          // Send the value to our group.\n          group.next(element ? element(value) : value);\n        } catch (err) {\n          handleError(err);\n        }\n      },\n      // Source completes.\n      () => notify((consumer) => consumer.complete()),\n      // Error from the source.\n      handleError,\n      // Free up memory.\n      // When the source subscription is _finally_ torn down, release the subjects and keys\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\n      // don't have to.\n      () => groups.clear(),\n      () => {\n        teardownAttempted = true;\n        // We only kill our subscription to the source if we have\n        // no active groups. As stated above, consider this scenario:\n        // source$.pipe(groupBy(fn), take(2)).\n        return activeGroups === 0;\n      }\n    );\n\n    // Subscribe to the source\n    source.subscribe(groupBySourceSubscriber);\n\n    /**\n     * Creates the actual grouped observable returned.\n     * @param key The key of the group\n     * @param groupSubject The subject that fuels the group\n     */\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\n      const result: any = new Observable<T>((groupSubscriber) => {\n        activeGroups++;\n        const innerSub = groupSubject.subscribe(groupSubscriber);\n        return () => {\n          innerSub.unsubscribe();\n          // We can kill the subscription to our source if we now have no more\n          // active groups subscribed, and a finalization was already attempted on\n          // the source.\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\n/**\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\n * contains a `key` property for the grouping.\n */\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  /**\n   * The key value for the grouped notifications.\n   */\n  readonly key: K;\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits `false` if the input Observable emits any values, or emits `true` if the\n * input Observable completes without emitting any values.\n *\n * <span class=\"informal\">Tells whether any values are emitted by an Observable.</span>\n *\n * ![](isEmpty.png)\n *\n * `isEmpty` transforms an Observable that emits values into an Observable that\n * emits a single boolean value representing whether or not any values were\n * emitted by the source Observable. As soon as the source Observable emits a\n * value, `isEmpty` will emit a `false` and complete.  If the source Observable\n * completes having not emitted anything, `isEmpty` will emit a `true` and\n * complete.\n *\n * A similar effect could be achieved with {@link count}, but `isEmpty` can emit\n * a `false` value sooner.\n *\n * ## Examples\n *\n * Emit `false` for a non-empty Observable\n *\n * ```ts\n * import { Subject, isEmpty } from 'rxjs';\n *\n * const source = new Subject<string>();\n * const result = source.pipe(isEmpty());\n *\n * source.subscribe(x => console.log(x));\n * result.subscribe(x => console.log(x));\n *\n * source.next('a');\n * source.next('b');\n * source.next('c');\n * source.complete();\n *\n * // Outputs\n * // 'a'\n * // false\n * // 'b'\n * // 'c'\n * ```\n *\n * Emit `true` for an empty Observable\n *\n * ```ts\n * import { EMPTY, isEmpty } from 'rxjs';\n *\n * const result = EMPTY.pipe(isEmpty());\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // true\n * ```\n *\n * @see {@link count}\n * @see {@link EMPTY}\n *\n * @return A function that returns an Observable that emits boolean value\n * indicating whether the source Observable was empty or not.\n */\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          subscriber.next(false);\n          subscriber.complete();\n        },\n        () => {\n          subscriber.next(true);\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { EMPTY } from '../observable/empty';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Waits for the source to complete, then emits the last N values from the source,\n * as specified by the `count` argument.\n *\n * ![](takeLast.png)\n *\n * `takeLast` results in an observable that will hold values up to `count` values in memory,\n * until the source completes. It then pushes all values in memory to the consumer, in the\n * order they were received from the source, then notifies the consumer that it is\n * complete.\n *\n * If for some reason the source completes before the `count` supplied to `takeLast` is reached,\n * all values received until that point are emitted, and then completion is notified.\n *\n * **Warning**: Using `takeLast` with an observable that never completes will result\n * in an observable that never emits a value.\n *\n * ## Example\n *\n * Take the last 3 values of an Observable with many values\n *\n * ```ts\n * import { range, takeLast } from 'rxjs';\n *\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return A function that returns an Observable that emits at most the last\n * `count` values emitted by the source Observable.\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        // This buffer will hold the values we are going to emit\n        // when the source completes. Since we only want to take the\n        // last N values, we can't emit until we're sure we're not getting\n        // any more values.\n        let buffer: T[] = [];\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              // Add the most recent value onto the end of our buffer.\n              buffer.push(value);\n              // If our buffer is now larger than the number of values we\n              // want to take, we remove the oldest value from the buffer.\n              count < buffer.length && buffer.shift();\n            },\n            () => {\n              // The source completed, we now know what are last values\n              // are, emit them in the order they were received.\n              for (const value of buffer) {\n                subscriber.next(value);\n              }\n              subscriber.complete();\n            },\n            // Errors are passed through to the consumer\n            undefined,\n            () => {\n              // During finalization release the values in our buffer.\n              buffer = null!;\n            }\n          )\n        );\n      });\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function last<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function last<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function last<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function last<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function last<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * ![](last.png)\n *\n * It will emit an error notification if the source completes without notification or one that matches\n * the predicate. It returns the last value or if a predicate is provided last value that matches the\n * predicate. It returns the given default value if no notification is emitted or matches the predicate.\n *\n * ## Examples\n *\n * Last alphabet from the sequence\n *\n * ```ts\n * import { from, last } from 'rxjs';\n *\n * const source = from(['x', 'y', 'z']);\n * const result = source.pipe(last());\n *\n * result.subscribe(value => console.log(`Last alphabet: ${ value }`));\n *\n * // Outputs\n * // Last alphabet: z\n * ```\n *\n * Default value when the value in the predicate is not matched\n *\n * ```ts\n * import { from, last } from 'rxjs';\n *\n * const source = from(['x', 'y', 'z']);\n * const result = source.pipe(last(char => char === 'a', 'not found'));\n *\n * result.subscribe(value => console.log(`'a' is ${ value }.`));\n *\n * // Outputs\n * // 'a' is not found.\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n * @see {@link skipWhile}\n * @see {@link first}\n *\n * @throws {EmptyError} Delivers an `EmptyError` to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param predicate The condition any source emitted item has to satisfy.\n * @param defaultValue An optional default value to provide if last `predicate`\n * isn't met or no values were emitted.\n * @return A function that returns an Observable that emits only the last item\n * satisfying the given condition from the source, or an error notification\n * with an `EmptyError` object if no such items are emitted.\n */\nexport function last<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      takeLast(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n","import { Notification } from '../Notification';\nimport { OperatorFunction, ObservableNotification } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * ![](materialize.png)\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n *\n * Convert a faulty Observable to an Observable of Notifications\n *\n * ```ts\n * import { of, materialize, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map((x: any) => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n *\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification { kind: 'N', value: 'A', error: undefined, hasValue: true }\n * // - Notification { kind: 'N', value: 'B', error: undefined, hasValue: true }\n * // - Notification { kind: 'E', value: undefined, error: TypeError { message: x.toUpperCase is not a function }, hasValue: false }\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return A function that returns an Observable that emits\n * {@link Notification} objects that wrap the original emissions from the\n * source Observable with metadata.\n */\nexport function materialize<T>(): OperatorFunction<T, Notification<T> & ObservableNotification<T>> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          subscriber.next(Notification.createNext(value));\n        },\n        () => {\n          subscriber.next(Notification.createComplete());\n          subscriber.complete();\n        },\n        (err) => {\n          subscriber.next(Notification.createError(err));\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * The `max` operator operates on an Observable that emits numbers (or items that\n * can be compared with a provided function), and when source Observable completes\n * it emits a single item: the item with the largest value.\n *\n * ![](max.png)\n *\n * ## Examples\n *\n * Get the maximal value of a series of numbers\n *\n * ```ts\n * import { of, max } from 'rxjs';\n *\n * of(5, 4, 7, 2, 8)\n *   .pipe(max())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 8\n * ```\n *\n * Use a comparer function to get the maximal item\n *\n * ```ts\n * import { of, max } from 'rxjs';\n *\n * of(\n *   { age: 7, name: 'Foo' },\n *   { age: 5, name: 'Bar' },\n *   { age: 9, name: 'Beer' }\n * ).pipe(\n *   max((a, b) => a.age < b.age ? -1 : 1)\n * )\n * .subscribe(x => console.log(x.name));\n *\n * // Outputs\n * // 'Beer'\n * ```\n *\n * @see {@link min}\n *\n * @param comparer Optional comparer function that it will use instead of its\n * default to compare the value of two items.\n * @return A function that returns an Observable that emits item with the\n * largest value.\n */\nexport function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) > 0 ? x : y) : (x, y) => (x > y ? x : y));\n}\n","import { mergeMap } from './mergeMap';\n\n/**\n * @deprecated Renamed to {@link mergeMap}. Will be removed in v8.\n */\nexport const flatMap = mergeMap;\n","import { OperatorFunction, ObservedValueOf, ObservableInput } from '../types';\nimport { mergeMap } from './mergeMap';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)` */\nexport function mergeMapTo<O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  concurrent?: number\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/**\n * @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead.\n * Details: https://rxjs.dev/deprecations/resultSelector\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * ![](mergeMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * ## Example\n *\n * For each click event, start an interval Observable ticking every 1 second\n *\n * ```ts\n * import { fromEvent, mergeMapTo, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(mergeMapTo(interval(1000)));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param innerObservable An `ObservableInput` to replace each value from the\n * source Observable.\n * @param concurrent Maximum number of input Observables being subscribed to\n * concurrently.\n * @return A function that returns an Observable that emits items from the\n * given `innerObservable`.\n * @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)`\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    return mergeMap(() => innerObservable, resultSelector, concurrent);\n  }\n  if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return mergeMap(() => innerObservable, concurrent);\n}\n","import { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * The first parameter of the `mergeScan` is an `accumulator` function which is\n * being called every time the source Observable emits a value. `mergeScan` will\n * subscribe to the value returned by the `accumulator` function and will emit\n * values to the subscriber emitted by inner Observable.\n *\n * The `accumulator` function is being called with three parameters passed to it:\n * `acc`, `value` and `index`. The `acc` parameter is used as the state parameter\n * whose value is initially set to the `seed` parameter (the second parameter\n * passed to the `mergeScan` operator).\n *\n * `mergeScan` internally keeps the value of the `acc` parameter: as long as the\n * source Observable emits without inner Observable emitting, the `acc` will be\n * set to `seed`. The next time the inner Observable emits a value, `mergeScan`\n * will internally remember it and it will be passed to the `accumulator`\n * function as `acc` parameter the next time source emits.\n *\n * The `value` parameter of the `accumulator` function is the value emitted by the\n * source Observable, while the `index` is a number which represent the order of the\n * current emission by the source Observable. It starts with 0.\n *\n * The last parameter to the `mergeScan` is the `concurrent` value which defaults\n * to Infinity. It represents the maximum number of inner Observable subscriptions\n * at a time.\n *\n * ## Example\n *\n * Count the number of click events\n *\n * ```ts\n * import { fromEvent, map, mergeScan, of } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(map(() => 1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed)\n * );\n *\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...and so on for each click\n * ```\n *\n * @see {@link scan}\n * @see {@link switchScan}\n *\n * @param accumulator The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param concurrent Maximum number of input Observables being subscribed to\n * concurrently.\n * @return A function that returns an Observable of the accumulated values.\n */\nexport function mergeScan<T, R>(\n  accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n  seed: R,\n  concurrent = Infinity\n): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The accumulated state.\n    let state = seed;\n\n    return mergeInternals(\n      source,\n      subscriber,\n      (value, index) => accumulator(state, value, index),\n      concurrent,\n      (value) => {\n        state = value;\n      },\n      false,\n      undefined,\n      () => (state = null!)\n    );\n  });\n}\n","import { ObservableInput, ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeAll } from './mergeAll';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndConcurrency: [...ObservableInputTuple<A>, number]\n): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\nexport function merge<T>(...args: unknown[]): OperatorFunction<T, unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n\n  return operate((source, subscriber) => {\n    mergeAll(concurrent)(from([source, ...(args as ObservableInput<T>[])], scheduler)).subscribe(subscriber);\n  });\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { merge } from './merge';\n\n/**\n * Merge the values from all observables to a single observable result.\n *\n * Creates an observable, that when subscribed to, subscribes to the source\n * observable, and all other sources provided as arguments. All values from\n * every source are emitted from the resulting subscription.\n *\n * When all sources complete, the resulting observable will complete.\n *\n * When any source errors, the resulting observable will error.\n *\n * ## Example\n *\n * Joining all outputs from multiple user input event streams\n *\n * ```ts\n * import { fromEvent, map, mergeWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click').pipe(map(() => 'click'));\n * const mousemoves$ = fromEvent(document, 'mousemove').pipe(map(() => 'mousemove'));\n * const dblclicks$ = fromEvent(document, 'dblclick').pipe(map(() => 'dblclick'));\n *\n * mousemoves$\n *   .pipe(mergeWith(clicks$, dblclicks$))\n *   .subscribe(x => console.log(x));\n *\n * // result (assuming user interactions)\n * // 'mousemove'\n * // 'mousemove'\n * // 'mousemove'\n * // 'click'\n * // 'click'\n * // 'dblclick'\n * ```\n *\n * @see {@link merge}\n *\n * @param otherSources the sources to combine the current source with.\n * @return A function that returns an Observable that merges the values from\n * all given Observables.\n */\nexport function mergeWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return merge(...otherSources);\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * The `min` operator operates on an Observable that emits numbers (or items that\n * can be compared with a provided function), and when source Observable completes\n * it emits a single item: the item with the smallest value.\n *\n * ![](min.png)\n *\n * ## Examples\n *\n * Get the minimal value of a series of numbers\n *\n * ```ts\n * import { of, min } from 'rxjs';\n *\n * of(5, 4, 7, 2, 8)\n *   .pipe(min())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 2\n * ```\n *\n * Use a comparer function to get the minimal item\n *\n * ```ts\n * import { of, min } from 'rxjs';\n *\n * of(\n *   { age: 7, name: 'Foo' },\n *   { age: 5, name: 'Bar' },\n *   { age: 9, name: 'Beer' }\n * ).pipe(\n *   min((a, b) => a.age < b.age ? -1 : 1)\n * )\n * .subscribe(x => console.log(x.name));\n *\n * // Outputs\n * // 'Bar'\n * ```\n *\n * @see {@link max}\n *\n * @param comparer Optional comparer function that it will use instead of its\n * default to compare the value of two items.\n * @return A function that returns an Observable that emits item with the\n * smallest value.\n */\nexport function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) < 0 ? x : y) : (x, y) => (x < y ? x : y));\n}\n","import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { connect } from './connect';\n\n/**\n * An operator that creates a {@link ConnectableObservable}, that when connected,\n * with the `connect` method, will use the provided subject to multicast the values\n * from the source to all consumers.\n *\n * @param subject The subject to multicast through.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\n * `multicast(subject), refCount()` is equivalent to\n * `share({ connector: () => subject, resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\n * {@link connect} operator.\n *\n * @param subject The subject used to multicast.\n * @param selector A setup function to setup the multicast\n * @return A function that returns an observable that mirrors the observable returned by the selector.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `multicast(subject, selector)` is equivalent to\n * `connect(selector, { connector: () => subject })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, O extends ObservableInput<any>>(\n  subject: Subject<T>,\n  selector: (shared: Observable<T>) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * An operator that creates a {@link ConnectableObservable}, that when connected,\n * with the `connect` method, will use the provided subject to multicast the values\n * from the source to all consumers.\n *\n * @param subjectFactory A factory that will be called to create the subject. Passing a function here\n * will cause the underlying subject to be \"reset\" on error, completion, or refCounted unsubscription of\n * the source.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\n * `multicast(() => new BehaviorSubject('test')), refCount()` is equivalent to\n * `share({ connector: () => new BehaviorSubject('test') })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T>(subjectFactory: () => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\n * {@link connect} operator.\n *\n * @param subjectFactory A factory that creates the subject used to multicast.\n * @param selector A function to setup the multicast and select the output.\n * @return A function that returns an observable that mirrors the observable returned by the selector.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `multicast(subjectFactory, selector)` is equivalent to\n * `connect(selector, { connector: subjectFactory })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, O extends ObservableInput<any>>(\n  subjectFactory: () => Subject<T>,\n  selector: (shared: Observable<T>) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, R>(\n  subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n  selector?: (source: Observable<T>) => Observable<R>\n): OperatorFunction<T, R> {\n  const subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : () => subjectOrSubjectFactory;\n\n  if (isFunction(selector)) {\n    // If a selector function is provided, then we're a \"normal\" operator that isn't\n    // going to return a ConnectableObservable. We can use `connect` to do what we\n    // need to do.\n    return connect(selector, {\n      connector: subjectFactory,\n    });\n  }\n\n  return (source: Observable<T>) => new ConnectableObservable<any>(source, subjectFactory);\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { onErrorResumeNext as oERNCreate } from '../observable/onErrorResumeNext';\n\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  ...sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables, subscribes to next one on error or complete.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\n *\n *\n * ## Example\n *\n * Subscribe to the next Observable after map fails\n *\n * ```ts\n * import { of, onErrorResumeNext, map } from 'rxjs';\n *\n * of(1, 2, 3, 0)\n *   .pipe(\n *     map(x => {\n *       if (x === 0) {\n *         throw Error();\n *       }\n *\n *       return 10 / x;\n *     }),\n *     onErrorResumeNext(of(1, 2, 3))\n *   )\n *   .subscribe({\n *     next: val => console.log(val),\n *     error: err => console.log(err),          // Will never be called.\n *     complete: () => console.log('that\\'s it!')\n *   });\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // 'that's it!'\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param sources `ObservableInput`s passed either directly or as an array.\n * @return A function that returns an Observable that emits values from source\n * Observable, but - if it errors - subscribes to the next passed Observable\n * and so on, until it completes or runs out of Observables.\n */\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  // For some reason, TS 4.1 RC gets the inference wrong here and infers the\n  // result to be `A[number][]` - completely dropping the ObservableInput part\n  // of the type. This makes no sense whatsoever. As a workaround, the type is\n  // asserted explicitly.\n  const nextSources = argsOrArgArray(sources) as unknown as ObservableInputTuple<A>;\n\n  return (source) => oERNCreate(source, ...nextSources);\n}\n\n/**\n * @deprecated Renamed. Use {@link onErrorResumeNextWith} instead. Will be removed in v8.\n */\nexport const onErrorResumeNext = onErrorResumeNextWith;\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n *\n * On every click (starting from the second), emit the relative distance to the previous click\n *\n * ```ts\n * import { fromEvent, pairwise, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(([first, second]) => {\n *     const x0 = first.clientX;\n *     const y0 = first.clientY;\n *     const x1 = second.clientX;\n *     const y1 = second.clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   })\n * );\n *\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return A function that returns an Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return operate((source, subscriber) => {\n    let prev: T;\n    let hasPrev = false;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const p = prev;\n        prev = value;\n        hasPrev && subscriber.next([p, value]);\n        hasPrev = true;\n      })\n    );\n  });\n}\n","import { map } from './map';\nimport { OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  k1: K1,\n  k2: K2,\n  k3: K3\n): OperatorFunction<T, T[K1][K2][K3]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(\n  k1: K1,\n  k2: K2,\n  k3: K3,\n  k4: K4\n): OperatorFunction<T, T[K1][K2][K3][K4]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6, ...rest: string[]): OperatorFunction<T, unknown>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T>(...properties: string[]): OperatorFunction<T, unknown>;\n/* tslint:enable:max-line-length */\n\n/**\n * Maps each source value to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted value.</span>\n *\n * ![](pluck.png)\n *\n * Given a list of strings or numbers describing a path to a property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * ## Example\n *\n * Map every click to the tagName of the clicked target element\n *\n * ```ts\n * import { fromEvent, pluck } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\n *\n * tagNames.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param properties The nested properties to pluck from each source\n * value.\n * @return A function that returns an Observable of property values from the\n * source values.\n * @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8.\n */\nexport function pluck<T, R>(...properties: Array<string | number | symbol>): OperatorFunction<T, R> {\n  const length = properties.length;\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n  return map((x) => {\n    let currentProp: any = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp?.[properties[i]];\n      if (typeof p !== 'undefined') {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { connect } from './connect';\n\n/**\n * Returns a connectable observable that, when connected, will multicast\n * all values through a single underlying {@link Subject} instance.\n *\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * `source.pipe(publish())` is equivalent to\n * `connectable(source, { connector: () => new Subject(), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publish`, use {@link share} operator instead.\n * `source.pipe(publish(), refCount())` is equivalent to\n * `source.pipe(share({ resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Returns an observable, that when subscribed to, creates an underlying {@link Subject},\n * provides an observable view of it to a `selector` function, takes the observable result of\n * that selector function and subscribes to it, sending its values to the consumer, _then_ connects\n * the subject to the original source.\n *\n * @param selector A function used to setup multicasting prior to automatic connection.\n *\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `publish(selector)` is equivalent to `connect(selector)`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T, O extends ObservableInput<any>>(selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <span class=\"informal\">Makes a cold Observable hot</span>\n *\n * ![](publish.png)\n *\n * ## Examples\n *\n * Make `source$` hot by applying `publish` operator, then merge each inner observable into a single one\n * and subscribe\n *\n * ```ts\n * import { zip, interval, of, map, publish, merge, tap } from 'rxjs';\n *\n * const source$ = zip(interval(2000), of(1, 2, 3, 4, 5, 6, 7, 8, 9))\n *   .pipe(map(([, number]) => number));\n *\n * source$\n *   .pipe(\n *     publish(multicasted$ =>\n *       merge(\n *         multicasted$.pipe(tap(x => console.log('Stream 1:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 2:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 3:', x)))\n *       )\n *     )\n *   )\n *   .subscribe();\n *\n * // Results every two seconds\n * // Stream 1: 1\n * // Stream 2: 1\n * // Stream 3: 1\n * // ...\n * // Stream 1: 9\n * // Stream 2: 9\n * // Stream 3: 9\n * ```\n *\n * @see {@link publishLast}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @param selector Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A function that returns a ConnectableObservable that upon connection\n * causes the source Observable to emit items to its Observers.\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T, R>(selector?: OperatorFunction<T, R>): MonoTypeOperatorFunction<T> | OperatorFunction<T, R> {\n  return selector ? (source) => connect(selector)(source) : (source) => multicast(new Subject<T>())(source);\n}\n","import { Observable } from '../Observable';\nimport { BehaviorSubject } from '../BehaviorSubject';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Creates a {@link ConnectableObservable} that utilizes a {@link BehaviorSubject}.\n *\n * @param initialValue The initial value passed to the {@link BehaviorSubject}.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link BehaviorSubject} under the hood, use {@link connectable}.\n * `source.pipe(publishBehavior(initValue))` is equivalent to\n * `connectable(source, { connector: () => new BehaviorSubject(initValue), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishBehavior`, use the {@link share} operator instead.\n * `source.pipe(publishBehavior(initValue), refCount())` is equivalent to\n * `source.pipe(share({ connector: () => new BehaviorSubject(initValue), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false  }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishBehavior<T>(initialValue: T): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  // Note that this has *never* supported the selector function.\n  return (source) => {\n    const subject = new BehaviorSubject<T>(initialValue);\n    return new ConnectableObservable(source, () => subject);\n  };\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Returns a connectable observable sequence that shares a single subscription to the\n * underlying sequence containing only the last notification.\n *\n * ![](publishLast.png)\n *\n * Similar to {@link publish}, but it waits until the source observable completes and stores\n * the last emitted value.\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\n * immediately get that last stored value and complete.\n *\n * ## Example\n *\n * ```ts\n * import { ConnectableObservable, interval, publishLast, tap, take } from 'rxjs';\n *\n * const connectable = <ConnectableObservable<number>>interval(1000)\n *   .pipe(\n *     tap(x => console.log('side effect', x)),\n *     take(3),\n *     publishLast()\n *   );\n *\n * connectable.subscribe({\n *   next: x => console.log('Sub. A', x),\n *   error: err => console.log('Sub. A Error', err),\n *   complete: () => console.log('Sub. A Complete')\n * });\n *\n * connectable.subscribe({\n *   next: x => console.log('Sub. B', x),\n *   error: err => console.log('Sub. B Error', err),\n *   complete: () => console.log('Sub. B Complete')\n * });\n *\n * connectable.connect();\n *\n * // Results:\n * // 'side effect 0'   - after one second\n * // 'side effect 1'   - after two seconds\n * // 'side effect 2'   - after three seconds\n * // 'Sub. A 2'        - immediately after 'side effect 2'\n * // 'Sub. B 2'\n * // 'Sub. A Complete'\n * // 'Sub. B Complete'\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link publish}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @return A function that returns an Observable that emits elements of a\n * sequence produced by multicasting the source sequence.\n * @deprecated Will be removed in v8. To create a connectable observable with an\n * {@link AsyncSubject} under the hood, use {@link connectable}.\n * `source.pipe(publishLast())` is equivalent to\n * `connectable(source, { connector: () => new AsyncSubject(), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishLast`, use the {@link share} operator instead.\n * `source.pipe(publishLast(), refCount())` is equivalent to\n * `source.pipe(share({ connector: () => new AsyncSubject(), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  // Note that this has *never* supported a selector function like `publish` and `publishReplay`.\n  return (source) => {\n    const subject = new AsyncSubject<T>();\n    return new ConnectableObservable(source, () => subject);\n  };\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { MonoTypeOperatorFunction, OperatorFunction, TimestampProvider, ObservableInput, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\n * internally.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link ReplaySubject} under the hood, use {@link connectable}.\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T>(\n  bufferSize?: number,\n  windowTime?: number,\n  timestampProvider?: TimestampProvider\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Creates an observable, that when subscribed to, will create a {@link ReplaySubject},\n * and pass an observable from it (using [asObservable](api/index/class/Subject#asObservable)) to\n * the `selector` function, which then returns an observable that is subscribed to before\n * \"connecting\" the source to the internal `ReplaySubject`.\n *\n * Since this is deprecated, for additional details see the documentation for {@link connect}.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param selector A function used to setup the multicast.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `source.pipe(publishReplay(size, window, selector, scheduler))` is equivalent to\n * `source.pipe(connect(selector, { connector: () => new ReplaySubject(size, window, scheduler) }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, O extends ObservableInput<any>>(\n  bufferSize: number | undefined,\n  windowTime: number | undefined,\n  selector: (shared: Observable<T>) => O,\n  timestampProvider?: TimestampProvider\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\n * internally.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param selector Passing `undefined` here determines that this operator will return a {@link ConnectableObservable}.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link ReplaySubject} under the hood, use {@link connectable}.\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, O extends ObservableInput<any>>(\n  bufferSize: number | undefined,\n  windowTime: number | undefined,\n  selector: undefined,\n  timestampProvider: TimestampProvider\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, R>(\n  bufferSize?: number,\n  windowTime?: number,\n  selectorOrScheduler?: TimestampProvider | OperatorFunction<T, R>,\n  timestampProvider?: TimestampProvider\n) {\n  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {\n    timestampProvider = selectorOrScheduler;\n  }\n  const selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;\n  // Note, we're passing `selector!` here, because at runtime, `undefined` is an acceptable argument\n  // but it makes our TypeScript signature for `multicast` unhappy (as it should, because it's gross).\n  return (source: Observable<T>) => multicast(new ReplaySubject<T>(bufferSize, windowTime, timestampProvider), selector!)(source);\n}\n","import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { raceInit } from '../observable/race';\nimport { operate } from '../util/lift';\nimport { identity } from '../util/identity';\n\n/**\n * Creates an Observable that mirrors the first source Observable to emit a next,\n * error or complete notification from the combination of the Observable to which\n * the operator is applied and supplied Observables.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, raceWith } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * obs1\n *   .pipe(raceWith(obs2, obs3))\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param otherSources Sources used to race for which Observable emits first.\n * @return A function that returns an Observable that mirrors the output of the\n * first Observable to emit an item.\n */\nexport function raceWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return !otherSources.length\n    ? identity\n    : operate((source, subscriber) => {\n        raceInit<T | A[number]>([source, ...otherSources])(subscriber);\n      });\n}\n","import { Subscription } from '../Subscription';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { timer } from '../observable/timer';\n\nexport interface RepeatConfig {\n  /**\n   * The number of times to repeat the source. Defaults to `Infinity`.\n   */\n  count?: number;\n\n  /**\n   * If a `number`, will delay the repeat of the source by that number of milliseconds.\n   * If a function, it will provide the number of times the source has been subscribed to,\n   * and the return value should be a valid observable input that will notify when the source\n   * should be repeated. If the notifier observable is empty, the result will complete.\n   */\n  delay?: number | ((count: number) => ObservableInput<any>);\n}\n\n/**\n * Returns an Observable that will resubscribe to the source stream when the source stream completes.\n *\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\n *\n * ![](repeat.png)\n *\n * Repeat will output values from a source until the source completes, then it will resubscribe to the\n * source a specified number of times, with a specified delay. Repeat can be particularly useful in\n * combination with closing operators like {@link take}, {@link takeUntil}, {@link first}, or {@link takeWhile},\n * as it can be used to restart a source again from scratch.\n *\n * Repeat is very similar to {@link retry}, where {@link retry} will resubscribe to the source in the error case, but\n * `repeat` will resubscribe if the source completes.\n *\n * Note that `repeat` will _not_ catch errors. Use {@link retry} for that.\n *\n * - `repeat(0)` returns an empty observable\n * - `repeat()` will repeat forever\n * - `repeat({ delay: 200 })` will repeat forever, with a delay of 200ms between repetitions.\n * - `repeat({ count: 2, delay: 400 })` will repeat twice, with a delay of 400ms between repetitions.\n * - `repeat({ delay: (count) => timer(count * 1000) })` will repeat forever, but will have a delay that grows by one second for each repetition.\n *\n * ## Example\n *\n * Repeat a message stream\n *\n * ```ts\n * import { of, repeat } from 'rxjs';\n *\n * const source = of('Repeat message');\n * const result = source.pipe(repeat(3));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results\n * // 'Repeat message'\n * // 'Repeat message'\n * // 'Repeat message'\n * ```\n *\n * Repeat 3 values, 2 times\n *\n * ```ts\n * import { interval, take, repeat } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(take(3), repeat(2));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results every second\n * // 0\n * // 1\n * // 2\n * // 0\n * // 1\n * // 2\n * ```\n *\n * Defining two complex repeats with delays on the same source.\n * Note that the second repeat cannot be called until the first\n * repeat as exhausted it's count.\n *\n * ```ts\n * import { defer, of, repeat } from 'rxjs';\n *\n * const source = defer(() => {\n *    return of(`Hello, it is ${new Date()}`)\n * });\n *\n * source.pipe(\n *    // Repeat 3 times with a delay of 1 second between repetitions\n *    repeat({\n *      count: 3,\n *      delay: 1000,\n *    }),\n *\n *    // *Then* repeat forever, but with an exponential step-back\n *    // maxing out at 1 minute.\n *    repeat({\n *      delay: (count) => timer(Math.min(60000, 2 ^ count * 1000))\n *    })\n * )\n * ```\n *\n * @see {@link repeatWhen}\n * @see {@link retry}\n *\n * @param countOrConfig Either the number of times the source Observable items are repeated\n * (a count of 0 will yield an empty Observable) or a {@link RepeatConfig} object.\n */\nexport function repeat<T>(countOrConfig?: number | RepeatConfig): MonoTypeOperatorFunction<T> {\n  let count = Infinity;\n  let delay: RepeatConfig['delay'];\n\n  if (countOrConfig != null) {\n    if (typeof countOrConfig === 'object') {\n      ({ count = Infinity, delay } = countOrConfig);\n    } else {\n      count = countOrConfig;\n    }\n  }\n\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let sourceSub: Subscription | null;\n\n        const resubscribe = () => {\n          sourceSub?.unsubscribe();\n          sourceSub = null;\n          if (delay != null) {\n            const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(soFar));\n            const notifierSubscriber = createOperatorSubscriber(subscriber, () => {\n              notifierSubscriber.unsubscribe();\n              subscribeToSource();\n            });\n            notifier.subscribe(notifierSubscriber);\n          } else {\n            subscribeToSource();\n          }\n        };\n\n        const subscribeToSource = () => {\n          let syncUnsub = false;\n          sourceSub = source.subscribe(\n            createOperatorSubscriber(subscriber, undefined, () => {\n              if (++soFar < count) {\n                if (sourceSub) {\n                  resubscribe();\n                } else {\n                  syncUnsub = true;\n                }\n              } else {\n                subscriber.complete();\n              }\n            })\n          );\n\n          if (syncUnsub) {\n            resubscribe();\n          }\n        };\n\n        subscribeToSource();\n      });\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * ![](repeatWhen.png)\n *\n * ## Example\n *\n * Repeat a message stream on click\n *\n * ```ts\n * import { of, fromEvent, repeatWhen } from 'rxjs';\n *\n * const source = of('Repeat message');\n * const documentClick$ = fromEvent(document, 'click');\n *\n * const result = source.pipe(repeatWhen(() => documentClick$));\n *\n * result.subscribe(data => console.log(data))\n * ```\n *\n * @see {@link repeat}\n * @see {@link retry}\n * @see {@link retryWhen}\n *\n * @param notifier Function that receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return A function that returns an Observable that mirrors the source\n * Observable with the exception of a `complete`.\n * @deprecated Will be removed in v9 or v10. Use {@link repeat}'s {@link RepeatConfig#delay delay} option instead.\n * Instead of `repeatWhen(() => notify$)`, use: `repeat({ delay: () => notify$ })`.\n */\nexport function repeatWhen<T>(notifier: (notifications: Observable<void>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null;\n    let syncResub = false;\n    let completions$: Subject<void>;\n    let isNotifierComplete = false;\n    let isMainComplete = false;\n\n    /**\n     * Checks to see if we can complete the result, completes it, and returns `true` if it was completed.\n     */\n    const checkComplete = () => isMainComplete && isNotifierComplete && (subscriber.complete(), true);\n    /**\n     * Gets the subject to send errors through. If it doesn't exist,\n     * we know we need to setup the notifier.\n     */\n    const getCompletionSubject = () => {\n      if (!completions$) {\n        completions$ = new Subject();\n\n        // If the call to `notifier` throws, it will be caught by the OperatorSubscriber\n        // In the main subscription -- in `subscribeForRepeatWhen`.\n        innerFrom(notifier(completions$)).subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            () => {\n              if (innerSub) {\n                subscribeForRepeatWhen();\n              } else {\n                // If we don't have an innerSub yet, that's because the inner subscription\n                // call hasn't even returned yet. We've arrived here synchronously.\n                // So we flag that we want to resub, such that we can ensure finalization\n                // happens before we resubscribe.\n                syncResub = true;\n              }\n            },\n            () => {\n              isNotifierComplete = true;\n              checkComplete();\n            }\n          )\n        );\n      }\n      return completions$;\n    };\n\n    const subscribeForRepeatWhen = () => {\n      isMainComplete = false;\n\n      innerSub = source.subscribe(\n        createOperatorSubscriber(subscriber, undefined, () => {\n          isMainComplete = true;\n          // Check to see if we are complete, and complete if so.\n          // If we are not complete. Get the subject. This calls the `notifier` function.\n          // If that function fails, it will throw and `.next()` will not be reached on this\n          // line. The thrown error is caught by the _complete handler in this\n          // `OperatorSubscriber` and handled appropriately.\n          !checkComplete() && getCompletionSubject().next();\n        })\n      );\n\n      if (syncResub) {\n        // Ensure that the inner subscription is torn down before\n        // moving on to the next subscription in the synchronous case.\n        // If we don't do this here, all inner subscriptions will not be\n        // torn down until the entire observable is done.\n        innerSub.unsubscribe();\n        // It is important to null this out. Not only to free up memory, but\n        // to make sure code above knows we are in a subscribing state to\n        // handle synchronous resubscription.\n        innerSub = null;\n        // We may need to do this multiple times, so reset the flags.\n        syncResub = false;\n        // Resubscribe\n        subscribeForRepeatWhen();\n      }\n    };\n\n    // Start the subscription\n    subscribeForRepeatWhen();\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { Subscription } from '../Subscription';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nimport { timer } from '../observable/timer';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * The {@link retry} operator configuration object. `retry` either accepts a `number`\n * or an object described by this interface.\n */\nexport interface RetryConfig {\n  /**\n   * The maximum number of times to retry. If `count` is omitted, `retry` will try to\n   * resubscribe on errors infinite number of times.\n   */\n  count?: number;\n  /**\n   * The number of milliseconds to delay before retrying, OR a function to\n   * return a notifier for delaying. If a function is given, that function should\n   * return a notifier that, when it emits will retry the source. If the notifier\n   * completes _without_ emitting, the resulting observable will complete without error,\n   * if the notifier errors, the error will be pushed to the result.\n   */\n  delay?: number | ((error: any, retryCount: number) => ObservableInput<any>);\n  /**\n   * Whether or not to reset the retry counter when the retried subscription\n   * emits its first value.\n   */\n  resetOnSuccess?: boolean;\n}\n\nexport function retry<T>(count?: number): MonoTypeOperatorFunction<T>;\nexport function retry<T>(config: RetryConfig): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`.\n *\n * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of\n * `count` resubscriptions rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * The number of retries is determined by the `count` parameter. It can be set either by passing a number to\n * `retry` function or by setting `count` property when `retry` is configured using {@link RetryConfig}. If\n * `count` is omitted, `retry` will try to resubscribe on errors infinite number of times.\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those\n * emitted during failed subscriptions. For example, if an Observable fails at first but emits `[1, 2]` then\n * succeeds the second time and emits: `[1, 2, 3, 4, 5, complete]` then the complete stream of emissions and\n * notifications would be: `[1, 2, 1, 2, 3, 4, 5, complete]`.\n *\n * ## Example\n *\n * ```ts\n * import { interval, mergeMap, throwError, of, retry } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(\n *   mergeMap(val => val > 5 ? throwError(() => 'Error!') : of(val)),\n *   retry(2) // retry 2 times on error\n * );\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(`${ err }: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 'Error!: Retried 2 times then quit!'\n * ```\n *\n * @see {@link retryWhen}\n *\n * @param configOrCount Either number of retry attempts before failing or a\n * {@link RetryConfig} object.\n * @return A function that returns an Observable that will resubscribe to the\n * source stream when the source stream errors, at most `count` times.\n */\nexport function retry<T>(configOrCount: number | RetryConfig = Infinity): MonoTypeOperatorFunction<T> {\n  let config: RetryConfig;\n  if (configOrCount && typeof configOrCount === 'object') {\n    config = configOrCount;\n  } else {\n    config = {\n      count: configOrCount as number,\n    };\n  }\n  const { count = Infinity, delay, resetOnSuccess: resetOnSuccess = false } = config;\n\n  return count <= 0\n    ? identity\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let innerSub: Subscription | null;\n        const subscribeForRetry = () => {\n          let syncUnsub = false;\n          innerSub = source.subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              (value) => {\n                // If we're resetting on success\n                if (resetOnSuccess) {\n                  soFar = 0;\n                }\n                subscriber.next(value);\n              },\n              // Completions are passed through to consumer.\n              undefined,\n              (err) => {\n                if (soFar++ < count) {\n                  // We are still under our retry count\n                  const resub = () => {\n                    if (innerSub) {\n                      innerSub.unsubscribe();\n                      innerSub = null;\n                      subscribeForRetry();\n                    } else {\n                      syncUnsub = true;\n                    }\n                  };\n\n                  if (delay != null) {\n                    // The user specified a retry delay.\n                    // They gave us a number, use a timer, otherwise, it's a function,\n                    // and we're going to call it to get a notifier.\n                    const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));\n                    const notifierSubscriber = createOperatorSubscriber(\n                      subscriber,\n                      () => {\n                        // After we get the first notification, we\n                        // unsubscribe from the notifier, because we don't want anymore\n                        // and we resubscribe to the source.\n                        notifierSubscriber.unsubscribe();\n                        resub();\n                      },\n                      () => {\n                        // The notifier completed without emitting.\n                        // The author is telling us they want to complete.\n                        subscriber.complete();\n                      }\n                    );\n                    notifier.subscribe(notifierSubscriber);\n                  } else {\n                    // There was no notifier given. Just resub immediately.\n                    resub();\n                  }\n                } else {\n                  // We're past our maximum number of retries.\n                  // Just send along the error.\n                  subscriber.error(err);\n                }\n              }\n            )\n          );\n          if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            subscribeForRetry();\n          }\n        };\n        subscribeForRetry();\n      });\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the `ObservableInput` returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * ![](retryWhen.png)\n *\n * Retry an observable sequence on error based on custom criteria.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, retryWhen, tap, delayWhen, timer } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(\n *   map(value => {\n *     if (value > 5) {\n *       // error will be picked up by retryWhen\n *       throw value;\n *     }\n *     return value;\n *   }),\n *   retryWhen(errors =>\n *     errors.pipe(\n *       // log error message\n *       tap(value => console.log(`Value ${ value } was too high!`)),\n *       // restart in 5 seconds\n *       delayWhen(value => timer(value * 1000))\n *     )\n *   )\n * );\n *\n * result.subscribe(value => console.log(value));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 'Value 6 was too high!'\n * // - Wait 5 seconds then repeat\n * ```\n *\n * @see {@link retry}\n *\n * @param notifier Function that receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return A function that returns an Observable that mirrors the source\n * Observable with the exception of an `error`.\n * @deprecated Will be removed in v9 or v10, use {@link retry}'s `delay` option instead.\n * Will be removed in v9 or v10. Use {@link retry}'s {@link RetryConfig#delay delay} option instead.\n * Instead of `retryWhen(() => notify$)`, use: `retry({ delay: () => notify$ })`.\n */\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null;\n    let syncResub = false;\n    let errors$: Subject<any>;\n\n    const subscribeForRetryWhen = () => {\n      innerSub = source.subscribe(\n        createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n          if (!errors$) {\n            errors$ = new Subject();\n            innerFrom(notifier(errors$)).subscribe(\n              createOperatorSubscriber(subscriber, () =>\n                // If we have an innerSub, this was an asynchronous call, kick off the retry.\n                // Otherwise, if we don't have an innerSub yet, that's because the inner subscription\n                // call hasn't even returned yet. We've arrived here synchronously.\n                // So we flag that we want to resub, such that we can ensure finalization\n                // happens before we resubscribe.\n                innerSub ? subscribeForRetryWhen() : (syncResub = true)\n              )\n            );\n          }\n          if (errors$) {\n            // We have set up the notifier without error.\n            errors$.next(err);\n          }\n        })\n      );\n\n      if (syncResub) {\n        // Ensure that the inner subscription is torn down before\n        // moving on to the next subscription in the synchronous case.\n        // If we don't do this here, all inner subscriptions will not be\n        // torn down until the entire observable is done.\n        innerSub.unsubscribe();\n        innerSub = null;\n        // We may need to do this multiple times, so reset the flag.\n        syncResub = false;\n        // Resubscribe\n        subscribeForRetryWhen();\n      }\n    };\n\n    // Start the subscription\n    subscribeForRetryWhen();\n  });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` `ObservableInput` emits something.</span>\n *\n * ![](sample.png)\n *\n * Whenever the `notifier` `ObservableInput` emits a value, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n *\n * On every click, sample the most recent `seconds` timer\n *\n * ```ts\n * import { fromEvent, interval, sample } from 'rxjs';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param notifier The `ObservableInput` to use for sampling the\n * source Observable.\n * @return A function that returns an Observable that emits the results of\n * sampling the values emitted by the source Observable whenever the notifier\n * Observable emits value or completes.\n */\nexport function sample<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        hasValue = true;\n        lastValue = value;\n      })\n    );\n    innerFrom(notifier).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          if (hasValue) {\n            hasValue = false;\n            const value = lastValue!;\n            lastValue = null;\n            subscriber.next(value);\n          }\n        },\n        noop\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { sample } from './sample';\nimport { interval } from '../observable/interval';\n\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * ![](sampleTime.png)\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n *\n * Every second, emit the most recent click at most once\n *\n * ```ts\n * import { fromEvent, sampleTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param period The sampling period expressed in milliseconds or the time unit\n * determined internally by the optional `scheduler`.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\n * that handle the sampling.\n * @return A function that returns an Observable that emits the results of\n * sampling the values emitted by the source Observable at the specified time\n * interval.\n */\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return sample(interval(period, scheduler));\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { scanInternals } from './scanInternals';\n\nexport function scan<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\nexport function scan<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\nexport function scan<V, A, S>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\n\n// TODO: link to a \"redux pattern\" section in the guide (location TBD)\n\n/**\n * Useful for encapsulating and managing state. Applies an accumulator (or \"reducer function\")\n * to each value from the source after an initial state is established -- either via\n * a `seed` value (second argument), or from the first value from the source.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation state after each update</span>\n *\n * ![](scan.png)\n *\n * This operator maintains an internal state and emits it after processing each value as follows:\n *\n * 1. First value arrives\n *   - If a `seed` value was supplied (as the second argument to `scan`), let `state = seed` and `value = firstValue`.\n *   - If NO `seed` value was supplied (no second argument), let `state = firstValue` and go to 3.\n * 2. Let `state = accumulator(state, value)`.\n *   - If an error is thrown by `accumulator`, notify the consumer of an error. The process ends.\n * 3. Emit `state`.\n * 4. Next value arrives, let `value = nextValue`, go to 2.\n *\n * ## Examples\n *\n * An average of previous numbers. This example shows how\n * not providing a `seed` can prime the stream with the\n * first value from the source.\n *\n * ```ts\n * import { of, scan, map } from 'rxjs';\n *\n * const numbers$ = of(1, 2, 3);\n *\n * numbers$\n *   .pipe(\n *     // Get the sum of the numbers coming in.\n *     scan((total, n) => total + n),\n *     // Get the average by dividing the sum by the total number\n *     // received so far (which is 1 more than the zero-based index).\n *     map((sum, index) => sum / (index + 1))\n *   )\n *   .subscribe(console.log);\n * ```\n *\n * The Fibonacci sequence. This example shows how you can use\n * a seed to prime accumulation process. Also... you know... Fibonacci.\n * So important to like, computers and stuff that its whiteboarded\n * in job interviews. Now you can show them the Rx version! (Please don't, haha)\n *\n * ```ts\n * import { interval, scan, map, startWith } from 'rxjs';\n *\n * const firstTwoFibs = [0, 1];\n * // An endless stream of Fibonacci numbers.\n * const fibonacci$ = interval(1000).pipe(\n *   // Scan to get the fibonacci numbers (after 0, 1)\n *   scan(([a, b]) => [b, a + b], firstTwoFibs),\n *   // Get the second number in the tuple, it's the one you calculated\n *   map(([, n]) => n),\n *   // Start with our first two digits :)\n *   startWith(...firstTwoFibs)\n * );\n *\n * fibonacci$.subscribe(console.log);\n * ```\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n * @see {@link switchScan}\n *\n * @param accumulator A \"reducer function\". This will be called for each value after an initial state is\n * acquired.\n * @param seed The initial state. If this is not provided, the first value from the source will\n * be used as the initial state, and emitted without going through the accumulator. All subsequent values\n * will be processed by the accumulator function. If this is provided, all values will go through\n * the accumulator function.\n * @return A function that returns an Observable of the accumulated values.\n */\nexport function scan<V, A, S>(accumulator: (acc: V | A | S, value: V, index: number) => A, seed?: S): OperatorFunction<V, V | A> {\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  return operate(scanInternals(accumulator, seed as S, arguments.length >= 2, true));\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Compares all values of two observables in sequence using an optional comparator function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * ![](sequenceEqual.png)\n *\n * `sequenceEqual` subscribes to source observable and `compareTo` `ObservableInput` (that internally\n * gets converted to an observable) and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other completes, the returned observable will never complete.\n *\n * ## Example\n *\n * Figure out if the Konami code matches\n *\n * ```ts\n * import { from, fromEvent, map, bufferCount, mergeMap, sequenceEqual } from 'rxjs';\n *\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent<KeyboardEvent>(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(last11 => from(last11).pipe(sequenceEqual(codes)))\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param compareTo The `ObservableInput` sequence to compare the source sequence to.\n * @param comparator An optional function to compare each value pair.\n *\n * @return A function that returns an Observable that emits a single boolean\n * value representing whether or not the values emitted by the source\n * Observable and provided `ObservableInput` were equal in sequence.\n */\nexport function sequenceEqual<T>(\n  compareTo: ObservableInput<T>,\n  comparator: (a: T, b: T) => boolean = (a, b) => a === b\n): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    // The state for the source observable\n    const aState = createState<T>();\n    // The state for the compareTo observable;\n    const bState = createState<T>();\n\n    /** A utility to emit and complete */\n    const emit = (isEqual: boolean) => {\n      subscriber.next(isEqual);\n      subscriber.complete();\n    };\n\n    /**\n     * Creates a subscriber that subscribes to one of the sources, and compares its collected\n     * state -- `selfState` -- to the other source's collected state -- `otherState`. This\n     * is used for both streams.\n     */\n    const createSubscriber = (selfState: SequenceState<T>, otherState: SequenceState<T>) => {\n      const sequenceEqualSubscriber = createOperatorSubscriber(\n        subscriber,\n        (a: T) => {\n          const { buffer, complete } = otherState;\n          if (buffer.length === 0) {\n            // If there's no values in the other buffer\n            // and the other stream is complete, we know\n            // this isn't a match, because we got one more value.\n            // Otherwise, we push onto our buffer, so when the other\n            // stream emits, it can pull this value off our buffer and check it\n            // at the appropriate time.\n            complete ? emit(false) : selfState.buffer.push(a);\n          } else {\n            // If the other stream *does* have values in its buffer,\n            // pull the oldest one off so we can compare it to what we\n            // just got. If it wasn't a match, emit `false` and complete.\n            !comparator(a, buffer.shift()!) && emit(false);\n          }\n        },\n        () => {\n          // Or observable completed\n          selfState.complete = true;\n          const { complete, buffer } = otherState;\n          // If the other observable is also complete, and there's\n          // still stuff left in their buffer, it doesn't match, if their\n          // buffer is empty, then it does match. This is because we can't\n          // possibly get more values here anymore.\n          complete && emit(buffer.length === 0);\n          // Be sure to clean up our stream as soon as possible if we can.\n          sequenceEqualSubscriber?.unsubscribe();\n        }\n      );\n\n      return sequenceEqualSubscriber;\n    };\n\n    // Subscribe to each source.\n    source.subscribe(createSubscriber(aState, bState));\n    innerFrom(compareTo).subscribe(createSubscriber(bState, aState));\n  });\n}\n\n/**\n * A simple structure for the data used to test each sequence\n */\ninterface SequenceState<T> {\n  /** A temporary store for arrived values before they are checked */\n  buffer: T[];\n  /** Whether or not the sequence source has completed. */\n  complete: boolean;\n}\n\n/**\n * Creates a simple structure that is used to represent\n * data used to test each sequence.\n */\nfunction createState<T>(): SequenceState<T> {\n  return {\n    buffer: [],\n    complete: false,\n  };\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubjectLike, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\n\nexport interface ShareConfig<T> {\n  /**\n   * The factory used to create the subject that will connect the source observable to\n   * multicast consumers.\n   */\n  connector?: () => SubjectLike<T>;\n  /**\n   * If `true`, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"retried\" in the event of an error.\n   * If `false`, when an error comes from the source it will push the error into the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnError?: boolean | ((error: any) => ObservableInput<any>);\n  /**\n   * If `true`, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"repeated\" after it is done.\n   * If `false`, when the source completes, it will push the completion through the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\n   * or resubscriptions will resubscribe to that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnComplete?: boolean | (() => ObservableInput<any>);\n  /**\n   * If `true`, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\n   * again.\n   * If `false`, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnRefCountZero?: boolean | (() => ObservableInput<any>);\n}\n\nexport function share<T>(): MonoTypeOperatorFunction<T>;\n\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\n *\n * ![](share.png)\n *\n * ## Example\n *\n * Generate new multicast Observable from the `source` Observable value\n *\n * ```ts\n * import { interval, tap, map, take, share } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   tap(x => console.log('Processing: ', x)),\n *   map(x => x * x),\n *   take(6),\n *   share()\n * );\n *\n * source.subscribe(x => console.log('subscription 1: ', x));\n * source.subscribe(x => console.log('subscription 2: ', x));\n *\n * // Logs:\n * // Processing: 0\n * // subscription 1: 0\n * // subscription 2: 0\n * // Processing: 1\n * // subscription 1: 1\n * // subscription 2: 1\n * // Processing: 2\n * // subscription 1: 4\n * // subscription 2: 4\n * // Processing: 3\n * // subscription 1: 9\n * // subscription 2: 9\n * // Processing: 4\n * // subscription 1: 16\n * // subscription 2: 16\n * // Processing: 5\n * // subscription 1: 25\n * // subscription 2: 25\n * ```\n *\n * ## Example with notifier factory: Delayed reset\n *\n * ```ts\n * import { interval, take, share, timer } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   take(3),\n *   share({\n *     resetOnRefCountZero: () => timer(1000)\n *   })\n * );\n *\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\n *\n * // Logs:\n * // subscription 1:  0\n * // (subscription 1 unsubscribes here)\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\n * // subscription 2:  1\n * // subscription 2:  2\n * // (subscription 2 unsubscribes here)\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\n * // subscription 3:  0\n * // subscription 3:  1\n * // subscription 3:  2\n * ```\n *\n * @see {@link shareReplay}\n *\n * @return A function that returns an Observable that mirrors the source.\n */\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n  // It's necessary to use a wrapper here, as the _operator_ must be\n  // referentially transparent. Otherwise, it cannot be used in calls to the\n  // static `pipe` function - to create a partial pipeline.\n  //\n  // The _operator function_ - the function returned by the _operator_ - will\n  // not be referentially transparent - as it shares its source - but the\n  // _operator function_ is called when the complete pipeline is composed via a\n  // call to a source observable's `pipe` method - not when the static `pipe`\n  // function is called.\n  return (wrapperSource) => {\n    let connection: SafeSubscriber<T> | undefined;\n    let resetConnection: Subscription | undefined;\n    let subject: SubjectLike<T> | undefined;\n    let refCount = 0;\n    let hasCompleted = false;\n    let hasErrored = false;\n\n    const cancelReset = () => {\n      resetConnection?.unsubscribe();\n      resetConnection = undefined;\n    };\n    // Used to reset the internal state to a \"cold\"\n    // state, as though it had never been subscribed to.\n    const reset = () => {\n      cancelReset();\n      connection = subject = undefined;\n      hasCompleted = hasErrored = false;\n    };\n    const resetAndUnsubscribe = () => {\n      // We need to capture the connection before\n      // we reset (if we need to reset).\n      const conn = connection;\n      reset();\n      conn?.unsubscribe();\n    };\n\n    return operate<T, T>((source, subscriber) => {\n      refCount++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n\n      // Create the subject if we don't have one yet. Grab a local reference to\n      // it as well, which avoids non-null assertions when using it and, if we\n      // connect to it now, then error/complete need a reference after it was\n      // reset.\n      const dest = (subject = subject ?? connector());\n\n      // Add the finalization directly to the subscriber - instead of returning it -\n      // so that the handling of the subscriber's unsubscription will be wired\n      // up _before_ the subscription to the source occurs. This is done so that\n      // the assignment to the source connection's `closed` property will be seen\n      // by synchronous firehose sources.\n      subscriber.add(() => {\n        refCount--;\n\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\n        // configuration.\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n\n      // The following line adds the subscription to the subscriber passed.\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\n      dest.subscribe(subscriber);\n\n      if (\n        !connection &&\n        // Check this shareReplay is still activate - it can be reset to 0\n        // and be \"unsubscribed\" _before_ it actually subscribes.\n        // If we were to subscribe then, it'd leak and get stuck.\n        refCount > 0\n      ) {\n        // We need to create a subscriber here - rather than pass an observer and\n        // assign the returned subscription to connection - because it's possible\n        // for reentrant subscriptions to the shared observable to occur and in\n        // those situations we want connection to be already-assigned so that we\n        // don't create another connection to the source.\n        connection = new SafeSubscriber({\n          next: (value) => dest.next(value),\n          error: (err) => {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: () => {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          },\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\n\nfunction handleReset<T extends unknown[] = never[]>(\n  reset: () => void,\n  on: boolean | ((...args: T) => ObservableInput<any>),\n  ...args: T\n): Subscription | undefined {\n  if (on === true) {\n    reset();\n    return;\n  }\n\n  if (on === false) {\n    return;\n  }\n\n  const onSubscriber = new SafeSubscriber({\n    next: () => {\n      onSubscriber.unsubscribe();\n      reset();\n    },\n  });\n\n  return innerFrom(on(...args)).subscribe(onSubscriber);\n}\n","import { ReplaySubject } from '../ReplaySubject';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { share } from './share';\n\nexport interface ShareReplayConfig {\n  bufferSize?: number;\n  windowTime?: number;\n  refCount: boolean;\n  scheduler?: SchedulerLike;\n}\n\nexport function shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplay`ed observable forever,\n * but an errored source can be retried.\n *\n * ## Why use `shareReplay`?\n *\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ## Reference counting\n *\n * By default `shareReplay` will use `refCount` of false, meaning that it will _not_ unsubscribe the\n * source when the reference counter drops to zero, i.e. the inner `ReplaySubject` will _not_ be unsubscribed\n * (and potentially run for ever).\n * This is the default as it is expected that `shareReplay` is often used to keep around expensive to setup\n * observables which we want to keep running instead of having to do the expensive setup again.\n *\n * As of RXJS version 6.4.0 a new overload signature was added to allow for manual control over what\n * happens when the operators internal reference counter drops to zero.\n * If `refCount` is true, the source will be unsubscribed from once the reference count drops to zero, i.e.\n * the inner `ReplaySubject` will be unsubscribed. All new subscribers will receive value emissions from a\n * new `ReplaySubject` which in turn will cause a new subscription to the source observable.\n *\n * ## Examples\n *\n * Example with a third subscriber coming late to the party\n *\n * ```ts\n * import { interval, take, shareReplay } from 'rxjs';\n *\n * const shared$ = interval(2000).pipe(\n *   take(6),\n *   shareReplay(3)\n * );\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * setTimeout(() => {\n *   shared$.subscribe(y => console.log('sub C: ', y));\n * }, 11000);\n *\n * // Logs:\n * // (after ~2000 ms)\n * // sub A: 0\n * // sub B: 0\n * // (after ~4000 ms)\n * // sub A: 1\n * // sub B: 1\n * // (after ~6000 ms)\n * // sub A: 2\n * // sub B: 2\n * // (after ~8000 ms)\n * // sub A: 3\n * // sub B: 3\n * // (after ~10000 ms)\n * // sub A: 4\n * // sub B: 4\n * // (after ~11000 ms, sub C gets the last 3 values)\n * // sub C: 2\n * // sub C: 3\n * // sub C: 4\n * // (after ~12000 ms)\n * // sub A: 5\n * // sub B: 5\n * // sub C: 5\n * ```\n *\n * Example for `refCount` usage\n *\n * ```ts\n * import { Observable, tap, interval, shareReplay, take } from 'rxjs';\n *\n * const log = <T>(name: string, source: Observable<T>) => source.pipe(\n *   tap({\n *     subscribe: () => console.log(`${ name }: subscribed`),\n *     next: value => console.log(`${ name }: ${ value }`),\n *     complete: () => console.log(`${ name }: completed`),\n *     finalize: () => console.log(`${ name }: unsubscribed`)\n *   })\n * );\n *\n * const obs$ = log('source', interval(1000));\n *\n * const shared$ = log('shared', obs$.pipe(\n *   shareReplay({ bufferSize: 1, refCount: true }),\n *   take(2)\n * ));\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * // PRINTS:\n * // shared: subscribed <-- reference count = 1\n * // source: subscribed\n * // shared: subscribed <-- reference count = 2\n * // source: 0\n * // shared: 0\n * // sub A: 0\n * // shared: 0\n * // sub B: 0\n * // source: 1\n * // shared: 1\n * // sub A: 1\n * // shared: completed <-- take(2) completes the subscription for sub A\n * // shared: unsubscribed <-- reference count = 1\n * // shared: 1\n * // sub B: 1\n * // shared: completed <-- take(2) completes the subscription for sub B\n * // shared: unsubscribed <-- reference count = 0\n * // source: unsubscribed <-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true\n *\n * // In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers\n * // are listening.\n * // source: 2\n * // source: 3\n * // source: 4\n * // ...\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param configOrBufferSize Maximum element count of the replay buffer or {@link ShareReplayConfig configuration}\n * object.\n * @param windowTime Maximum time length of the replay buffer in milliseconds.\n * @param scheduler Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return A function that returns an Observable sequence that contains the\n * elements of a sequence produced by multicasting the source sequence within a\n * selector function.\n */\nexport function shareReplay<T>(\n  configOrBufferSize?: ShareReplayConfig | number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T> {\n  let bufferSize: number;\n  let refCount = false;\n  if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n    ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);\n  } else {\n    bufferSize = (configOrBufferSize ?? Infinity) as number;\n  }\n  return share<T>({\n    connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),\n    resetOnError: true,\n    resetOnComplete: false,\n    resetOnRefCountZero: refCount,\n  });\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\n\nimport { MonoTypeOperatorFunction, OperatorFunction, TruthyTypesOf } from '../types';\nimport { SequenceError } from '../util/SequenceError';\nimport { NotFoundError } from '../util/NotFoundError';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function single<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that asserts that only one value is\n * emitted from the observable that matches the predicate. If no\n * predicate is provided, then it will assert that the observable\n * only emits one value.\n *\n * If the source Observable did not emit `next` before completion, it\n * will emit an {@link EmptyError} to the Observer's `error` callback.\n *\n * In the event that two values are found that match the predicate,\n * or when there are two values emitted and no predicate, it will\n * emit a {@link SequenceError} to the Observer's `error` callback.\n *\n * In the event that no values match the predicate, if one is provided,\n * it will emit a {@link NotFoundError} to the Observer's `error` callback.\n *\n * ## Example\n *\n * Expect only `name` beginning with `'B'`\n *\n * ```ts\n * import { of, single } from 'rxjs';\n *\n * const source1 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Laney' },\n *  { name: 'Lily' }\n * );\n *\n * source1\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe(x => console.log(x));\n * // Emits 'Ben'\n *\n *\n * const source2 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Bradley' },\n *  { name: 'Lincoln' }\n * );\n *\n * source2\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: SequenceError('Too many values match')\n *\n *\n * const source3 = of(\n *  { name: 'Laney' },\n *  { name: 'Tracy' },\n *  { name: 'Lily' },\n *  { name: 'Lincoln' }\n * );\n *\n * source3\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: NotFoundError('No values match')\n * ```\n *\n * @see {@link first}\n * @see {@link find}\n * @see {@link findIndex}\n * @see {@link elementAt}\n *\n * @throws {NotFoundError} Delivers a `NotFoundError` to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @throws {SequenceError} Delivers a `SequenceError` if more than one value is\n * emitted that matches the provided predicate. If no predicate is provided, it\n * will deliver a `SequenceError` if more than one value comes from the source.\n * @throws {EmptyError} Delivers an `EmptyError` if no values were `next`ed prior\n * to completion.\n *\n * @param predicate A predicate function to evaluate items emitted by the source\n * Observable.\n * @return A function that returns an Observable that emits the single item\n * emitted by the source Observable that matches the predicate.\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let singleValue: T;\n    let seenValue = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          seenValue = true;\n          if (!predicate || predicate(value, index++, source)) {\n            hasValue && subscriber.error(new SequenceError('Too many matching values'));\n            hasValue = true;\n            singleValue = value;\n          }\n        },\n        () => {\n          if (hasValue) {\n            subscriber.next(singleValue);\n            subscriber.complete();\n          } else {\n            subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());\n          }\n        }\n      )\n    );\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { filter } from './filter';\n\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * ![](skip.png)\n *\n * Skips the values until the sent notifications are equal or less than provided skip count. It raises\n * an error if skip count is equal or more than the actual number of emits and source raises an error.\n *\n * ## Example\n *\n * Skip the values before the emission\n *\n * ```ts\n * import { interval, skip } from 'rxjs';\n *\n * // emit every half second\n * const source = interval(500);\n * // skip the first 10 emitted values\n * const result = source.pipe(skip(10));\n *\n * result.subscribe(value => console.log(value));\n * // output: 10...11...12...13...\n * ```\n *\n * @see {@link last}\n * @see {@link skipWhile}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param count The number of times, items emitted by source Observable should be skipped.\n * @return A function that returns an Observable that skips the first `count`\n * values emitted by the source Observable.\n */\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\n  return filter((_, index) => count <= index);\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Skip a specified number of values before the completion of an observable.\n *\n * ![](skipLast.png)\n *\n * Returns an observable that will emit values as soon as it can, given a number of\n * skipped values. For example, if you `skipLast(3)` on a source, when the source\n * emits its fourth value, the first value the source emitted will finally be emitted\n * from the returned observable, as it is no longer part of what needs to be skipped.\n *\n * All values emitted by the result of `skipLast(N)` will be delayed by `N` emissions,\n * as each value is held in a buffer until enough values have been emitted that that\n * the buffered value may finally be sent to the consumer.\n *\n * After subscribing, unsubscribing will not result in the emission of the buffered\n * skipped values.\n *\n * ## Example\n *\n * Skip the last 2 values of an observable with many values\n *\n * ```ts\n * import { of, skipLast } from 'rxjs';\n *\n * const numbers = of(1, 2, 3, 4, 5);\n * const skipLastTwo = numbers.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * // (4 and 5 are skipped)\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @param skipCount Number of elements to skip from the end of the source Observable.\n * @return A function that returns an Observable that skips the last `count`\n * values emitted by the source Observable.\n */\nexport function skipLast<T>(skipCount: number): MonoTypeOperatorFunction<T> {\n  return skipCount <= 0\n    ? // For skipCounts less than or equal to zero, we are just mirroring the source.\n      identity\n    : operate((source, subscriber) => {\n        // A ring buffer to hold the values while we wait to see\n        // if we can emit it or it's part of the \"skipped\" last values.\n        // Note that it is the _same size_ as the skip count.\n        let ring: T[] = new Array(skipCount);\n        // The number of values seen so far. This is used to get\n        // the index of the current value when it arrives.\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Get the index of the value we have right now\n            // relative to all other values we've seen, then\n            // increment `seen`. This ensures we've moved to\n            // the next slot in our ring buffer.\n            const valueIndex = seen++;\n            if (valueIndex < skipCount) {\n              // If we haven't seen enough values to fill our buffer yet,\n              // Then we aren't to a number of seen values where we can\n              // emit anything, so let's just start by filling the ring buffer.\n              ring[valueIndex] = value;\n            } else {\n              // We are traversing over the ring array in such\n              // a way that when we get to the end, we loop back\n              // and go to the start.\n              const index = valueIndex % skipCount;\n              // Pull the oldest value out so we can emit it,\n              // and stuff the new value in it's place.\n              const oldValue = ring[index];\n              ring[index] = value;\n              // Emit the old value. It is important that this happens\n              // after we swap the value in the buffer, if it happens\n              // before we swap the value in the buffer, then a synchronous\n              // source can get the buffer out of whack.\n              subscriber.next(oldValue);\n            }\n          })\n        );\n\n        return () => {\n          // Release our values in memory\n          ring = null!;\n        };\n      });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * The `skipUntil` operator causes the observable stream to skip the emission of values until the passed in observable\n * emits the first value. This can be particularly useful in combination with user interactions, responses of HTTP\n * requests or waiting for specific times to pass by.\n *\n * ![](skipUntil.png)\n *\n * Internally, the `skipUntil` operator subscribes to the passed in `notifier` `ObservableInput` (which gets converted\n * to an Observable) in order to recognize the emission of its first value. When `notifier` emits next, the operator\n * unsubscribes from it and starts emitting the values of the *source* observable until it completes or errors. It\n * will never let the *source* observable emit any values if the `notifier` completes or throws an error without\n * emitting a value before.\n *\n * ## Example\n *\n * In the following example, all emitted values of the interval observable are skipped until the user clicks anywhere\n * within the page\n *\n * ```ts\n * import { interval, fromEvent, skipUntil } from 'rxjs';\n *\n * const intervalObservable = interval(1000);\n * const click = fromEvent(document, 'click');\n *\n * const emitAfterClick = intervalObservable.pipe(\n *   skipUntil(click)\n * );\n * // clicked at 4.6s. output: 5...6...7...8........ or\n * // clicked at 7.3s. output: 8...9...10..11.......\n * emitAfterClick.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipWhile}\n * @see {@link skipLast}\n *\n * @param notifier An `ObservableInput` that has to emit an item before the source Observable elements begin to\n * be mirrored by the resulting Observable.\n * @return A function that returns an Observable that skips items from the\n * source Observable until the `notifier` Observable emits an item, then emits the\n * remaining items.\n */\nexport function skipUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n\n    const skipSubscriber = createOperatorSubscriber(\n      subscriber,\n      () => {\n        skipSubscriber?.unsubscribe();\n        taking = true;\n      },\n      noop\n    );\n\n    innerFrom(notifier).subscribe(skipSubscriber);\n\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => taking && subscriber.next(value)));\n  });\n}\n","import { Falsy, MonoTypeOperatorFunction, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function skipWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, Extract<T, Falsy> extends never ? never : T>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => true): OperatorFunction<T, never>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * Skips all the notifications with a truthy predicate. It will not skip the notifications when the predicate is falsy.\n * It can also be skipped using index. Once the predicate is true, it will not be called again.\n *\n * ## Example\n *\n * Skip some super heroes\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from(['Green Arrow', 'SuperMan', 'Flash', 'SuperGirl', 'Black Canary'])\n * // Skip the heroes until SuperGirl\n * const example = source.pipe(skipWhile(hero => hero !== 'SuperGirl'));\n * // output: SuperGirl, Black Canary\n * example.subscribe(femaleHero => console.log(femaleHero));\n * ```\n *\n * Skip values from the array until index 5\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from([1, 2, 3, 4, 5, 6, 7, 9, 10]);\n * const example = source.pipe(skipWhile((_, i) => i !== 5));\n * // output: 6, 7, 9, 10\n * example.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param predicate A function to test each item emitted from the source Observable.\n * @return A function that returns an Observable that begins emitting items\n * emitted by the source Observable when the specified predicate becomes false.\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => (taking || (taking = !predicate(value, index++))) && subscriber.next(value))\n    );\n  });\n}\n","import { concat } from '../observable/concat';\nimport { OperatorFunction, SchedulerLike, ValueFromArray } from '../types';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function startWith<T>(value: null): OperatorFunction<T, T | null>;\nexport function startWith<T>(value: undefined): OperatorFunction<T, T | undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function startWith<T, A extends readonly unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\nexport function startWith<T, A extends readonly unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that, at the moment of subscription, will synchronously emit all\n * values provided to this operator, then subscribe to the source and mirror all of its emissions\n * to subscribers.\n *\n * This is a useful way to know when subscription has occurred on an existing observable.\n *\n * <span class=\"informal\">First emits its arguments in order, and then any\n * emissions from the source.</span>\n *\n * ![](startWith.png)\n *\n * ## Examples\n *\n * Emit a value when a timer starts.\n *\n * ```ts\n * import { timer, map, startWith } from 'rxjs';\n *\n * timer(1000)\n *   .pipe(\n *     map(() => 'timer emit'),\n *     startWith('timer start')\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // results:\n * // 'timer start'\n * // 'timer emit'\n * ```\n *\n * @param values Items you want the modified Observable to emit first.\n * @return A function that returns an Observable that synchronously emits\n * provided values before subscribing to the source Observable.\n *\n * @see {@link endWith}\n * @see {@link finalize}\n * @see {@link concat}\n */\nexport function startWith<T, D>(...values: D[]): OperatorFunction<T, T | D> {\n  const scheduler = popScheduler(values);\n  return operate((source, subscriber) => {\n    // Here we can't pass `undefined` as a scheduler, because if we did, the\n    // code inside of `concat` would be confused by the `undefined`, and treat it\n    // like an invalid observable. So we have to split it two different ways.\n    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n  });\n}\n","import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switchAll}.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n *\n * Generate new Observable according to source Observable values\n *\n * ```ts\n * import { of, switchMap } from 'rxjs';\n *\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // 3\n * // 9\n * // 27\n * ```\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMap, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * only the values from the most recently projected inner Observable.\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return operate((source, subscriber) => {\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\n    let index = 0;\n    // Whether or not the source subscription has completed\n    let isComplete = false;\n\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\n    // This is called both when the source completes and when the inners complete.\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Cancel the previous inner subscription if there was one\n          innerSubscriber?.unsubscribe();\n          let innerIndex = 0;\n          const outerIndex = index++;\n          // Start the next inner subscription\n          innerFrom(project(value, outerIndex)).subscribe(\n            (innerSubscriber = createOperatorSubscriber(\n              subscriber,\n              // When we get a new inner value, next it through. Note that this is\n              // handling the deprecate result selector here. This is because with this architecture\n              // it ends up being smaller than using the map operator.\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\n              () => {\n                // The inner has completed. Null out the inner subscriber to\n                // free up memory and to signal that we have no inner subscription\n                // currently.\n                innerSubscriber = null!;\n                checkComplete();\n              }\n            ))\n          );\n        },\n        () => {\n          isComplete = true;\n          checkComplete();\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\n\n/**\n * Converts a higher-order Observable into a first-order Observable\n * producing values only from the most recent observable sequence\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](switchAll.png)\n *\n * `switchAll` subscribes to a source that is an observable of observables, also known as a\n * \"higher-order observable\" (or `Observable<Observable<T>>`). It subscribes to the most recently\n * provided \"inner observable\" emitted by the source, unsubscribing from any previously subscribed\n * to inner observable, such that only the most recent inner observable may be subscribed to at\n * any point in time. The resulting observable returned by `switchAll` will only complete if the\n * source observable completes, *and* any currently subscribed to inner observable also has completed,\n * if there are any.\n *\n * ## Examples\n *\n * Spawn a new interval observable for each click event, but for every new\n * click, cancel the previous interval and subscribe to the new one\n *\n * ```ts\n * import { fromEvent, tap, map, interval, switchAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));\n * const source = clicks.pipe(map(() => interval(1000)));\n *\n * source\n *   .pipe(switchAll())\n *   .subscribe(x => console.log(x));\n *\n * // Output\n * // click\n * // 0\n * // 1\n * // 2\n * // 3\n * // ...\n * // click\n * // 0\n * // 1\n * // 2\n * // ...\n * // click\n * // ...\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link mergeAll}\n *\n * @return A function that returns an Observable that converts a higher-order\n * Observable into a first-order Observable producing values only from the most\n * recent Observable sequence.\n */\nexport function switchAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return switchMap(identity);\n}\n","import { switchMap } from './switchMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)` */\nexport function switchMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMapTo<O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: undefined\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switchMap} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](switchMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * ## Example\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMapTo, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMapTo(interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param innerObservable An `ObservableInput` to replace each value from the\n * source Observable.\n * @return A function that returns an Observable that emits items from the\n * given `innerObservable` (and optionally transformed through the deprecated\n * `resultSelector`) every time a value is emitted on the source Observable,\n * and taking only the values from the most recently projected inner\n * Observable.\n * @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)`\n */\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);\n}\n","import { ObservableInput, ObservedValueOf, OperatorFunction } from '../types';\nimport { switchMap } from './switchMap';\nimport { operate } from '../util/lift';\n\n// TODO: Generate a marble diagram for these docs.\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, emitting values\n * only from the most recently returned Observable.\n *\n * <span class=\"informal\">It's like {@link mergeScan}, but only the most recent\n * Observable returned by the accumulator is merged into the outer Observable.</span>\n *\n * @see {@link scan}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @return A function that returns an observable of the accumulated values.\n */\nexport function switchScan<T, R, O extends ObservableInput<any>>(\n  accumulator: (acc: R, value: T, index: number) => O,\n  seed: R\n): OperatorFunction<T, ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    // The state we will keep up to date to pass into our\n    // accumulator function at each new value from the source.\n    let state = seed;\n\n    // Use `switchMap` on our `source` to do the work of creating\n    // this operator. Note the backwards order here of `switchMap()(source)`\n    // to avoid needing to use `pipe` unnecessarily\n    switchMap(\n      // On each value from the source, call the accumulator with\n      // our previous state, the value and the index.\n      (value: T, index) => accumulator(state, value, index),\n      // Using the deprecated result selector here as a dirty trick\n      // to update our state with the flattened value.\n      (_, innerValue) => ((state = innerValue), innerValue)\n    )(source).subscribe(subscriber);\n\n    return () => {\n      // Release state on finalization\n      state = null!;\n    };\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n *\n * Tick every second until the first click happens\n *\n * ```ts\n * import { interval, fromEvent, takeUntil } from 'rxjs';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param notifier The `ObservableInput` whose first emitted value will cause the output\n * Observable of `takeUntil` to stop emitting values from the source Observable.\n * @return A function that returns an Observable that emits the values from the\n * source Observable until `notifier` emits its first value.\n */\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: true): MonoTypeOperatorFunction<T>;\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: false): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * ![](takeWhile.png)\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * ## Example\n *\n * Emit click events only while the clientX property is greater than 200\n *\n * ```ts\n * import { fromEvent, takeWhile } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param predicate A function that evaluates a value emitted by the source\n * Observable and returns a boolean. Also takes the (zero-based) index as the\n * second argument.\n * @param inclusive When set to `true` the value that caused `predicate` to\n * return `false` will also be emitted.\n * @return A function that returns an Observable that emits values from the\n * source Observable so long as each value satisfies the condition defined by\n * the `predicate`, then completes.\n */\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive = false): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const result = predicate(value, index++);\n        (result || inclusive) && subscriber.next(value);\n        !result && subscriber.complete();\n      })\n    );\n  });\n}\n","import { MonoTypeOperatorFunction, Observer } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\n\n/**\n * An extension to the {@link Observer} interface used only by the {@link tap} operator.\n *\n * It provides a useful set of callbacks a user can register to do side-effects in\n * cases other than what the usual {@link Observer} callbacks are\n * ({@link guide/glossary-and-semantics#next next},\n * {@link guide/glossary-and-semantics#error error} and/or\n * {@link guide/glossary-and-semantics#complete complete}).\n *\n * ## Example\n *\n * ```ts\n * import { fromEvent, switchMap, tap, interval, take } from 'rxjs';\n *\n * const source$ = fromEvent(document, 'click');\n * const result$ = source$.pipe(\n *   switchMap((_, i) => i % 2 === 0\n *     ? fromEvent(document, 'mousemove').pipe(\n *         tap({\n *           subscribe: () => console.log('Subscribed to the mouse move events after click #' + i),\n *           unsubscribe: () => console.log('Mouse move events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('Mouse move events #' + i + ' finalized')\n *         })\n *       )\n *     : interval(1_000).pipe(\n *         take(5),\n *         tap({\n *           subscribe: () => console.log('Subscribed to the 1-second interval events after click #' + i),\n *           unsubscribe: () => console.log('1-second interval events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('1-second interval events #' + i + ' finalized')\n *         })\n *       )\n *   )\n * );\n *\n * const subscription = result$.subscribe({\n *   next: console.log\n * });\n *\n * setTimeout(() => {\n *   console.log('Unsubscribe after 60 seconds');\n *   subscription.unsubscribe();\n * }, 60_000);\n * ```\n */\nexport interface TapObserver<T> extends Observer<T> {\n  /**\n   * The callback that `tap` operator invokes at the moment when the source Observable\n   * gets subscribed to.\n   */\n  subscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when an explicit\n   * {@link guide/glossary-and-semantics#unsubscription unsubscribe} happens. It won't get invoked on\n   * `error` or `complete` events.\n   */\n  unsubscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when any kind of\n   * {@link guide/glossary-and-semantics#finalization finalization} happens - either when\n   * the source Observable `error`s or `complete`s or when it gets explicitly unsubscribed\n   * by the user. There is no difference in using this callback or the {@link finalize}\n   * operator, but if you're already using `tap` operator, you can use this callback\n   * instead. You'd get the same result in either case.\n   */\n  finalize: () => void;\n}\nexport function tap<T>(observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void)): MonoTypeOperatorFunction<T>;\n/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\nexport function tap<T>(\n  next?: ((value: T) => void) | null,\n  error?: ((error: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Used to perform side-effects for notifications from the source observable\n *\n * <span class=\"informal\">Used when you want to affect outside state with a notification without altering the notification</span>\n *\n * ![](tap.png)\n *\n * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects\n * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will\n * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to\n * help you remove side-effects from other operations.\n *\n * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function\n * reference, or a partial observer, then pass that notification down the stream.\n *\n * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler\n * provided to `tap` will be emitted as an error from the returned observable.\n *\n * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.\n *\n * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere\n * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous\n * operation.\n *\n * ## Examples\n *\n * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,\n * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number\n * was, so we have added a `tap(console.log)`.\n *\n * ```ts\n * import { of, tap, map } from 'rxjs';\n *\n * of(Math.random()).pipe(\n *   tap(console.log),\n *   map(n => n > 0.5 ? 'big' : 'small')\n * ).subscribe(console.log);\n * ```\n *\n * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only\n * want to emit numbers 3 or less we get from another source. We can force our observable to error\n * using `tap`.\n *\n * ```ts\n * import { of, tap } from 'rxjs';\n *\n * const source = of(1, 2, 3, 4, 5);\n *\n * source.pipe(\n *   tap(n => {\n *     if (n > 3) {\n *       throw new TypeError(`Value ${ n } is greater than 3`);\n *     }\n *   })\n * )\n * .subscribe({ next: console.log, error: err => console.log(err.message) });\n * ```\n *\n * We want to know when an observable completes before moving on to the next observable. The system\n * below will emit a random series of `'X'` characters from 3 different observables in sequence. The\n * only way we know when one observable completes and moves to the next one, in this case, is because\n * we have added a `tap` with the side effect of logging to console.\n *\n * ```ts\n * import { of, concatMap, interval, take, map, tap } from 'rxjs';\n *\n * of(1, 2, 3).pipe(\n *   concatMap(n => interval(1000).pipe(\n *     take(Math.round(Math.random() * 10)),\n *     map(() => 'X'),\n *     tap({ complete: () => console.log(`Done with ${ n }`) })\n *   ))\n * )\n * .subscribe(console.log);\n * ```\n *\n * @see {@link finalize}\n * @see {@link TapObserver}\n *\n * @param observerOrNext A next handler or partial observer\n * @param error An error handler\n * @param complete A completion handler\n * @return A function that returns an Observable identical to the source, but\n * runs the specified Observer or callback(s) for each item.\n */\nexport function tap<T>(\n  observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void) | null,\n  error?: ((e: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T> {\n  // We have to check to see not only if next is a function,\n  // but if error or complete were passed. This is because someone\n  // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.\n  const tapObserver =\n    isFunction(observerOrNext) || error || complete\n      ? // tslint:disable-next-line: no-object-literal-type-assertion\n        ({ next: observerOrNext as Exclude<typeof observerOrNext, Partial<TapObserver<T>>>, error, complete } as Partial<TapObserver<T>>)\n      : observerOrNext;\n\n  return tapObserver\n    ? operate((source, subscriber) => {\n        tapObserver.subscribe?.();\n        let isUnsub = true;\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              tapObserver.next?.(value);\n              subscriber.next(value);\n            },\n            () => {\n              isUnsub = false;\n              tapObserver.complete?.();\n              subscriber.complete();\n            },\n            (err) => {\n              isUnsub = false;\n              tapObserver.error?.(err);\n              subscriber.error(err);\n            },\n            () => {\n              if (isUnsub) {\n                tapObserver.unsubscribe?.();\n              }\n              tapObserver.finalize?.();\n            }\n          )\n        );\n      })\n    : // Tap was called with no valid tap observer or handler\n      // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)\n      // so we're going to just mirror the source.\n      identity;\n}\n","import { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * An object interface used by {@link throttle} or {@link throttleTime} that ensure\n * configuration options of these operators.\n *\n * @see {@link throttle}\n * @see {@link throttleTime}\n */\nexport interface ThrottleConfig {\n  /**\n   * If `true`, the resulting Observable will emit the first value from the source\n   * Observable at the **start** of the \"throttling\" process (when starting an\n   * internal timer that prevents other emissions from the source to pass through).\n   * If `false`, it will not emit the first value from the source Observable at the\n   * start of the \"throttling\" process.\n   *\n   * If not provided, defaults to: `true`.\n   */\n  leading?: boolean;\n  /**\n   * If `true`, the resulting Observable will emit the last value from the source\n   * Observable at the **end** of the \"throttling\" process (when ending an internal\n   * timer that prevents other emissions from the source to pass through).\n   * If `false`, it will not emit the last value from the source Observable at the\n   * end of the \"throttling\" process.\n   *\n   * If not provided, defaults to: `false`.\n   */\n  trailing?: boolean;\n}\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.svg)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, throttle, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(() => interval(1000)));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function that receives a value from the source\n * Observable, for computing the silencing duration for each source value,\n * returned as an `ObservableInput`.\n * @param config A configuration object to define `leading` and `trailing`\n * behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return A function that returns an Observable that performs the throttle\n * operation to limit the rate of emissions from the source.\n */\nexport function throttle<T>(durationSelector: (value: T) => ObservableInput<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    const { leading = true, trailing = false } = config ?? {};\n    let hasValue = false;\n    let sendValue: T | null = null;\n    let throttled: Subscription | null = null;\n    let isComplete = false;\n\n    const endThrottling = () => {\n      throttled?.unsubscribe();\n      throttled = null;\n      if (trailing) {\n        send();\n        isComplete && subscriber.complete();\n      }\n    };\n\n    const cleanupThrottling = () => {\n      throttled = null;\n      isComplete && subscriber.complete();\n    };\n\n    const startThrottle = (value: T) =>\n      (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));\n\n    const send = () => {\n      if (hasValue) {\n        // Ensure we clear out our value and hasValue flag\n        // before we emit, otherwise reentrant code can cause\n        // issues here.\n        hasValue = false;\n        const value = sendValue!;\n        sendValue = null;\n        // Emit the value.\n        subscriber.next(value);\n        !isComplete && startThrottle(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        // Regarding the presence of throttled.closed in the following\n        // conditions, if a synchronous duration selector is specified - weird,\n        // but legal - an already-closed subscription will be assigned to\n        // throttled, so the subscription's closed property needs to be checked,\n        // too.\n        (value) => {\n          hasValue = true;\n          sendValue = value;\n          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));\n        },\n        () => {\n          isComplete = true;\n          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { throttle, ThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { timer } from '../observable/timer';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Examples\n *\n * ### Limit click rate\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, throttleTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param scheduler The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling. Defaults to {@link asyncScheduler}.\n * @param config A configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return A function that returns an Observable that performs the throttle\n * operation to limit the rate of emissions from the source.\n */\nexport function throttleTime<T>(\n  duration: number,\n  scheduler: SchedulerLike = asyncScheduler,\n  config?: ThrottleConfig\n): MonoTypeOperatorFunction<T> {\n  const duration$ = timer(duration, scheduler);\n  return throttle(() => duration$, config);\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits an object containing the current value, and the time that has\n * passed between emitting the current value and the previous value, which is\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\n * the current time at each emission, then calculating the difference. The `scheduler`\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\n * milliseconds.\n *\n * <span class=\"informal\">Convert an Observable that emits items into one that\n * emits indications of the amount of time elapsed between those emissions.</span>\n *\n * ![](timeInterval.png)\n *\n * ## Example\n *\n * Emit interval between current value with the last value\n *\n * ```ts\n * import { interval, timeInterval } from 'rxjs';\n *\n * const seconds = interval(1000);\n *\n * seconds\n *   .pipe(timeInterval())\n *   .subscribe(value => console.log(value));\n *\n * // NOTE: The values will never be this precise,\n * // intervals created with `interval` or `setInterval`\n * // are non-deterministic.\n *\n * // { value: 0, interval: 1000 }\n * // { value: 1, interval: 1000 }\n * // { value: 2, interval: 1000 }\n * ```\n *\n * @param scheduler Scheduler used to get the current time.\n * @return A function that returns an Observable that emits information about\n * value and interval.\n */\nexport function timeInterval<T>(scheduler: SchedulerLike = asyncScheduler): OperatorFunction<T, TimeInterval<T>> {\n  return operate((source, subscriber) => {\n    let last = scheduler.now();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const now = scheduler.now();\n        const interval = now - last;\n        last = now;\n        subscriber.next(new TimeInterval(value, interval));\n      })\n    );\n  });\n}\n\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\n// there's no reason users should be manually creating this type.\n\nexport class TimeInterval<T> {\n  /**\n   * @deprecated Internal implementation detail, do not construct directly. Will be made an interface in v8.\n   */\n  constructor(public value: T, public interval: number) {}\n}\n","import { async } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\nimport { timeout } from './timeout';\n\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(someDate, a$, scheduler)`, use the configuration object\n * `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(dueBy: Date, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use the configuration object\n *  `timeout({ each: 100, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(waitFor: number, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n\n/**\n * When the passed timespan elapses before the source emits any given value, it will unsubscribe from the source,\n * and switch the subscription to another observable.\n *\n * <span class=\"informal\">Used to switch to a different observable if your source is being slow.</span>\n *\n * Useful in cases where:\n *\n * - You want to switch to a different source that may be faster.\n * - You want to notify a user that the data stream is slow.\n * - You want to emit a custom error rather than the {@link TimeoutError} emitted\n *   by the default usage of {@link timeout}.\n *\n * If the first parameter is passed as Date and the time of the Date arrives before the first value arrives from the source,\n * it will unsubscribe from the source and switch the subscription to another observable.\n *\n * <span class=\"informal\">Use Date object to switch to a different observable if the first value doesn't arrive by a specific time.</span>\n *\n * Can be used to set a timeout only for the first value, however it's recommended to use the {@link timeout} operator with\n * the `first` configuration to get the same effect.\n *\n * ## Examples\n *\n * Fallback to a faster observable\n *\n * ```ts\n * import { interval, timeoutWith } from 'rxjs';\n *\n * const slow$ = interval(1000);\n * const faster$ = interval(500);\n *\n * slow$\n *   .pipe(timeoutWith(900, faster$))\n *   .subscribe(console.log);\n * ```\n *\n * Emit your own custom timeout error\n *\n * ```ts\n * import { interval, timeoutWith, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(1000);\n *\n * slow$\n *   .pipe(timeoutWith(900, throwError(() => new CustomTimeoutError())))\n *   .subscribe({\n *     error: err => console.error(err.message)\n *   });\n * ```\n *\n * @see {@link timeout}\n *\n * @param due When passed a number, used as the time (in milliseconds) allowed between each value from the source before timeout\n * is triggered. When passed a Date, used as the exact time at which the timeout will be triggered if the first value does not arrive.\n * @param withObservable The observable to switch to when timeout occurs.\n * @param scheduler The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it starts emitting values\n * from the `ObservableInput` passed as a second parameter.\n * @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use {@link timeout} with the configuration\n * object: `timeout({ each: 100, with: () => a$, scheduler })`. Instead of `timeoutWith(someDate, a$, scheduler)`, use {@link timeout}\n * with the configuration object: `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8.\n */\nexport function timeoutWith<T, R>(\n  due: number | Date,\n  withObservable: ObservableInput<R>,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T | R> {\n  let first: number | Date | undefined;\n  let each: number | undefined;\n  let _with: () => ObservableInput<R>;\n  scheduler = scheduler ?? async;\n\n  if (isValidDate(due)) {\n    first = due;\n  } else if (typeof due === 'number') {\n    each = due;\n  }\n\n  if (withObservable) {\n    _with = () => withObservable;\n  } else {\n    throw new TypeError('No observable provided to switch to');\n  }\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return timeout<T, ObservableInput<R>>({\n    first,\n    each,\n    scheduler,\n    with: _with,\n  });\n}\n","import { OperatorFunction, TimestampProvider, Timestamp } from '../types';\nimport { dateTimestampProvider } from '../scheduler/dateTimestampProvider';\nimport { map } from './map';\n\n/**\n * Attaches a timestamp to each item emitted by an observable indicating when it was emitted\n *\n * The `timestamp` operator maps the *source* observable stream to an object of type\n * `{value: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value\n * and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By\n * default, it uses the `asyncScheduler` which simply returns `Date.now()` (milliseconds since 1970/01/01\n * 00:00:00:000) and therefore is of type `number`.\n *\n * ![](timestamp.png)\n *\n * ## Example\n *\n * In this example there is a timestamp attached to the document's click events\n *\n * ```ts\n * import { fromEvent, timestamp } from 'rxjs';\n *\n * const clickWithTimestamp = fromEvent(document, 'click').pipe(\n *   timestamp()\n * );\n *\n * // Emits data of type { value: PointerEvent, timestamp: number }\n * clickWithTimestamp.subscribe(data => {\n *   console.log(data);\n * });\n * ```\n *\n * @param timestampProvider An object with a `now()` method used to get the current timestamp.\n * @return A function that returns an Observable that attaches a timestamp to\n * each item emitted by the source Observable indicating when it was emitted.\n */\nexport function timestamp<T>(timestampProvider: TimestampProvider = dateTimestampProvider): OperatorFunction<T, Timestamp<T>> {\n  return map((value: T) => ({ value, timestamp: timestampProvider.now() }));\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * ![](window.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * `windowBoundaries` emits an item. `windowBoundaries` can be any type that\n * `ObservableInput` accepts. It internally gets converted to an Observable.\n * Because each window is an Observable, the output is a higher-order Observable.\n *\n * ## Example\n *\n * In every window of 1 second each, emit at most 2 click events\n *\n * ```ts\n * import { fromEvent, interval, window, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const sec = interval(1000);\n * const result = clicks.pipe(\n *   window(sec),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param windowBoundaries An `ObservableInput` that completes the\n * previous window and starts a new window.\n * @return A function that returns an Observable of windows, which are\n * Observables emitting values of the source Observable.\n */\nexport function window<T>(windowBoundaries: ObservableInput<any>): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    let windowSubject: Subject<T> = new Subject<T>();\n\n    subscriber.next(windowSubject.asObservable());\n\n    const errorHandler = (err: any) => {\n      windowSubject.error(err);\n      subscriber.error(err);\n    };\n\n    // Subscribe to our source\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => windowSubject?.next(value),\n        () => {\n          windowSubject.complete();\n          subscriber.complete();\n        },\n        errorHandler\n      )\n    );\n\n    // Subscribe to the window boundaries.\n    innerFrom(windowBoundaries).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          windowSubject.complete();\n          subscriber.next((windowSubject = new Subject()));\n        },\n        noop,\n        errorHandler\n      )\n    );\n\n    return () => {\n      // Unsubscribing the subject ensures that anyone who has captured\n      // a reference to this window that tries to use it after it can\n      // no longer get values from the source will get an ObjectUnsubscribedError.\n      windowSubject?.unsubscribe();\n      windowSubject = null!;\n    };\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n *\n * Ignore every 3rd click event, starting from the first one\n *\n * ```ts\n * import { fromEvent, windowCount, map, skip, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3),\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n *\n * ```ts\n * import { fromEvent, windowCount, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll() // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param windowSize The maximum number of values emitted by each window.\n * @param startWindowEvery Interval at which to start a new window. For example\n * if `startWindowEvery` is `2`, then a new window will be started on every\n * other value from the source. A new window is started at the beginning of the\n * source by default.\n * @return A function that returns an Observable of windows, which in turn are\n * Observable of values.\n */\nexport function windowCount<T>(windowSize: number, startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  const startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;\n\n  return operate((source, subscriber) => {\n    let windows = [new Subject<T>()];\n    let starts: number[] = [];\n    let count = 0;\n\n    // Open the first window.\n    subscriber.next(windows[0].asObservable());\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Emit the value through all current windows.\n          // We don't need to create a new window yet, we\n          // do that as soon as we close one.\n          for (const window of windows) {\n            window.next(value);\n          }\n          // Here we're using the size of the window array to figure\n          // out if the oldest window has emitted enough values. We can do this\n          // because the size of the window array is a function of the values\n          // seen by the subscription. If it's time to close it, we complete\n          // it and remove it.\n          const c = count - windowSize + 1;\n          if (c >= 0 && c % startEvery === 0) {\n            windows.shift()!.complete();\n          }\n\n          // Look to see if the next count tells us it's time to open a new window.\n          // TODO: We need to figure out if this really makes sense. We're technically\n          // emitting windows *before* we have a value to emit them for. It's probably\n          // more expected that we should be emitting the window when the start\n          // count is reached -- not before.\n          if (++count % startEvery === 0) {\n            const window = new Subject<T>();\n            windows.push(window);\n            subscriber.next(window.asObservable());\n          }\n        },\n        () => {\n          while (windows.length > 0) {\n            windows.shift()!.complete();\n          }\n          subscriber.complete();\n        },\n        (err) => {\n          while (windows.length > 0) {\n            windows.shift()!.error(err);\n          }\n          subscriber.error(err);\n        },\n        () => {\n          starts = null!;\n          windows = null!;\n        }\n      )\n    );\n  });\n}\n","import { Subject } from '../Subject';\nimport { asyncScheduler } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { Observer, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function windowTime<T>(windowTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(\n  windowTimeSpan: number,\n  windowCreationInterval: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(\n  windowTimeSpan: number,\n  windowCreationInterval: number | null | void,\n  maxWindowSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, Observable<T>>;\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n *\n * In every window of 1 second each, emit at most 2 click events\n *\n * ```ts\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n *\n * ```ts\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with `maxWindowCount` instead of `take`\n *\n * ```ts\n * import { fromEvent, windowTime, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // take at most 2 emissions from each window\n *   mergeAll()                 // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param windowTimeSpan The amount of time, in milliseconds, to fill each window.\n * @param windowCreationInterval The interval at which to start new\n * windows.\n * @param maxWindowSize Max number of\n * values each window can emit before completion.\n * @param scheduler The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowTime<T>(windowTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, Observable<T>> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const windowCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxWindowSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active windows, their related subscriptions, and removal functions.\n    let windowRecords: WindowRecord<T>[] | null = [];\n    // If true, it means that every time we close a window, we want to start a new window.\n    // This is only really used for when *just* the time span is passed.\n    let restartOnClose = false;\n\n    const closeWindow = (record: { window: Subject<T>; subs: Subscription }) => {\n      const { window, subs } = record;\n      window.complete();\n      subs.unsubscribe();\n      arrRemove(windowRecords, record);\n      restartOnClose && startWindow();\n    };\n\n    /**\n     * Called every time we start a new window. This also does\n     * the work of scheduling the job to close the window.\n     */\n    const startWindow = () => {\n      if (windowRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const window = new Subject<T>();\n        const record = {\n          window,\n          subs,\n          seen: 0,\n        };\n        windowRecords.push(record);\n        subscriber.next(window.asObservable());\n        executeSchedule(subs, scheduler, () => closeWindow(record), windowTimeSpan);\n      }\n    };\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      // The user passed both a windowTimeSpan (required), and a creation interval\n      // That means we need to start new window on the interval, and those windows need\n      // to wait the required time span before completing.\n      executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);\n    } else {\n      restartOnClose = true;\n    }\n\n    startWindow();\n\n    /**\n     * We need to loop over a copy of the window records several times in this operator.\n     * This is to save bytes over the wire more than anything.\n     * The reason we copy the array is that reentrant code could mutate the array while\n     * we are iterating over it.\n     */\n    const loop = (cb: (record: WindowRecord<T>) => void) => windowRecords!.slice().forEach(cb);\n\n    /**\n     * Used to notify all of the windows and the subscriber in the same way\n     * in the error and complete handlers.\n     */\n    const terminate = (cb: (consumer: Observer<any>) => void) => {\n      loop(({ window }) => cb(window));\n      cb(subscriber);\n      subscriber.unsubscribe();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Notify all windows of the value.\n          loop((record) => {\n            record.window.next(value);\n            // If the window is over the max size, we need to close it.\n            maxWindowSize <= ++record.seen && closeWindow(record);\n          });\n        },\n        // Complete the windows and the downstream subscriber and clean up.\n        () => terminate((consumer) => consumer.complete()),\n        // Notify the windows and the downstream subscriber of the error and clean up.\n        (err) => terminate((consumer) => consumer.error(err))\n      )\n    );\n\n    // Additional finalization. This will be called when the\n    // destination tears down. Other finalizations are registered implicitly\n    // above via subscription.\n    return () => {\n      // Ensure that the buffer is released.\n      windowRecords = null!;\n    };\n  });\n}\n\ninterface WindowRecord<T> {\n  seen: number;\n  window: Subject<T>;\n  subs: Subscription;\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, windowToggle, EMPTY, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),\n *   mergeAll()\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param openings An observable of notifications to start new windows.\n * @param closingSelector A function that takes the value emitted by the\n * `openings` observable and returns an Observable, which, when it emits a next\n * notification, signals that the associated window should complete.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowToggle<T, O>(\n  openings: ObservableInput<O>,\n  closingSelector: (openValue: O) => ObservableInput<any>\n): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    const windows: Subject<T>[] = [];\n\n    const handleError = (err: any) => {\n      while (0 < windows.length) {\n        windows.shift()!.error(err);\n      }\n      subscriber.error(err);\n    };\n\n    innerFrom(openings).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (openValue) => {\n          const window = new Subject<T>();\n          windows.push(window);\n          const closingSubscription = new Subscription();\n          const closeWindow = () => {\n            arrRemove(windows, window);\n            window.complete();\n            closingSubscription.unsubscribe();\n          };\n\n          let closingNotifier: Observable<any>;\n          try {\n            closingNotifier = innerFrom(closingSelector(openValue));\n          } catch (err) {\n            handleError(err);\n            return;\n          }\n\n          subscriber.next(window.asObservable());\n\n          closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));\n        },\n        noop\n      )\n    );\n\n    // Subscribe to the source to get things started.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Copy the windows array before we emit to\n          // make sure we don't have issues with reentrant code.\n          const windowsCopy = windows.slice();\n          for (const window of windowsCopy) {\n            window.next(value);\n          }\n        },\n        () => {\n          // Complete all of our windows before we complete.\n          while (0 < windows.length) {\n            windows.shift()!.complete();\n          }\n          subscriber.complete();\n        },\n        handleError,\n        () => {\n          // Add this finalization so that all window subjects are\n          // disposed of. This way, if a user tries to subscribe\n          // to a window *after* the outer subscription has been unsubscribed,\n          // they will get an error, instead of waiting forever to\n          // see if a value arrives.\n          while (0 < windows.length) {\n            windows.shift()!.unsubscribe();\n          }\n        }\n      )\n    );\n  });\n}\n","import { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n *\n * Emit only the first two clicks events in every window of [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, windowWhen, interval, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param closingSelector A function that takes no arguments and returns an\n * {@link ObservableInput} (that gets converted to Observable) that signals\n * (on either `next` or `complete`) when to close the previous window and\n * start a new one.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    let window: Subject<T> | null;\n    let closingSubscriber: Subscriber<any> | undefined;\n\n    /**\n     * When we get an error, we have to notify both the\n     * destination subscriber and the window.\n     */\n    const handleError = (err: any) => {\n      window!.error(err);\n      subscriber.error(err);\n    };\n\n    /**\n     * Called every time we need to open a window.\n     * Recursive, as it will start the closing notifier, which\n     * inevitably *should* call openWindow -- but may not if\n     * it is a \"never\" observable.\n     */\n    const openWindow = () => {\n      // We need to clean up our closing subscription,\n      // we only cared about the first next or complete notification.\n      closingSubscriber?.unsubscribe();\n\n      // Close our window before starting a new one.\n      window?.complete();\n\n      // Start the new window.\n      window = new Subject<T>();\n      subscriber.next(window.asObservable());\n\n      // Get our closing notifier.\n      let closingNotifier: Observable<any>;\n      try {\n        closingNotifier = innerFrom(closingSelector());\n      } catch (err) {\n        handleError(err);\n        return;\n      }\n\n      // Subscribe to the closing notifier, be sure\n      // to capture the subscriber (aka Subscription)\n      // so we can clean it up when we close the window\n      // and open a new one.\n      closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));\n    };\n\n    // Start the first window.\n    openWindow();\n\n    // Subscribe to the source\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => window!.next(value),\n        () => {\n          // The source completed, close the window and complete.\n          window!.complete();\n          subscriber.complete();\n        },\n        handleError,\n        () => {\n          // Be sure to clean up our closing subscription\n          // when this tears down.\n          closingSubscriber?.unsubscribe();\n          window = null!;\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { identity } from '../util/identity';\nimport { noop } from '../util/noop';\nimport { popResultSelector } from '../util/args';\n\nexport function withLatestFrom<T, O extends unknown[]>(...inputs: [...ObservableInputTuple<O>]): OperatorFunction<T, [T, ...O]>;\n\nexport function withLatestFrom<T, O extends unknown[], R>(\n  ...inputs: [...ObservableInputTuple<O>, (...value: [T, ...O]) => R]\n): OperatorFunction<T, R>;\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * ![](withLatestFrom.png)\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * ## Example\n *\n * On every click event, emit an array with the latest timer event plus the click event\n *\n * ```ts\n * import { fromEvent, interval, withLatestFrom } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const result = clicks.pipe(withLatestFrom(timer));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n *\n * @param inputs An input Observable to combine with the source Observable. More\n * than one input Observables may be given as argument. If the last parameter is\n * a function, it will be used as a projection function for combining values\n * together. When the function is called, it receives all values in order of the\n * Observables passed, where the first parameter is a value from the source\n * Observable. (e.g.\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this\n * is not passed, arrays will be emitted on the output Observable.\n * @return A function that returns an Observable of projected values from the\n * most recent values from each input Observable, or an array of the most\n * recent values from each input Observable.\n */\nexport function withLatestFrom<T, R>(...inputs: any[]): OperatorFunction<T, R | any[]> {\n  const project = popResultSelector(inputs) as ((...args: any[]) => R) | undefined;\n\n  return operate((source, subscriber) => {\n    const len = inputs.length;\n    const otherValues = new Array(len);\n    // An array of whether or not the other sources have emitted. Matched with them by index.\n    // TODO: At somepoint, we should investigate the performance implications here, and look\n    // into using a `Set()` and checking the `size` to see if we're ready.\n    let hasValue = inputs.map(() => false);\n    // Flipped true when we have at least one value from all other sources and\n    // we are ready to start emitting values.\n    let ready = false;\n\n    // Other sources. Note that here we are not checking `subscriber.closed`,\n    // this causes all inputs to be subscribed to, even if nothing can be emitted\n    // from them. This is an important distinction because subscription constitutes\n    // a side-effect.\n    for (let i = 0; i < len; i++) {\n      innerFrom(inputs[i]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            otherValues[i] = value;\n            if (!ready && !hasValue[i]) {\n              // If we're not ready yet, flag to show this observable has emitted.\n              hasValue[i] = true;\n              // Intentionally terse code.\n              // If all of our other observables have emitted, set `ready` to `true`,\n              // so we know we can start emitting values, then clean up the `hasValue` array,\n              // because we don't need it anymore.\n              (ready = hasValue.every(identity)) && (hasValue = null!);\n            }\n          },\n          // Completing one of the other sources has\n          // no bearing on the completion of our result.\n          noop\n        )\n      );\n    }\n\n    // Source subscription\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        if (ready) {\n          // We have at least one value from the other sources. Go ahead and emit.\n          const values = [value, ...otherValues];\n          subscriber.next(project ? project(...values) : values);\n        }\n      })\n    );\n  });\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { zip } from '../observable/zip';\nimport { joinAllInternals } from './joinAllInternals';\n\n/**\n * Collects all observable inner sources from the source, once the source completes,\n * it will subscribe to all inner sources, combining their values by index and emitting\n * them.\n *\n * @see {@link zipWith}\n * @see {@link zip}\n */\nexport function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function zipAll<T>(): OperatorFunction<any, T[]>;\nexport function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\nexport function zipAll<T, R>(project?: (...values: T[]) => R) {\n  return joinAllInternals(zip, project);\n}\n","import { zip as zipStatic } from '../observable/zip';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { operate } from '../util/lift';\n\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[]>(otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[], R>(\n  otherInputsAndProject: [...ObservableInputTuple<A>],\n  project: (...values: Cons<T, A>) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[], R>(\n  ...otherInputsAndProject: [...ObservableInputTuple<A>, (...values: Cons<T, A>) => R]\n): OperatorFunction<T, R>;\n\n/**\n * @deprecated Replaced with {@link zipWith}. Will be removed in v8.\n */\nexport function zip<T, R>(...sources: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, any> {\n  return operate((source, subscriber) => {\n    zipStatic(source as ObservableInput<any>, ...(sources as Array<ObservableInput<any>>)).subscribe(subscriber);\n  });\n}\n","import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { zip } from './zip';\n\n/**\n * Subscribes to the source, and the observable inputs provided as arguments, and combines their values, by index, into arrays.\n *\n * What is meant by \"combine by index\": The first value from each will be made into a single array, then emitted,\n * then the second value from each will be combined into a single array and emitted, then the third value\n * from each will be combined into a single array and emitted, and so on.\n *\n * This will continue until it is no longer able to combine values of the same index into an array.\n *\n * After the last value from any one completed source is emitted in an array, the resulting observable will complete,\n * as there is no way to continue \"zipping\" values together by index.\n *\n * Use-cases for this operator are limited. There are memory concerns if one of the streams is emitting\n * values at a much faster rate than the others. Usage should likely be limited to streams that emit\n * at a similar pace, or finite streams of known length.\n *\n * In many cases, authors want `combineLatestWith` and not `zipWith`.\n *\n * @param otherInputs other observable inputs to collate values from.\n * @return A function that returns an Observable that emits items by index\n * combined from the source Observable and provided Observables, in form of an\n * array.\n */\nexport function zipWith<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>> {\n  return zip(...otherInputs);\n}\n","//////////////////////////////////////////////////////////\n// Here we need to reference our other deep imports\n// so VS code will figure out where they are\n// see conversation here:\n// https://github.com/microsoft/TypeScript/issues/43034\n//////////////////////////////////////////////////////////\n\n// tslint:disable: no-reference\n// It's tempting to add references to all of the deep-import locations, but\n// adding references to those that require DOM types breaks Node projects.\n/// <reference path=\"./operators/index.ts\" />\n/// <reference path=\"./testing/index.ts\" />\n// tslint:enable: no-reference\n\n/* Observable */\nexport { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { Operator } from './internal/Operator';\nexport { observable } from './internal/symbol/observable';\nexport { animationFrames } from './internal/observable/dom/animationFrames';\n\n/* Subjects */\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\n\n/* Schedulers */\nexport { asap, asapScheduler } from './internal/scheduler/asap';\nexport { async, asyncScheduler } from './internal/scheduler/async';\nexport { queue, queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame, animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\n\n/* Subscription */\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\n\n/* Notification */\nexport { Notification, NotificationKind } from './internal/Notification';\n\n/* Utils */\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\n\n/* Promise Conversion */\nexport { lastValueFrom } from './internal/lastValueFrom';\nexport { firstValueFrom } from './internal/firstValueFrom';\n\n/* Error types */\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { NotFoundError } from './internal/util/NotFoundError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { SequenceError } from './internal/util/SequenceError';\nexport { TimeoutError } from './internal/operators/timeout';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\n\n/* Static observable creation exports */\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { connectable } from './internal/observable/connectable';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\n\n/* Constants */\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\n\n/* Types */\nexport * from './internal/types';\n\n/* Config */\nexport { config, GlobalConfig } from './internal/config';\n\n/* Operators */\nexport { audit } from './internal/operators/audit';\nexport { auditTime } from './internal/operators/auditTime';\nexport { buffer } from './internal/operators/buffer';\nexport { bufferCount } from './internal/operators/bufferCount';\nexport { bufferTime } from './internal/operators/bufferTime';\nexport { bufferToggle } from './internal/operators/bufferToggle';\nexport { bufferWhen } from './internal/operators/bufferWhen';\nexport { catchError } from './internal/operators/catchError';\nexport { combineAll } from './internal/operators/combineAll';\nexport { combineLatestAll } from './internal/operators/combineLatestAll';\nexport { combineLatestWith } from './internal/operators/combineLatestWith';\nexport { concatAll } from './internal/operators/concatAll';\nexport { concatMap } from './internal/operators/concatMap';\nexport { concatMapTo } from './internal/operators/concatMapTo';\nexport { concatWith } from './internal/operators/concatWith';\nexport { connect, ConnectConfig } from './internal/operators/connect';\nexport { count } from './internal/operators/count';\nexport { debounce } from './internal/operators/debounce';\nexport { debounceTime } from './internal/operators/debounceTime';\nexport { defaultIfEmpty } from './internal/operators/defaultIfEmpty';\nexport { delay } from './internal/operators/delay';\nexport { delayWhen } from './internal/operators/delayWhen';\nexport { dematerialize } from './internal/operators/dematerialize';\nexport { distinct } from './internal/operators/distinct';\nexport { distinctUntilChanged } from './internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from './internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from './internal/operators/elementAt';\nexport { endWith } from './internal/operators/endWith';\nexport { every } from './internal/operators/every';\nexport { exhaust } from './internal/operators/exhaust';\nexport { exhaustAll } from './internal/operators/exhaustAll';\nexport { exhaustMap } from './internal/operators/exhaustMap';\nexport { expand } from './internal/operators/expand';\nexport { filter } from './internal/operators/filter';\nexport { finalize } from './internal/operators/finalize';\nexport { find } from './internal/operators/find';\nexport { findIndex } from './internal/operators/findIndex';\nexport { first } from './internal/operators/first';\nexport { groupBy, BasicGroupByOptions, GroupByOptionsWithElement } from './internal/operators/groupBy';\nexport { ignoreElements } from './internal/operators/ignoreElements';\nexport { isEmpty } from './internal/operators/isEmpty';\nexport { last } from './internal/operators/last';\nexport { map } from './internal/operators/map';\nexport { mapTo } from './internal/operators/mapTo';\nexport { materialize } from './internal/operators/materialize';\nexport { max } from './internal/operators/max';\nexport { mergeAll } from './internal/operators/mergeAll';\nexport { flatMap } from './internal/operators/flatMap';\nexport { mergeMap } from './internal/operators/mergeMap';\nexport { mergeMapTo } from './internal/operators/mergeMapTo';\nexport { mergeScan } from './internal/operators/mergeScan';\nexport { mergeWith } from './internal/operators/mergeWith';\nexport { min } from './internal/operators/min';\nexport { multicast } from './internal/operators/multicast';\nexport { observeOn } from './internal/operators/observeOn';\nexport { onErrorResumeNextWith } from './internal/operators/onErrorResumeNextWith';\nexport { pairwise } from './internal/operators/pairwise';\nexport { pluck } from './internal/operators/pluck';\nexport { publish } from './internal/operators/publish';\nexport { publishBehavior } from './internal/operators/publishBehavior';\nexport { publishLast } from './internal/operators/publishLast';\nexport { publishReplay } from './internal/operators/publishReplay';\nexport { raceWith } from './internal/operators/raceWith';\nexport { reduce } from './internal/operators/reduce';\nexport { repeat, RepeatConfig } from './internal/operators/repeat';\nexport { repeatWhen } from './internal/operators/repeatWhen';\nexport { retry, RetryConfig } from './internal/operators/retry';\nexport { retryWhen } from './internal/operators/retryWhen';\nexport { refCount } from './internal/operators/refCount';\nexport { sample } from './internal/operators/sample';\nexport { sampleTime } from './internal/operators/sampleTime';\nexport { scan } from './internal/operators/scan';\nexport { sequenceEqual } from './internal/operators/sequenceEqual';\nexport { share, ShareConfig } from './internal/operators/share';\nexport { shareReplay, ShareReplayConfig } from './internal/operators/shareReplay';\nexport { single } from './internal/operators/single';\nexport { skip } from './internal/operators/skip';\nexport { skipLast } from './internal/operators/skipLast';\nexport { skipUntil } from './internal/operators/skipUntil';\nexport { skipWhile } from './internal/operators/skipWhile';\nexport { startWith } from './internal/operators/startWith';\nexport { subscribeOn } from './internal/operators/subscribeOn';\nexport { switchAll } from './internal/operators/switchAll';\nexport { switchMap } from './internal/operators/switchMap';\nexport { switchMapTo } from './internal/operators/switchMapTo';\nexport { switchScan } from './internal/operators/switchScan';\nexport { take } from './internal/operators/take';\nexport { takeLast } from './internal/operators/takeLast';\nexport { takeUntil } from './internal/operators/takeUntil';\nexport { takeWhile } from './internal/operators/takeWhile';\nexport { tap, TapObserver } from './internal/operators/tap';\nexport { throttle, ThrottleConfig } from './internal/operators/throttle';\nexport { throttleTime } from './internal/operators/throttleTime';\nexport { throwIfEmpty } from './internal/operators/throwIfEmpty';\nexport { timeInterval } from './internal/operators/timeInterval';\nexport { timeout, TimeoutConfig, TimeoutInfo } from './internal/operators/timeout';\nexport { timeoutWith } from './internal/operators/timeoutWith';\nexport { timestamp } from './internal/operators/timestamp';\nexport { toArray } from './internal/operators/toArray';\nexport { window } from './internal/operators/window';\nexport { windowCount } from './internal/operators/windowCount';\nexport { windowTime } from './internal/operators/windowTime';\nexport { windowToggle } from './internal/operators/windowToggle';\nexport { windowWhen } from './internal/operators/windowWhen';\nexport { withLatestFrom } from './internal/operators/withLatestFrom';\nexport { zipAll } from './internal/operators/zipAll';\nexport { zipWith } from './internal/operators/zipWith';\n","import {\n  setupWalletSelector,\n  VerifiedOwner,\n  VerifyOwnerParams,\n  Wallet,\n} from '@near-wallet-selector/core';\nimport { setupModal } from '@near-wallet-selector/modal-ui';\nimport { map, distinctUntilChanged, Subscription } from 'rxjs';\n\nimport {\n  WALLET_CONNECTION_POLL_INTERVAL,\n  WALLET_CONNECTION_TIMEOUT,\n} from './constants';\n\nimport type {\n  WalletSelector,\n  AccountState,\n  WalletModuleFactory,\n} from '@near-wallet-selector/core';\nimport type { WalletSelectorModal } from '@near-wallet-selector/modal-ui';\n\nimport { setupBitteWallet } from '@bitte-ai/wallet';\n\nimport { setupMeteorWallet } from '@near-wallet-selector/meteor-wallet';\nimport { setupHereWallet } from '@near-wallet-selector/here-wallet';\nimport { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';\n\n\nconst SUPPORT = '- further help available on our telegram channel: https://t.me/mintdev';\n\nexport const ERROR_MESSAGES =  {\n  WALLET_SETUP_NOT_CALLED_ERROR: `Call and await setupWalletSelectorComponents() before registering a subscriber - ${SUPPORT}`,\n  WALLET_CONNECTION_NOT_FOUND:  `Wallet connection not received after ${WALLET_CONNECTION_TIMEOUT}ms - ${SUPPORT}`,\n};\n\nexport const SUPPORTED_NEAR_WALLETS: Array<WalletModuleFactory> =[\n  setupMeteorWallet(),\n  setupMyNearWallet(),\n  setupHereWallet(),\n];\n\nexport type WalletSelectorComponents = {\n  selector: WalletSelector;\n  modal: WalletSelectorModal;\n}\n\n interface ConnectionTimeoutError extends Error {\n  message: string\n}\n\nconst walletUrls = {\n  testnet: 'https://testnet.wallet.bitte.ai/',\n  mainnet: 'https://wallet.bitte.ai',\n};\n\nexport const BitteWalletAuth = {\n  walletSelectorComponents: {\n    selector: null,\n    modal: null,\n  },\n  setupBitteWalletSelector: async (\n    onlyBitteWallet = false,\n    network?: 'testnet' | 'mainnet',\n    options?: { additionalWallets?: Array<WalletModuleFactory> },\n    contractAddress?: string,\n    walletUrl?: string\n  ): Promise<WalletSelectorComponents> => {\n\n    if (onlyBitteWallet === false) {\n      BitteWalletAuth.walletSelectorComponents.selector = await setupWalletSelector({\n        network: network || 'mainnet',\n        modules: [\n          setupBitteWallet() as WalletModuleFactory<Wallet>,\n          ...(options?.additionalWallets || []),\n          ...SUPPORTED_NEAR_WALLETS,\n        ],\n      });\n    } else {\n      BitteWalletAuth.walletSelectorComponents.selector = await setupWalletSelector({\n\n        network: network || 'mainnet',\n        modules: [\n          setupBitteWallet({\n            walletUrl: walletUrl || walletUrls[network as 'mainnet' | 'testnet'],\n          }) as WalletModuleFactory<Wallet>,\n          ...(options?.additionalWallets || []),\n        ],\n      });\n    }\n\n    BitteWalletAuth.walletSelectorComponents.modal = setupModal(BitteWalletAuth.walletSelectorComponents.selector, {\n      contractId: contractAddress,\n    });\n\n    return BitteWalletAuth.walletSelectorComponents;\n  },\n  setupWalletSelectorComponents: async (\n    network?,\n    contractAddress?,\n    options?: { additionalWallets?: Array<WalletModuleFactory> },\n  ): Promise<WalletSelectorComponents> => {\n    const selector = await setupWalletSelector({\n      network: network,\n      modules: [\n        ...SUPPORTED_NEAR_WALLETS,\n        ...(options?.additionalWallets || []),\n      ],\n    });\n\n    const modal = setupModal(selector, {\n      contractId: contractAddress,\n    });\n\n    BitteWalletAuth.walletSelectorComponents = {\n      selector,\n      modal,\n    };\n    return BitteWalletAuth.walletSelectorComponents;\n  },\n  SetupNotCalledError: class extends Error {\n    constructor(message?: string) {\n      super(message);\n      this.name = 'SetupNotCalledError';\n    }\n  },\n  ConnectionTimeoutError: class extends Error {\n    message: string\n  },\n  validateWalletComponentsAreSetup:(): void => {\n    if (!BitteWalletAuth.walletSelectorComponents.selector) {\n      throw new BitteWalletAuth.SetupNotCalledError(ERROR_MESSAGES.WALLET_SETUP_NOT_CALLED_ERROR);\n    }\n  },\n  registerWalletAccountsSubscriber: (\n    callback: (accounts: AccountState[]) => void,\n  ): Subscription => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    return BitteWalletAuth.walletSelectorComponents.selector.store.observable\n      .pipe(\n        map((state:any) => state.accounts),\n        distinctUntilChanged(),\n      )\n      .subscribe(callback);\n  },\n  timerReference: null,\n  pollForWalletConnection: async (): Promise<AccountState[]> => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n    // clear any existing timer\n    clearTimeout(BitteWalletAuth.timerReference);\n\n    const tryToResolveAccountsFromState = (\n      resolve: (value: AccountState[]) => void,\n      reject: (err: ConnectionTimeoutError) => void,\n      elapsed = 0,\n    ): void => {\n      const { accounts } =\n        BitteWalletAuth.walletSelectorComponents.selector.store.getState() || {};\n\n      // accounts present in state\n      if (accounts) {\n        resolve(accounts);\n      }\n\n      // timed out\n      if (elapsed > WALLET_CONNECTION_TIMEOUT) {\n        reject(\n          new ConnectionTimeoutError(ERROR_MESSAGES.WALLET_CONNECTION_NOT_FOUND),\n        );\n      }\n\n      // try again\n      clearTimeout(BitteWalletAuth.timerReference);\n      BitteWalletAuth.timerReference = setTimeout(\n        () =>\n          tryToResolveAccountsFromState(\n            resolve,\n            reject,\n            elapsed + WALLET_CONNECTION_POLL_INTERVAL,\n          ),\n        WALLET_CONNECTION_POLL_INTERVAL,\n      );\n    };\n\n    return new Promise((resolve, reject) =>\n      tryToResolveAccountsFromState(resolve, reject),\n    );\n  },\n  getWallet: async (): Promise<Wallet> => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    return await BitteWalletAuth.walletSelectorComponents.selector.wallet();\n  },\n  connectWalletSelector:(): void => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    BitteWalletAuth.walletSelectorComponents.modal.show();\n  },\n  disconnectFromWalletSelector: async (): Promise<void> => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    const wallet = await BitteWalletAuth.walletSelectorComponents.selector.wallet();\n    wallet.signOut();\n  },\n  getVerifiedOwner: async (\n    params: VerifyOwnerParams,\n  ): Promise<VerifiedOwner | undefined> => {\n    BitteWalletAuth.validateWalletComponentsAreSetup();\n\n    const { message, callbackUrl, meta } = params;\n\n    const wallet = await BitteWalletAuth.walletSelectorComponents.selector.wallet();\n\n    const owner = (await wallet.verifyOwner({\n      message: message,\n      callbackUrl: callbackUrl,\n      meta: meta,\n    })) as VerifiedOwner;\n\n    return owner;\n  },\n  signMessage: async (\n    params: VerifyOwnerParams,\n  ): Promise<VerifiedOwner> => {\n    const owner = await BitteWalletAuth.getVerifiedOwner(params);\n\n    return owner;\n  },\n};","\nexport const NEAR_LOGIN_CONTRACT_ID = process.env.NEAR_LOGIN_CONTRACT_ID;\n\nexport const WALLET_CONNECTION_POLL_INTERVAL = 1_000;\n// how long to wait for the user to make the connection to the wallet.\nexport const WALLET_CONNECTION_TIMEOUT = 30_000;\n\nexport const MINTBASE_CONNECT_HOST = 'https://connect.mintbase.xyz';\n// export const MINTBASE_CONNECT_HOST = 'http://localhost:8000';\n","import React, {\n  createContext,\n  JSX,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { BitteWalletAuth } from \"./wallet/bitte-wallet\";\nimport type { WalletSelectorComponents } from \"./wallet/bitte-wallet\";\n\nimport type {\n  WalletSelector,\n  AccountState,\n  VerifiedOwner,\n  VerifyOwnerParams,\n  WalletModuleFactory,\n} from \"@near-wallet-selector/core\";\nimport type { WalletSelectorModal } from \"@near-wallet-selector/modal-ui\";\n\nexport type BitteWalletContext = {\n  selector: WalletSelector;\n  modal: WalletSelectorModal | undefined;\n  accounts: AccountState[];\n  activeAccountId: string | null;\n  isConnected: boolean;\n  isWaitingForConnection: boolean;\n  isWalletSelectorSetup: boolean;\n  errorMessage: string | null;\n  connect: () => Promise<void>;\n  disconnect: () => Promise<void>;\n  signMessage: (params: VerifyOwnerParams) => Promise<VerifiedOwner>;\n};\n\ninterface ContextProviderType {\n  children: React.ReactNode;\n  network?:  'testnet' | 'mainnet';\n  onlyMbWallet?: boolean;\n  contractAddress?: string;\n  additionalWallets?: Array<WalletModuleFactory>;\n  onlyBitteWallet?: boolean;\n  walletUrl?:string\n}\n\nexport const BitteWalletContext = createContext<BitteWalletContext | null>(\n  null\n);\n\nexport const BitteWalletContextProvider: React.FC<ContextProviderType> = ({\n  children,\n  network,\n  contractAddress,\n  additionalWallets,\n  onlyBitteWallet,\n  walletUrl,\n}): JSX.Element => {\n  const [errorMessage, setErrorMessage] = useState<string | null>(null);\n  const [components, setComponents] = useState<WalletSelectorComponents | null>(\n    null\n  );\n  const [accounts, setAccounts] = useState<AccountState[]>([]);\n  const [isWaitingForConnection, setIsWaitingForConnection] =\n    useState<boolean>(false);\n  const [isWalletSelectorSetup, setIsWalletSelectorSetup] =\n    useState<boolean>(false);\n\n  const selectedNetwork = network;\n  const selectedContract = contractAddress;\n\n  const {\n    setupBitteWalletSelector,\n    registerWalletAccountsSubscriber,\n    connectWalletSelector,\n    pollForWalletConnection,\n    disconnectFromWalletSelector,\n    signMessage,\n  } = BitteWalletAuth;\n\n  const setupBitteWallet = async (): Promise<WalletSelectorComponents> => {\n    const isOnlyBitteWallet =\n      !!onlyBitteWallet ||\n      !!(additionalWallets && additionalWallets.length > 0);\n\n\n    return await setupBitteWalletSelector(\n      isOnlyBitteWallet,\n      selectedNetwork,\n     {additionalWallets: additionalWallets },\n      walletUrl\n    );\n  };\n\n  const setup = useCallback(async () => {\n    const components = await setupBitteWallet();\n\n    setIsWalletSelectorSetup(true);\n    setComponents(components);\n  }, []);\n\n  const onCloseModal = (): void => {\n    setIsWaitingForConnection(false);\n  };\n\n  const setupWallet = async (): Promise<WalletSelectorComponents> => {\n    const components = await setupBitteWallet();\n\n    return components;\n  };\n\n  // call setup on wallet selector\n\n  useEffect(() => {\n    setupWallet();\n\n    setup().catch((err: Error) => {\n      if (err instanceof Error && err.message.length > 0) {\n        setErrorMessage(err.message);\n      }\n    });\n\n    // Add the event listener here\n    const closeButton = document?.getElementsByClassName(\"close-button\")[0];\n    closeButton?.addEventListener(\"click\", onCloseModal);\n\n    // Cleanup the event listener on unmount\n    return (): void => {\n      closeButton?.removeEventListener(\"click\", onCloseModal);\n    };\n  }, [setup]);\n\n  // subscribe to account state changes\n  useEffect(() => {\n    if (!components) {\n      return undefined;\n    }\n\n    const subscription = registerWalletAccountsSubscriber(\n      (accounts: AccountState[]) => {\n        setAccounts(accounts);\n      }\n    );\n\n    return (): void => {\n      subscription.unsubscribe();\n    };\n  }, [components]);\n\n  const { selector, modal } = components || {};\n\n\n\n  const connect = async (): Promise<void> => {\n    setIsWaitingForConnection(true);\n\n    setErrorMessage(null);\n    connectWalletSelector();\n\n    try {\n      const accounts = await pollForWalletConnection();\n      setIsWaitingForConnection(false);\n      setAccounts(accounts);\n    } catch (err: unknown) {\n      if (err) {\n        setErrorMessage((err as Error).message);\n      }\n    }\n  };\n\n  const disconnect = async (): Promise<void> => {\n    await disconnectFromWalletSelector();\n    setIsWaitingForConnection(false);\n  };\n\n  const contextVal = useMemo<BitteWalletContext>(\n    () => ({\n      selector: selector as WalletSelector,\n      modal: modal,\n      accounts: accounts,\n      activeAccountId:\n        accounts.find((account) => account.active)?.accountId || null,\n      isConnected: accounts && accounts.length > 0,\n      isWaitingForConnection: isWaitingForConnection,\n      isWalletSelectorSetup: isWalletSelectorSetup,\n      errorMessage: errorMessage,\n      connect,\n      disconnect,\n      signMessage,\n    }),\n    [selector, modal, accounts]\n  );\n\n  return (\n    <BitteWalletContext.Provider value={contextVal}>\n      {children}\n    </BitteWalletContext.Provider>\n  );\n};\n\nexport const useBitteWallet = (): BitteWalletContext => {\n  const context = useContext(BitteWalletContext);\n  if (!context) {\n    throw new Error(\n      \"useBitteWallet must be used within a BitteWalletContextProvider\"\n    );\n  }\n  return context;\n};\n","import { useEffect, useState } from 'react';\n\ntype UseNearPriceReturn = {\n  nearPrice: number;\n  error: string | null;\n}\n\nexport const useNearPrice = (): UseNearPriceReturn => {\n  const [price, setPrice] = useState<number>(0);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const nearPriceData = async (): Promise<void> => {\n      const { data, error } = await nearPrice();\n      if (error) {\n        setError(error);\n        return;\n      }\n      setPrice(Number(data));\n    };\n    nearPriceData();\n  }, []);\n\n  return {\n    nearPrice: price,\n    error,\n  };\n};\n\n// Coppied from archived repo: https://github.com/Mintbase/mintbase-js/blob/1661bb879eae3ae4f3e525e69bb2c1aeed1ef77f/packages/data/src/api/nearPrice/nearPrice.ts#L17\nconst BINANCE_API = 'https://api.binance.com/api/v3/ticker/price?symbol=NEARUSDT';\n\nexport interface ParsedDataReturn<T> {\n  error?: null | string;\n  data?: T | null;\n}\n\nexport interface NearPriceData  {\n    price?: string;\n}\nexport interface CoinGeckoNearPriceData {\n    near?: {\n        usd: string;\n    };\n}\n\n\nexport const nearPrice = async (): Promise<ParsedDataReturn<string>> => {\n  try {\n    const req = await fetch(BINANCE_API);\n    const data: NearPriceData = await req.json();\n    return {data: data.price || \"0\"};\n  } catch (err: unknown) {\n    console.error(\n      `Failed to retrieve near price ${err}`,\n    );\n    return {data: \"0\"};\n  }\n};"]}